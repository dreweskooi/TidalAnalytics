<?xml version="1.0" encoding="utf-8" ?>    
<queries>   
    <query>  
        <queryname>100 Objects related to connection</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>n</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
      select 'tsksch' as [table], tsksch_id as [id] , nodmst.nodmst_id, nodmst.nodmst_name   from tsksch, nodmst where tsksch.nodmst_id = nodmst.nodmst_id and tsksch.nodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'infonode' as [table], infonode_id as [id],  nodmst.nodmst_id, nodmst.nodmst_name  from infonode, nodmst where infonodmst_id = nodmst.nodmst_id and infonodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobdtl' as [table], jobdtl_id as [id], nodmst.nodmst_id, nodmst.nodmst_name   from jobdtl, nodmst where jobdtl.nodmst_id = nodmst.nodmst_id and jobdtl.nodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobreport' as [table], jobreport_id as [id], runnodmst_id, nodmst.nodmst_name   from jobreport, nodmst  where jobreport.runnodmst_id = nodmst.nodmst_id and jobreport.runnodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobrun' as [table], jobrun_id as [id], nodmst.nodmst_id, nodmst.nodmst_name   from jobrun, nodmst where nodmst.nodmst_id = jobrun.nodmst_id and nodmst.nodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'trgmst' as [table], trgmst_id as [id], nodmst.nodmst_id, nodmst.nodmst_name   from trgmst, nodmst where nodmst.nodmst_id = trgmst.nodmst_id and nodmst.nodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'tsklmst' as [table], tskmst_id as [id],  nodmst.nodmst_id, nodmst.nodmst_name   from tskmst, nodmst where nodmst.nodmst_id = tskmst.nodmst_id and nodmst.nodmst_id in (select nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select 'tsksch'  tble , tsksch_id  id  , nodmst.nodmst_id, nodmst.nodmst_name   from tidal.tsksch, nodmst where tsksch.nodmst_id = nodmst.nodmst_id and tsksch.nodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'infonode'  tble , infonode_id  id ,  nodmst.nodmst_id, nodmst.nodmst_name  from tidal.infonode, nodmst where infonodmst_id = nodmst.nodmst_id and infonodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobdtl'  tble , jobdtl_id  id , nodmst.nodmst_id, nodmst.nodmst_name   from tidal.jobdtl, nodmst where jobdtl.nodmst_id = nodmst.nodmst_id and jobdtl.nodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobreport'  tble , jobreport_id  id , runnodmst_id, nodmst.nodmst_name   from tidal.jobreport, nodmst  where jobreport.runnodmst_id = nodmst.nodmst_id and jobreport.runnodmst_id in (select tidal.nodmst_id from nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'jobrun'  tble , jobrun_id  id , nodmst.nodmst_id, nodmst.nodmst_name   from tidal.jobrun, nodmst where nodmst.nodmst_id = jobrun.nodmst_id and nodmst.nodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'trgmst'  tble , trgmst_id  id , nodmst.nodmst_id, nodmst.nodmst_name   from tidal.trgmst, nodmst where nodmst.nodmst_id = trgmst.nodmst_id and nodmst.nodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
      union
      select 'tsklmst'  tble , tskmst_id  id ,  nodmst.nodmst_id, nodmst.nodmst_name   from tidal.tskmst, nodmst where nodmst.nodmst_id = tskmst.nodmst_id and nodmst.nodmst_id in (select nodmst_id from tidal.nodmst where nodmst_name like '<<agentname>><<%>>')
         ]]>
        </querytext_oracle>
    </query> 
    <query>
        <queryname>102 Objects that contain search string</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'jobdtl' as [where_found], jobmst_id as [id], 'Cmd: ' + jobdtl_cmd +' parms: ' + jobdtl_params + convert(varchar(250),jobmst.jobmst_id) + ' ' + jobmst.jobmst_name Context   from jobdtl, jobmst where jobdtl.jobdtl_id = jobmst.jobdtl_id and not jobmst_dirty = 'X' and (jobdtl_cmd  like '<<search_string>>' or jobdtl_params like '<<search_string>>')
      union
      select 'msglog' as [where_found], msglog_id as [id], 'Text: ' + substring(msglog_text,0,100) Context from msglog where msglog_text  like '<<search_string>>' 
      union
      select 'tskalrt' as [where_found], tskalrt_id as [id], concat('Msg: ',tskalrt_msg) Context  from tskalrt where tskalrt_msg  like '<<search_string>>' 
      union
      select 'usrmst' as [where_found], usrmst_id as [id], concat('Usrmst name: ',usrmst_name,' ', usrmst_fullname, ' ', usrmst_email) Context  from usrmst where usrmst_name  like '<<search_string>>' or usrmst_fullname  like '<<search_string>>' or usrmst_email  like '<<search_string>>' 
      union
      select 'tskmail' as [where_found], tskmail_id as [id], concat('Subject: ',tskmail_subject) Context  from tskmail where tskmail_subject  like '<<search_string>>' 

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 select 'jobdtl'  where_found, jobmst_id as id, 'Cmd: ' || jobdtl_cmd ||' parms: ' || to_char(jobdtl_params) + to_char(jobmst.jobmst_id) || ' ' || jobmst.jobmst_name Context   from jobdtl, jobmst where jobdtl.jobdtl_id = jobmst.jobdtl_id and not jobmst_dirty = 'X' and (jobdtl_cmd  like '<<search_string>>' or jobdtl_params like '<<search_string>>')
      union
      select 'msglog' as where_found, msglog_id as id, 'Text: ' || substr(msglog_text,0,100) Context from msglog where msglog_text  like '<<search_string>>' 
      union
      select 'tskalrt' as where_found, tskalrt_id as id, concat('Msg: ',tskalrt_msg) Context  from tskalrt where tskalrt_msg  like '<<search_string>>' 
      union
      select 'usrmst' as where_found, usrmst_id as id, 'Usrmst name: ' ||usrmst_name ||' ' || usrmst_fullname || ' ' || usrmst_email Context  from usrmst where usrmst_name  like '<<search_string>>' or usrmst_fullname  like '<<search_string>>' or usrmst_email  like '<<search_string>>' 
      union
      select 'tskmail' as where_found, tskmail_id as id, concat('Subject: ',tskmail_subject) Context  from tskmail where tskmail_subject  like '<<search_string>>' 

            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>103 Objects that contain search string all tables</queryname>
        <category>search</category>
        <linkquery>104</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
DECLARE @SQL VARCHAR(MAX) 
DECLARE @SearchString VARCHAR(100) 
SET @SQL='' 
-- ------------------------------------------ 
-- Enter the string to be searched for here : 
-- 
SET @SearchString='<<search_text>>' 
-- ------------------------------------------ 
SELECT   @SQL = @SQL + 'SELECT ''' +  T.name + ''' _table, ''' + C.name + ''' _column, CONVERT(VARCHAR(MAX),COUNT(*)) + '' matches in column ''+'''
         + C.name + '''+'' on table '' + ''' + T.name + 
         ''' [Matches]  FROM ' + 
         QUOTENAME(SC.name) + '.' + QUOTENAME(T.name) + ' WHERE ' + QUOTENAME(C.name) + 
         ' LIKE ''%' + @SearchString + 
         '%'' HAVING  COUNT(*)>0 UNION ALL ' +CHAR(13) + CHAR(10) 
FROM     sys.columns C 
JOIN     sys.tables T 
ON C.object_id=T.object_id 
JOIN     sys.schemas SC 
ON SC.schema_id=T.schema_id 
JOIN     sys.types ST 
ON C.user_type_id=ST.user_type_id 
JOIN     sys.types SYST 
ON ST.system_type_id=SYST.user_type_id 
AND ST.system_type_id=SYST.system_type_id 
WHERE    SYST.name IN ('varchar','nvarchar','text','ntext','char','nchar') and not T.name in ('msglog','joboutput','jobrun','jobrunx','trgtskrun','servicedist','servicemst','imagemst', 'strmst','sysval','usersession')
ORDER BY T.name, C.name 
-- Strip off the last UNION ALL 
IF LEN(@SQL)>12 
  SELECT @SQL=LEFT(@SQL,LEN(@SQL)- 12) 
EXEC(@SQL) 

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT X.*
FROM (SELECT '' AS jobdtl_name) AS dummy
CROSS APPLY
(
  SELECT
        '<<table>>' [table], <<table>>_id [id],  '<<column>>' [column], <<column>>  [data] from <<table>> where <<column>> like '<<search_text>>'
) AS X;
     ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select '<<table>>' [table], <<table>>_id [id], '<<column>>' [column],  case when COL_LENGTH('<<table>>','<<table>>_name') is not null then 'Name: ' +  <<table>>_name else '' end  + ', ID: ' + convert(varchar(10),<<table>>_id) + ', Data: ' + convert(varchar(2500),<<column>>) [data] from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104jobdtl</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'jobdtl' [table],'<<column>>' [column], 'Job Name: ' + coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst_name + ', ID:' + convert(varchar(10),jobmst_id) + ', Data: ' + convert(varchar(2500),jobdtl.<<column>>) [data] from jobmst,jobdtl  where jobdtl.jobdtl_id = jobmst.jobdtl_id and not jobmst.jobmst_dirty = 'X' and jobdtl.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '<<search_text>>'
            ]]>
        </querytext_oracle>
    </query>
     <query>
        <queryname>104jobmst</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'jobmst' [table],'<<column>>' [column], 'Job Name: ' + coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst_name + ', ID:' + convert(varchar(10),jobmst_id) + ', Data: ' + convert(varchar(2500),jobmst.<<column>>) [data] from jobmst  where not jobmst.jobmst_dirty ='X' and jobmst.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '<<search_text>>'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104jobdep</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'jobdep' [table],'<<column>>' [column], 'Job Name: ' + coalesce(jobmst.jobmst_prntname,'') + '\' +  jobmst_name + ', ID:' + convert(varchar(10),jobmst.jobmst_id) + ', Data: ' + convert(varchar(2500),jobdep.<<column>>) [data] from jobmst,jobdep  where jobdep.jobmst_id = jobmst.jobmst_id and not jobmst.jobmst_dirty = 'X' and jobdep.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
  select 'jobdep' [table],'<<column>>' [column], 'Name: ' + jobmst_name + ', ID:' + convert(varchar(250),jobmst_id) + ', Data: ' + convert(varchar(2500),jobdtl.<<column>>) [data] from jobmst,jobdep  where jobdep.jobmst_id = jobmst.jobmst_id and not jobmst.jobmst_dirty = 'X' and jobdep.<<column>> like '%<<search_text>>%'            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tskmail</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'tskmail' [table], '<<column>>' [column],  'Name:' + tskmst_name + ', Desc: ' + coalesce(tskmst_desc,'') + ', Data: ' +  convert(varchar(2500),tskmail.<<column>>) [data] from tskmst,tskmail  where tskmst_id  = tskmail_id and tskmail.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tskalrt</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tskalrt.<<column>> from tskmst,tskalrt  where tskmst_id  = tskalrt_id and tskalrt.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tsklog</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tsklog.<<column>> from tskmst,tsklog  where tskmst_id  = tsklog_id and tsklog.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tskmst</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select 'tskmst' [table], '<<column>>' [column], 'Name: ' + tskmst_name + ', Desc: ' +  convert(varchar(200), tskmst.<<column>>) data from tskmst where  tskmst.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tsksch</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tsksch.<<column>> from tskmst,tsksch  where tskmst_id  = tsksch_id and tsksch.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tskservice</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tskservice.<<column>> from tskmst,tskservice  where tskmst_id  = tskservice_id and tskservice.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tskvar</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tskvar.<<column>> from tskmst,tskvar  where tskmst_id  = tskvar_id and tskvar.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>104tsksnmp</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      select tskmst_name, tskmst_desc, tsksnmp.<<column>> from tskmst,tsksnmp  where tskmst_id  = tsksnmp_id and tsksnmp.<<column>> like '%<<search_text>>%'
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select <<table>>_id, <<table>>_name, <<column>> from <<table>> where <<column>> like '%<<search_text>>%'
            ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>105 Show rows per table and size of data in table</queryname>
        <category>database</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
SELECT 
t.Name AS table_name,
p.rows AS row_count,
CAST(ROUND((SUM(a.used_pages) / 128), 0) as varchar(10)) AS used_mb,
CAST(ROUND((SUM(a.total_pages) - SUM(a.used_pages)) / 128, 0) AS varchar(10)) AS unused_mb,
CAST(ROUND((SUM(a.total_pages) / 128), 0) AS varchar(10)) AS total_mb
FROM sys.tables t
INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id
INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
WHERE (
t.name IN ('msglog','jobrun','jobmst','jobdtl','trgjob','jobrunx','joboutput','jobdep','trgjob','trgtskrun','usreqv','workusr','trgmst','','','','','','','','','','') or 
	p.rows > 100
)
GROUP BY t.Name, s.Name, p.Rows
ORDER BY row_count desc, s.Name, t.Name

    </querytext_sqlserver>
        <querytext_oracle>
      SELECT lower(table_name)  AS table_name ,tablespace_name ,num_rows ,blocks*8/1024      AS size_mb ,pct_free ,compression ,logging FROM    all_tables WHERE   owner = 'TIDAL' ORDER BY 3 desc
    </querytext_oracle>
    </query>
    <query>
        <queryname>106 Show database table Rows by date</queryname>
        <category>database</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>ProdDate,TotalRows</chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
SELECT      CONVERT(varchar(10), STATUS_DATE, 120) AS ProdDate ,  SUM(ROW_COUNT) AS TotalRows, SUM(TOTAL_MB) AS TotalMb
FROM            TABLE_SIZE_HISTORY
GROUP BY CONVERT(varchar(10), STATUS_DATE, 120)  order by CONVERT(varchar(10), STATUS_DATE, 120)
    </querytext_sqlserver>
        <querytext_oracle>
SELECT      to_date(STATUS_DATE) ProdDate,  SUM(ROW_COUNT) AS TotalRows, SUM(TOTAL_MB) AS TotalMb
FROM            TABLE_SIZE_HISTORY
GROUP BY STATUS_DATE    
</querytext_oracle>
    </query>
    <query>
        <queryname>107 Monthly Database Rowcount comparison</queryname>
        <category>database</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
         <![CDATA[

with cte as (
SELECT  TABLE_NAME Table_Name,    
 cast(datepart(yyyy,status_date) as varchar) + '_' + CONVERT(varchar(2),status_date, 101) yy_mm,
 DATEDIFF(MONTH, '20130101', status_date) month,
  avg(ROW_COUNT) AS TotalRows, avg(TOTAL_MB) AS TotalMB
FROM            TABLE_SIZE_HISTORY
GROUP BY table_size_history.TABLE_NAME, cast(datepart(yyyy,status_date) as varchar) + '_' + CONVERT(varchar(2),status_date, 101),
 DATEDIFF(MONTH, '20130101', status_date)
 ) 
  select cur_month.TABLE_NAME Table_Name, cur_month.yy_mm current_Month, cur_month.TotalRows current_Rows, prev_month.yy_mm prevous_Month, prev_month.TotalRows previous_Rows, 
 ((cur_month.TotalRows - prev_month.TotalRows) * 100) / case  when prev_month.TotalRows < 1 then 1 else prev_month.TotalRows end pct_difference
  from cte cur_month, cte prev_month 
 where 
 cur_month.month - <<months_back:1>> = prev_month.month  
 and cur_month.TABLE_NAME = prev_month.TABLE_NAME
 and abs(((cur_month.TotalRows - prev_month.TotalRows) * 100) / case  when prev_month.TotalRows < 1 then 1 else prev_month.TotalRows end) >= <<change_pct:10>> 
 and DATEDIFF(month, '20130101', getdate()) = cur_month.month
 order by  TABLE_NAME, cur_month.month desc

   ]]>   
 </querytext_sqlserver>
    <querytext_oracle>
    </querytext_oracle>
    </query>
    <query>
        <queryname>108 Weekly Database Rowcount comparison</queryname>
        <category>database</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
         <![CDATA[
with cte as (
SELECT    TABLE_NAme Table_Name,  
 cast(datepart(yyyy,status_date) as varchar) + '_' + cast(DATEPART(wk, status_date)  as varchar) yy_ww,
 DATEDIFF(week, '20130101', status_date) [week],
  avg(ROW_COUNT) AS TotalRows, avg(TOTAL_MB) AS TotalMB
FROM            TABLE_SIZE_HISTORY
GROUP BY table_size_history.TABLE_NAME, cast(datepart(yyyy,status_date) as varchar) + '_' +   cast(DATEPART(wk, status_date)  as varchar),
 DATEDIFF(week, '20130101', status_date)
 ) 
  select  cur_week.TABLE_NAME Table_Name, cur_week.yy_ww current_Week, cur_week.TotalRows current_Rows, prev_week.yy_ww previous_Week, prev_week.TotalRows previous_Rows, 
 ((cur_week.TotalRows - prev_week.TotalRows) * 100) / case  when prev_week.TotalRows < 1 then 1 else prev_week.TotalRows end pct_difference
  from cte cur_week, cte prev_week 
 where 
 cur_week.week - <<weeks_back:1>> = prev_week.week 
 and cur_week.Table_Name = prev_week.Table_Name
 and abs(((cur_week.TotalRows - prev_week.TotalRows) * 100) / case  when prev_week.TotalRows < 1 then 1 else prev_week.TotalRows end) >= <<change_pct:10>>
 and DATEDIFF(week, '20130101', getdate()) = cur_week.week
 order by  cur_week.week desc
   ]]>   
 </querytext_sqlserver>
    <querytext_oracle>
    </querytext_oracle>
    </query>
 
    <query>
        <queryname>110 Job Definition Data by JobGroup</queryname>
        <category>Jobs</category>
        <querytotals>Total Jobs:count(jobmst_id)</querytotals>
        <linkquery>401 Job Dependencies</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
          
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_runbook,
  jobdtl_envfile,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(REPLACE(STR(m.jobmst_id,8),' ',0) as varchar(1000)) as fullpath,
  --cast(REPLACE(STR(jobmst_id,8),' ','0')) as varchar(1000))  as fullpath,
  0 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  jobdtl_envfile,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + REPLACE(STR(m.jobmst_id,8),' ','0') as varchar(1000)),
  mt.lvls +1 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  d.jobdtl_envfile,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'Group' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=6 then 'OS400' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  cast(jde.jobdtl_cmd as varchar(4000)) jobdtl_cmd,
  cast(jobdtl_params as varchar(4000)) jobdtl_params,
  jde.jobmst_active,
  owner_name Owner,
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_runbook Runbook,
  jobdtl_envfile EnvironmentFile,
  cast(jobdtl_extinfo as varchar(4000)) jobdtl_extinfo,
  jobdtl_retnsn,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 lvl,
  fullpath,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 [$$treeLevel]
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  where Jobname like '<<Job_name:%>>' and  coalesce(JobGroup,'') like '<<JobGroup:%>>'
order by fullpath

     ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,' ') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) || '\' || cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' || JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active,
  owner_name "Owner",
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_extinfo,
  jobdtl_retnsn,
  length(coalesce(JobGroup,' ')) -  length(replace(coalesce(JobGroup,' '),'\',' ')) lvl,
  fullpath,
  length(coalesce(JobGroup,' ')) - length(replace(coalesce(JobGroup,' '),'\','')) "$$treeLevel"
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  where Jobname like '<<Job_name:%>>' and  coalesce(JobGroup,'') like '<<JobGroup:%>>'
order by fullpath

	  ]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>Transporter JobGroup Data</queryname>
        <category>Jobs</category>
        <querytotals>Total Jobs:count(jobmst_id)</querytotals>
        <linkquery>401 Job Dependencies</linkquery><querydescription>JobGroup Data</querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <cachetimeout>3600</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_runbook,
  jobdtl_envfile,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(REPLACE(STR(m.jobmst_id,8),' ',0) as varchar(1000)) as fullpath,
  --cast(REPLACE(STR(jobmst_id,8),' ','0')) as varchar(1000))  as fullpath,
  0 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  jobdtl_envfile,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + REPLACE(STR(m.jobmst_id,8),' ','0') as varchar(1000)),
  mt.lvls +1 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  d.jobdtl_envfile,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X' 
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'Group' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end JobGroup,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end entityName,
  coalesce(evntmst_name,'') Calendar,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  jde.jobmst_active,
  owner_name Owner,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 lvl,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 [$$treeLevel]
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
where jobmst_type = 1
order by fullpath
     ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,' ') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) || '\' || cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' || JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active,
  owner_name "Owner",
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_extinfo,
  jobdtl_retnsn,
  length(coalesce(JobGroup,' ')) -  length(replace(coalesce(JobGroup,' '),'\',' ')) lvl,
  fullpath,
  length(coalesce(JobGroup,' ')) - length(replace(coalesce(JobGroup,' '),'\','')) "$$treeLevel"
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  where Jobname like '<<Job_name:%>>' and  coalesce(JobGroup,'') like '<<JobGroup:%>>'
order by fullpath

	  ]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>Transporter Job Data</queryname>
        <category>Jobs</category>
        <querytotals>Total Jobs:count(jobmst_id)</querytotals>
        <linkquery>401 Job Dependencies</linkquery><querydescription>Job Data</querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <cachetimeout>3600</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_runbook,
  jobdtl_envfile,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(REPLACE(STR(m.jobmst_id,8),' ',0) as varchar(1000)) as fullpath,
  --cast(REPLACE(STR(jobmst_id,8),' ','0')) as varchar(1000))  as fullpath,
  0 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  jobdtl_envfile,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + REPLACE(STR(m.jobmst_id,8),' ','0') as varchar(1000)),
  mt.lvls +1 as lvls,
  case when m.jobmst_type = 1 and m.jobmst_prntid  is null then '\' + m.jobmst_name else coalesce(m.jobmst_prntname,'') + '\' + m.jobmst_name end as [JobGroup],
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_runbook,
  d.jobdtl_envfile,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X' 
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'Group' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end JobGroup,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end entityName,
  coalesce(evntmst_name,'') Calendar,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  jde.jobmst_active,
  owner_name Owner,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 lvl,
  len(coalesce('\' + fullpath,'')) -  len(replace('\' + fullpath,'\','')) - 1 [$$treeLevel]
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
order by fullpath
     ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,' ') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) || '\' || cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' || JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active,
  owner_name "Owner",
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_extinfo,
  jobdtl_retnsn,
  length(coalesce(JobGroup,' ')) -  length(replace(coalesce(JobGroup,' '),'\',' ')) lvl,
  fullpath,
  length(coalesce(JobGroup,' ')) - length(replace(coalesce(JobGroup,' '),'\','')) "$$treeLevel"
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  where Jobname like '<<Job_name:%>>' and  coalesce(JobGroup,'') like '<<JobGroup:%>>'
order by fullpath

	  ]]>
        </querytext_oracle>
    </query>



    <query>
        <queryname>111 Job Definition Data</queryname>
        <category>jobs</category>
        <querytotals>Total Jobs:count(jobmst_id)</querytotals>
        <linkquery>401 Job Dependencies</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobdtl_envfile,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  d.jobdtl_envfile,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  d.jobdtl_envfile,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  case when D.jobdtl_inhagent = 'Y' then mt.jobdtl_proxy else D.jobdtl_proxy end as jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'Group' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' + JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  case  coalesce(evntmst_name,'') when '' then 'N' else 'Y' end Scheduled,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(jc.jobcls_name,'') Jobclass,
  coalesce(nl.nodlstmst_name,'') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active Enabled,
  owner_name owner,
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobdtl_extinfo ExtendedInfo,
  jobmst_desc Notes,
  jobmst_runbook RunBook,
  jobdtl_envfile EnviromentFile,
  jobmst_lstchgtm LastUpdated,
  len(coalesce(JobGroup,'')) -  len(replace(coalesce(JobGroup,''),'\','')) lvl,
  --len(coalesce(JobGroup,'')) -  len(replace(coalesce(JobGroup,''),'\','')) [$$treeLevel],
  fullpath
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
  where Jobname like '<<Job_name:%>>' and
  coalesce(JobGroup,'') like '<<JobGroup:%>>' and
  coalesce(evntmst_name,'') like '<<Calendar:%>>' and
  coalesce(n.nodmst_name,'') like '<<Agent:%>>' and 
  jobmst_lstchgtm >= '<<updated_after_date:1985-01-01>>'
order by fullpath
    ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo1,
  jobdtl_extinfo2,
  jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  0 as lvls,
  case m.jobmst_type when 1 then  cast('\' as varchar(1)) || cast(m.jobmst_name as varchar(1000)) else ' ' end  JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,  
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  substr(jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  mt.lvls +1 as lvls,
  case m.jobmst_type when 1 then  cast((mt.JobGroup || cast('\' as varchar(1)) || m.jobmst_name) as varchar(1000)) else mt.JobGroup end JobGroup  ,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  substr(d.jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(d.jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(d.jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  d.jobdtl_saveoutput,
  d.jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' 
    when jobmst_type=2 then 'Job'
    when jobmst_type=6 then 'FTP'          
    when jobmst_type=7 then 'AS400' 
    when jobmst_type=8 then 'Adapter' 
    else to_char(jobmst_type) end JobType,
  JobName,
  case when jobmst_type = 1 and coalesce(JobGroup,'') = '' then '\' || JobName else coalesce(JobGroup,'') end JobGroup,
  coalesce(evntmst_name,'') Calendar,
  case  coalesce(evntmst_name,'') when '' then 'N' else 'Y' end Scheduled,
  jde.nodmst_id,
  coalesce(n.NODMST_NAME,' ') Agent,
  coalesce(jc.jobcls_name,'') Jobclass,  
  cast(jde.jobdtl_cmd as varchar(4000)) jobdtl_cmd,
  cast(jobdtl_params as varchar(4000)) jobdtl_params,
  jde.jobmst_active Enabled,
  owner_name "Owner",
  U.USRMST_NAME RuntimeUser,
  JOBDTL_INHAGENT,
  jobdtl_INHEVENT,
  jobdtl_INHTIME,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_desc,
  jobmst_runbook,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_lstchgtm "LastUpdated",
  jobdtl_extinfo1 "ExtendedInfo1",
  jobdtl_extinfo2 "ExtendedInfo2",
  jobdtl_extinfo3 "ExtendedInfo3",
  '' "ExtendedInfo"
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
 where JobName like '<<job_name>>' and JobGroup like '<<jobgroup>>'
	  ]]>
        </querytext_oracle>
    </query>
 <query>
        <queryname>112 Job related data</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select * from (
SELECT        jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end jobmst_type, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, '' related, '' details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_id, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'command' related, jobdtl.jobdtl_cmd details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'parameters' related, cast(jobdtl.jobdtl_params as varchar) details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'calendar' AS related, isnull(evntmst.evntmst_name,'') as details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                         evntmst ON jobmst.evntmst_id = evntmst.evntmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') jobmst_prntname, jobmst.jobmst_name, 'agent' AS related, isnull(nodmst.nodmst_name,'')  AS details 
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                         nodmst ON jobdtl.nodmst_id = nodmst.nodmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'agentlist' AS related, nodlstms.nodlstmst_name as details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id INNER JOIN
                         nodlstms ON jobdtl.nodlstmst_id = nodlstms.nodlstmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst.jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'jobdep' related, concat(jobmst_1.jobmst_name, jobmst_1.jobmst_prntname, ' ', jobdep.jobdep_status) details
FROM            jobmst INNER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                         jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 1)
union
SELECT        jobmst.jobmst_id, case when jobmst.jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'filedep' related, concat(jobdep.jobdep_filename, ' ', jobdep.jobdep_filetype) details
FROM            jobmst INNER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                         jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 2)

union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end jobmst_type, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'event' AS related, CONCAT(trgmst.trgmst_name, ' ', trgjob.trgjob_type) AS details
FROM            trgmst INNER JOIN
                         trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
) v1 
order by jobmst_prntname, jobmst_name, related, details
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
select * from (
SELECT        jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end jobmst_type, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, '' related, '' details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'command' related, jobdtl.jobdtl_cmd details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'parameters' related, cast(jobdtl.jobdtl_params as varchar) details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'calendar' AS related, isnull(evntmst.evntmst_name,'') as details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                         evntmst ON jobmst.evntmst_id = evntmst.evntmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') jobmst_prntname, jobmst.jobmst_name, 'agent' AS related, isnull(nodmst.nodmst_name,'')  AS details 
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                         nodmst ON jobdtl.nodmst_id = nodmst.nodmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'agentlist' AS related, nodlstms.nodlstmst_name as details
FROM            jobmst INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id INNER JOIN
                         nodlstms ON jobdtl.nodlstmst_id = nodlstms.nodlstmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        jobmst.jobmst_id, case when jobmst.jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'jobdep' related, concat(jobmst_1.jobmst_name, jobmst_1.jobmst_prntname, ' ', jobdep.jobdep_status) details
FROM            jobmst INNER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                         jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 1)
union
SELECT        jobmst.jobmst_id, case when jobmst.jobmst_type = 1 then 'JobGroup' else 'Job' end, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'filedep' related, concat(jobdep.jobdep_filename, ' ', jobdep.jobdep_filetype) details
FROM            jobmst INNER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                         jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 2)

union
SELECT        jobmst.jobmst_id, case when jobmst_type = 1 then 'JobGroup' else 'Job' end jobmst_type, jobmst.jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'event' AS related, CONCAT(trgmst.trgmst_name, ' ', trgjob.trgjob_type) AS details
FROM            trgmst INNER JOIN
                         trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
) v1 
order by jobmst_prntname, jobmst_name, related, details
      ]]>
    </querytext_oracle>
    </query>   
    <query>
        <queryname>114 Show jobs per agent</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
      SELECT     dbo.nodmst.nodmst_name, dbo.nodmst.nodmst_active, dbo.nodmst.nodmst_id, dbo.jobmst.jobmst_prntname,
      dbo.jobmst.jobmst_name, dbo.jobmst.jobmst_dirty
      FROM         dbo.nodmst INNER JOIN
      dbo.jobdtl ON dbo.nodmst.nodmst_id = dbo.jobdtl.nodmst_id INNER JOIN
      dbo.jobmst ON dbo.jobdtl.jobdtl_id = dbo.jobmst.jobdtl_id
      WHERE     (dbo.jobmst.jobmst_dirty != 'X')
      ORDER BY dbo.nodmst.nodmst_active, dbo.nodmst.nodmst_name, dbo.jobmst.jobmst_prntname, dbo.jobmst.jobmst_name
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
            SELECT     nodmst.nodmst_name, nodmst.nodmst_active, nodmst.nodmst_id, jobmst.jobmst_prntname,
      jobmst.jobmst_name, jobmst.jobmst_dirty
      FROM         tidal.nodmst INNER JOIN
      tidal.jobdtl ON nodmst.nodmst_id = jobdtl.nodmst_id INNER JOIN
      tidal.jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id
      WHERE     (jobmst.jobmst_dirty != 'X')
      ORDER BY nodmst.nodmst_active, nodmst.nodmst_name, jobmst.jobmst_prntname, jobmst.jobmst_name
      ]]>
    </querytext_oracle>
    </query>
    <query>
      <queryname>112 Job related data compare</queryname>
      <category>jobs</category>
      <linkquery></linkquery><querydescription></querydescription>
      <db>admiral</db>
      <chartfields></chartfields>
      <import_oracle>y</import_oracle>
      <querytext_sqlserver>
          <![CDATA[
select * from (
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname,jobmst.jobmst_name, '' related, '' details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X')
union
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname,jobmst.jobmst_name, 'command' related,  jobdtl.jobdtl_cmd details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X')
union
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname,jobmst.jobmst_name, 'parameters' related, REPLACE(REPLACE(CAST(jobdtl_params AS VARCHAR), CHAR(13), ' '), CHAR(10), ' ') details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X')
union
SELECT        ISNULL(jobmst.jobmst_prntname, '_') AS jobmst_prntname, jobmst.jobmst_name, 'calendar' AS related, isnull(evntmst.evntmst_name,case when jobdtl_inhevent = 'Y' then 'Inherited' else '' end) as details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                       evntmst ON jobmst.evntmst_id = evntmst.evntmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        ISNULL(jobmst.jobmst_prntname, '_') jobmst_prntname, jobmst.jobmst_name, 'agent' AS related, isnull(nodmst.nodmst_name, case when jobdtl_inhagent = 'Y' then 'Inherited' else '' end)  AS details 
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                       nodmst ON jobdtl.nodmst_id = nodmst.nodmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        ISNULL(jobmst.jobmst_prntname, '_') AS jobmst_prntname, jobmst.jobmst_name, 'agentlist' AS related, nodlstms.nodlstmst_name as details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id INNER JOIN
                       nodlstms ON jobdtl.nodlstmst_id = nodlstms.nodlstmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname, jobmst.jobmst_name, 'jobdep' related, concat(jobmst_1.jobmst_name, jobmst_1.jobmst_prntname, ' ', jobdep.jobdep_status) details
FROM            jobmst INNER JOIN
                       jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                       jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 1)
union
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname, jobmst.jobmst_name, 'filedep' related, concat(jobdep.jobdep_filename, ' ', jobdep.jobdep_filetype) details
FROM            jobmst INNER JOIN
                       jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                       jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 2)

union
SELECT        isnull(jobmst.jobmst_prntname,'_') jobmst_prntname, jobmst.jobmst_name, 'event' AS related, CONCAT(trgmst.trgmst_name, ' ', trgjob.trgjob_type) AS details
FROM            trgmst INNER JOIN
                       trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                       jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
) v1 
where (jobmst_prntname like '\<<jobgroup>>\%' or jobmst_prntname like '\<<jobgroup>>') or (jobmst_name =  '<<jobgroup>>' and jobmst_prntname = '_')
order by jobmst_prntname, jobmst_name, related, details
    ]]>
      </querytext_sqlserver>
      <querytext_oracle>
       <![CDATA[
select * from (
SELECT        case when jobmst_type = 1 then 'JobGroup' else 'Job' end jobmst_type, jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, '' related, '' details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'command' related, jobdtl.jobdtl_cmd details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        jobmst_active, isnull(jobmst.jobmst_prntname,'') jobmst_prntname,jobmst.jobmst_name, 'parameters' related, cast(jobdtl.jobdtl_params as varchar) details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE        (jobmst_dirty <> 'X' and jobmst_type > 1)
union
SELECT        ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'calendar' AS related, isnull(evntmst.evntmst_name,'') as details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                       evntmst ON jobmst.evntmst_id = evntmst.evntmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        ISNULL(jobmst.jobmst_prntname, '') jobmst_prntname, jobmst.jobmst_name, 'agent' AS related, isnull(nodmst.nodmst_name,'')  AS details 
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id left outer JOIN
                       nodmst ON jobdtl.nodmst_id = nodmst.nodmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        ISNULL(jobmst.jobmst_prntname, '') AS jobmst_prntname, jobmst.jobmst_name, 'agentlist' AS related, nodlstms.nodlstmst_name as details
FROM            jobmst INNER JOIN
                       jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id INNER JOIN
                       nodlstms ON jobdtl.nodlstmst_id = nodlstms.nodlstmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
union
SELECT        isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'jobdep' related, concat(jobmst_1.jobmst_name, jobmst_1.jobmst_prntname, ' ', jobdep.jobdep_status) details
FROM            jobmst INNER JOIN
                       jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                       jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 1)
union
SELECT        isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'filedep' related, concat(jobdep.jobdep_filename, ' ', jobdep.jobdep_filetype) details
FROM            jobmst INNER JOIN
                       jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                       jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X' and jobdep.jobdep_type  = 2)

union
SELECT        isnull(jobmst.jobmst_prntname,'') jobmst_prntname, jobmst.jobmst_name, 'event' AS related, CONCAT(trgmst.trgmst_name, ' ', trgjob.trgjob_type) AS details
FROM            trgmst INNER JOIN
                       trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                       jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
WHERE        (jobmst.jobmst_dirty <> 'X')
) v1 
order by jobmst_prntname, jobmst_name, related, details
    ]]>
  </querytext_oracle>
  </query>   
    <query>
        <queryname>115 Show job counts per group</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
         <![CDATA[        
    select isnull(jobmst_prntname,'') + '\' + jobmst_name [Group] , count(isnull(jobmst_prntname,'') + '\' + jobmst_name) [Count] , j1.jobmst_id, j1.jobmst_active from jobmst j1,
      (select jobmst.jobmst_prntname  parentname from jobmst where not jobmst_dirty = 'X')  j2
      where(not jobmst_dirty = 'X' and (j2.parentname like isnull(jobmst_prntname,'') + '\' + jobmst_name + '\' +'%' or j2.parentname = isnull(jobmst_prntname,'') + '\' + jobmst_name )
      or j2.parentname = '\' + jobmst_name ) 
      group by isnull(jobmst_prntname,'') + '\' + jobmst_name, jobmst_id, jobmst_active
      order by isnull(jobmst_prntname,'') + '\' + jobmst_name      ]]>      
    </querytext_sqlserver>
        <querytext_oracle>
                 <![CDATA[
SELECT NVL(jobmst_prntname,'')  || '\' || jobmst_name Grp ,
  COUNT(NVL(jobmst_prntname,'') || '\' || jobmst_name) Cnt
FROM tidal.jobmst j1,
  (SELECT jobmst.jobmst_prntname parentname FROM tidal.jobmst
  ) j2
WHERE (j2.parentname LIKE NVL(jobmst_prntname,'') || '\' || jobmst_name || '\' ||'%'
OR j2.parentname = NVL(jobmst_prntname,'')        || '\' || jobmst_name )
OR j2.parentname = '\'                            || jobmst_name
GROUP BY NVL(jobmst_prntname,'')                  || '\' || jobmst_name
ORDER BY NVL(jobmst_prntname,'')                  || '\' || jobmst_name
      ]]>
    </querytext_oracle>
    </query>
    
    <query>
        <queryname>120 Show jobs per agent list</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      SELECT DISTINCT
      dbo.nodlstms.nodlstmst_name AS AgentList, dbo.nodlstms.nodlstmst_type, dbo.jobmst.jobmst_prntname,
      dbo.jobmst.jobmst_name, dbo.nodmst.nodmst_name, dbo.nodmst.nodmst_active
      FROM         dbo.jobdtl INNER JOIN
      dbo.jobmst ON dbo.jobdtl.jobdtl_id = dbo.jobmst.jobdtl_id INNER JOIN
      dbo.nodlstms ON dbo.jobdtl.nodlstmst_id = dbo.nodlstms.nodlstmst_id INNER JOIN
      dbo.nodlstdt ON dbo.nodlstms.nodlstmst_id = dbo.nodlstdt.nodlstmst_id INNER JOIN
      dbo.nodmst ON dbo.nodlstdt.nodmst_id = dbo.nodmst.nodmst_id
      WHERE     (dbo.jobmst.jobmst_dirty != 'X')
      ORDER BY dbo.jobmst.jobmst_prntname, dbo.jobmst.jobmst_name
    </querytext_sqlserver>
        <querytext_oracle>
      SELECT DISTINCT
      nodlstms.nodlstmst_name AS AgentList, nodlstms.nodlstmst_type, jobmst.jobmst_prntname,
      jobmst.jobmst_name, nodmst.nodmst_name, nodmst.nodmst_active
      FROM         tidal.jobdtl INNER JOIN
      tidal.jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id INNER JOIN
      tidal.nodlstms ON jobdtl.nodlstmst_id = nodlstms.nodlstmst_id INNER JOIN
      tidal.nodlstdt ON nodlstms.nodlstmst_id = nodlstdt.nodlstmst_id INNER JOIN
      tidal.nodmst ON nodlstdt.nodmst_id = nodmst.nodmst_id
      WHERE     (jobmst.jobmst_dirty != 'X')
      ORDER BY jobmst.jobmst_prntname, jobmst.jobmst_name
    </querytext_oracle>
    </query>
<query>
        <queryname>130 Agent job counts</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
        <![CDATA[
			WITH JobDtlExtract (
			jobmst_id,
			jobmst_prntid,
			JobName,
			fullpath,
			lvls,
			JobGroup,
			calid,
			nodmst_id,
			jobcls_id,
			nodlstmst_id,
			jobdtl_fromtm,
			jobdtl_untiltm,
			jobmst_type,
			jobdtl_cmd,
			jobdtl_params,
			jobmst_desc,
			jobmst_runbook,
			jobmst_active,
			jobmst_owner,
			jobmst_alias,
			jobdtl_proxy,
			JOBDTL_INTERVAL,
			JOBDTL_INTERVALCNT,
			JOBDTL_NORMALEXIT,
			JOBDTL_PRIORITY,
			SERVICEMST_ID,
			jobdtl_inhevent,
			jobdtl_inhagent,
			jobdtl_inhtime,
			jobdtl_minrun,
			jobdtl_maxrun,
			jobdtl_concur,
			jobdtl_duration,
			jobdtl_retnsn,
			jobdtl_rerun,
			jobdtl_carryover,
			jobdtl_extinfo,
			jobdtl_saveoutput,
			jobdtl_trackmethod,
			jobdtl_trackcmd,
			jobmst_lstchgtm,
			enabled_job_count,
			enabled_job_with_calendar,
			enabled_job_no_calendar,
			disabled_job_count,
			disabled_job_with_calendar,
			disabled_job_no_calendar
			)  as
			(
			SELECT m.jobmst_id,
			m.jobmst_prntid,
			m.jobmst_name as JobName,
			cast(jobmst_id as varchar(1000)) as fullpath,
			0 as lvls,
			cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
			M.evntmst_id calid,
			D.nodmst_id,
			m.jobcls_id,
			nodlstmst_id,
			d.jobdtl_fromtm,
			d.jobdtl_untiltm,
			m.jobmst_type,
			d.jobdtl_cmd,
			d.jobdtl_params,
			m.jobmst_desc,
			m.jobmst_runbook,
			m.jobmst_active,
			m.jobmst_owner,
			m.jobmst_alias,
			d.jobdtl_proxy,
			D.JOBDTL_INTERVAL,
			D.JOBDTL_INTERVALCNT,
			D.JOBDTL_NORMALEXIT,
			D.JOBDTL_PRIORITY,
			D.SERVICEMST_ID,
			D.jobdtl_inhevent,
			D.jobdtl_inhagent,
			D.jobdtl_inhtime,
			jobdtl_minrun,
			jobdtl_maxrun,
			jobdtl_concur,
			jobdtl_duration,
			jobdtl_retnsn,
			jobdtl_rerun,
			jobdtl_carryover,
			jobdtl_extinfo,
			jobdtl_saveoutput,
			case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
			jobdtl_trackcmd,
			m.jobmst_lstchgtm,
			case when m.jobmst_active ='Y' then  1 else 0 end enabled_job_count,
			case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,'') when '' then 0 else 1 end else 0 end  enabled_job_with_calendar,
			case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,'') when '' then 1 else 0 end else 0 end  enabled_job_no_calendar,
			case when m.jobmst_active ='N' then  1 else 0 end disabled_job_count,
			case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,'') when '' then 0 else 1 end else 0 end  disabled_job_with_calendar,
			case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,'') when '' then 1 else 0 end else 0 end  disabled_job_no_calendar

			FROM jobmst M, jobdtl D
			WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
			UNION ALL
			SELECT m.jobmst_id,
			m.jobmst_prntid,
			m.jobmst_name as JobName,
			cast(cast(mt.fullpath as varchar(1000)) + '\' + cast(m.jobmst_id as varchar(100)) as varchar(1000)),
			mt.lvls +1 as lvls,
			cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
			case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
			case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
			m.jobcls_id,
			case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
			case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
			case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
			m.jobmst_type,
			d.jobdtl_cmd,
			d.jobdtl_params,
			m.jobmst_desc,
			m.jobmst_runbook,
			m.jobmst_active,
			m.jobmst_owner,
			m.jobmst_alias,
			case when D.jobdtl_inhagent = 'Y' then mt.jobdtl_proxy else D.jobdtl_proxy end as jobdtl_proxy,
			D.JOBDTL_INTERVAL,
			D.JOBDTL_INTERVALCNT,
			D.JOBDTL_NORMALEXIT,
			D.JOBDTL_PRIORITY,
			D.SERVICEMST_ID,
			D.jobdtl_inhevent,
			D.jobdtl_inhagent,
			D.jobdtl_inhtime,
			d.jobdtl_minrun,
			d.jobdtl_maxrun,
			d.jobdtl_concur,
			d.jobdtl_duration,
			d.jobdtl_retnsn,
			d.jobdtl_rerun,
			d.jobdtl_carryover,
			d.jobdtl_extinfo,
			d.jobdtl_saveoutput,
			case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
			d.jobdtl_trackcmd,
			m.jobmst_lstchgtm,
			case when m.jobmst_active ='Y' then  1 else 0 end enabled_job_count,
			case when m.jobmst_active ='Y' then  case  coalesce(calid,'') when '' then 0 else 1 end else 0 end  enabled_job_with_calendar,
			case when m.jobmst_active ='Y' then  case  coalesce(calid,'') when '' then 1 else 0 end else 0 end  enabled_job_no_calendar,
			case when m.jobmst_active ='N' then  1 else 0 end disabled_job_count,
			case when m.jobmst_active ='N' then  case  coalesce(calid,'') when '' then 0 else 1 end else 0 end  disabled_job_with_calendar,
			case when m.jobmst_active ='N' then  case  coalesce(calid,'') when '' then 1 else 0 end else 0 end  disabled_job_no_calendar
			FROM jobmst M, JobDtlExtract MT, jobdtl D
			where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
			)
			SELECT 
			coalesce(nodmst.nodmst_id,'') agent_id, 
			case when nodmst.nodmst_name is null then coalesce(nl.nodlstmst_name,'') else '' end   agent_list, 
			coalesce(nodmst.nodmst_name,'')   agent_name, 
			Case 
				 when nodmst.nodmst_type=1 then 'Master'
				 when nodmst.nodmst_type=2 then 'Agent'
				 when nodmst.nodmst_type=3 then 'Shell'
				 when nodmst.nodmst_type=4 then 'Backup Master'
				 when nodmst.nodmst_type=5 then 'FaultMon'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 1 then 'Windows Agent'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 2 then 'Unix Agent'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 4 then 'MVS Agent'
				 when nodmst.nodmst_type=7 then 'Remote Master'
				 when nodmst.nodmst_type=8 then 'Adapter'
				 when nodmst.nodmst_type=9 then 'Consolidator'
				 when nodmst.nodmst_type=10 then 'Service Host'
				 when nodmst.nodmst_type = 11 then 'Service Adapter' 
				 when nodmst.nodmst_type=12 then 'Dist Master Node'
			 else coalesce(cast(nodmst.nodmst_type as varchar(10)),'') end AgentType,
			coalesce(servicemst.servicemst_fullname,'') Adapter,
			coalesce(nodmst.nodmst_active,'') agent_enabled, 
			coalesce(sum(enabled_job_count),'') enabled_job_count,
			coalesce(sum(enabled_job_with_calendar),'') enabled_job_with_calendar,
			coalesce(sum(enabled_job_no_calendar),'') enabled_job_no_calendar,
			coalesce(sum(disabled_job_count),'') disabled_job_count,
			coalesce(sum(disabled_job_with_calendar),'') disabled_job_with_calendar,
			coalesce(sum(disabled_job_no_calendar),'') disabled_job_no_calendar,
			--case when jde.jobmst_active ='Y' then  count(jde.jobmst_id) else 0 end enabled_job_count,
			--case when jde.jobmst_active ='Y' then  sum( case coalesce(evntmst_name,'') when '' then 0 else 1 end) else 0 end  enabled_job_with_calendar,
			--case when jde.jobmst_active ='Y' then  sum( case when coalesce(evntmst_name,'') = '' and coalesce(jobmst_id,'') != '' then 1 else 0 end) else 0 end  enabled_job_no_calendar,
			--case when jde.jobmst_active ='N' then  count(jde.jobmst_id) else 0 end disabled_job_count,
			--case when jde.jobmst_active ='N' then  sum( case coalesce(evntmst_name,'') when '' then 0 else 1 end) else 0 end  disabled_job_with_calendar,
			--case when jde.jobmst_active ='N' then  sum( case when coalesce(evntmst_name,'') = '' and coalesce(jobmst_id,'') != '' then 1 else 0 end) else 0 end  disabled_job_no_calendar,
			   (select  coalesce( convert( varchar(10), max(jobrun_proddt), 126 ), '')        from jobrun where jobrun.nodmst_id = nodmst.nodmst_id) LastRunDate,
			    case when count(jde.jobmst_id) = 0  and nodmst.nodmst_id > 1 then 'Possibly Obsolete' else     '' end  Status
			From  nodmst 
			 left outer join servicemst on nodmst.servicemst_id = servicemst.servicemst_id
			 full outer join JobDtlExtract jde on nodmst.nodmst_id = jde.nodmst_id
			left outer join EVNTMST e on jde.calid= e.evntmst_id
			left outer join NODMST n on jde.nodmst_id= n.nodmst_id
			full outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
			left outer join OWNER o on jde.jobmst_owner = o.owner_id
			left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
			left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID
			left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
			group by nodmst.nodmst_id, nodmst.nodmst_type, nodmst.nodmst_ostype, servicemst.servicemst_fullname, nodmst.nodmst_name, nodmst.nodmst_active, nl.nodlstmst_name
			order by nodmst.nodmst_name , nodmst.nodmst_active
        ]]>
    </querytext_sqlserver>
        <querytext_oracle>
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo1,
  jobdtl_extinfo2,
  jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm,
  enabled_job_count,
  enabled_job_with_calendar,
  enabled_job_no_calendar,
  disabled_job_count,
  disabled_job_with_calendar,
  disabled_job_no_calendar
  )  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  0 as lvls,
  case m.jobmst_type when 1 then  cast('\' as varchar(1)) || cast(m.jobmst_name as varchar(1000)) else ' ' end  JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,  
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  substr(jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm,
  case when m.jobmst_active ='Y' then  1 else 0 end enabled_job_count,
  case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,0) when 0 then 0 else 1 end else 0 end  enabled_job_with_calendar,
  case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,0) when 0 then 1 else 0 end else 0 end  enabled_job_no_calendar,
  case when m.jobmst_active ='N' then  1 else 0 end disabled_job_count,
  case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,0) when 0 then 0 else 1 end else 0 end  disabled_job_with_calendar,
  case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,0) when 0 then 1 else 0 end else 0 end  disabled_job_no_calendar
  
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  mt.lvls +1 as lvls,
  case m.jobmst_type when 1 then  cast((mt.JobGroup || cast('\' as varchar(1)) || m.jobmst_name) as varchar(1000)) else mt.JobGroup end JobGroup  ,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  substr(d.jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(d.jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(d.jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  d.jobdtl_saveoutput,
  d.jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm,
  case when m.jobmst_active ='Y' then  1 else 0 end enabled_job_count,
  case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,0) when 0 then 0 else 1 end else 0 end  enabled_job_with_calendar,
  case when m.jobmst_active ='Y' then  case  coalesce(M.evntmst_id,0) when 0 then 1 else 0 end else 0 end  enabled_job_no_calendar,
  case when m.jobmst_active ='N' then  1 else 0 end disabled_job_count,
  case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,0) when 0 then 0 else 1 end else 0 end  disabled_job_with_calendar,
  case when m.jobmst_active ='N' then  case  coalesce(M.evntmst_id,0) when 0 then 1 else 0 end else 0 end  disabled_job_no_calendar
  
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT 
			nodmst.nodmst_id agent_id, 
      case when nodmst.nodmst_name is null then coalesce(nl.nodlstmst_name,' ') else ' ' end   agent_list,       
			nodmst.nodmst_name agent_name, 
			Case 
				 when nodmst.nodmst_type=1 then 'Master'
				 when nodmst.nodmst_type=2 then 'Agent'
				 when nodmst.nodmst_type=3 then 'Shell'
				 when nodmst.nodmst_type=4 then 'Backup Master'
				 when nodmst.nodmst_type=5 then 'FaultMon'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 1 then 'Windows Agent'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 2 then 'Unix Agent'
				 when nodmst.nodmst_type=6 and nodmst.nodmst_ostype = 4 then 'MVS Agent'
				 when nodmst.nodmst_type=7 then 'Remote Master'
				 when nodmst.nodmst_type=8 then 'Adapter'
				 when nodmst.nodmst_type=9 then 'Consolidator'
				 when nodmst.nodmst_type=10 then 'Service Host'
				 when nodmst.nodmst_type = 11 then 'Service Adapter' 
				 when nodmst.nodmst_type=12 then 'Dist Master Node'
			 else cast(nodmst.nodmst_type as varchar(10)) end AgentType,  
			coalesce(servicemst.servicemst_fullname,' ') Adapter,  
			coalesce(nodmst.nodmst_active,' ') agent_enabled, 
			coalesce(sum(enabled_job_count),0) enabled_job_count,
			coalesce(sum(enabled_job_with_calendar),0) enabled_job_with_calendar,
			coalesce(sum(enabled_job_no_calendar),0) enabled_job_no_calendar,
			coalesce(sum(disabled_job_count),0) disabled_job_count,
			coalesce(sum(disabled_job_with_calendar),0) disabled_job_with_calendar,
			coalesce(sum(disabled_job_no_calendar),0) disabled_job_no_calendar,
         (select  max(jobrun_proddt) from jobrun where jobrun.nodmst_id = nodmst.nodmst_id) LastRunDate,
         case when count(jde.jobmst_id) = 0 and nodmst.nodmst_id > 1 then 'Possibly Obsolete' else     ' ' end  Status
			From  nodmst 
			 left outer join servicemst on nodmst.servicemst_id = servicemst.servicemst_id
			 full outer join JobDtlExtract jde on nodmst.nodmst_id = jde.nodmst_id
			left outer join EVNTMST e on jde.calid= e.evntmst_id
			left outer join NODMST n on jde.nodmst_id= n.nodmst_id
			full outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
			left outer join OWNER o on jde.jobmst_owner = o.owner_id
			left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
			left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID
			left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
            --where nodmst.nodmst_id > 1
			group by nodmst.nodmst_id, nodmst.nodmst_type, nodmst.nodmst_ostype, servicemst.servicemst_fullname, nodmst.nodmst_name, nodmst.nodmst_active, nl.nodlstmst_name
			order by nodmst.nodmst_name , nodmst.nodmst_active

        </querytext_oracle>
    </query>




    <query> 
        <queryname>200 Show deleted jobs with dependencies</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select * from jobmst where jobmst_dirty!=' ' and  (jobmst_id in (select jobmst_id from jobdep) or jobmst_id in (select jobdep_jobmst from jobdep))
    </querytext_sqlserver>
        <querytext_oracle>
      select * from tidal.jobmst where jobmst_dirty!=' ' and  (jobmst_id in (select jobmst_id from tidal.jobdep) or jobmst_id in (select jobdep_jobmst from tidal.jobdep))
    </querytext_oracle>
    </query>
    <query>
        <queryname>220 Show deleted jobs with resources</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select * from jobmst where jobmst_dirty!=' ' and  jobmst_id in (select jobmst_id from resjob)
    </querytext_sqlserver>
        <querytext_oracle>
      select * from tidal.jobmst where jobmst_dirty!=' ' and  jobmst_id in (select jobmst_id from tidal.resjob)
    </querytext_oracle>
    </query>
    <query>
        <queryname>230 Show deleted jobs with events</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select * from jobmst where jobmst_dirty!=' ' and  jobmst_id in (select jobmst_id from trgjob)
    </querytext_sqlserver>
        <querytext_oracle>
      select * from tidal.jobmst where jobmst_dirty!=' ' and  jobmst_id in (select jobmst_id from tidal.trgjob)
    </querytext_oracle>
    </query> 
    <query>
        <queryname>240 Show jobs without parents</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select *  from jobmst where  not jobmst_prntid in (select jobmst_id from jobmst where jobmst_type = 1) and not jobmst_Prntid is null
    </querytext_sqlserver>
        <querytext_oracle>
      select *  from tidal.jobmst where  not jobmst_prntid in (select jobmst_id from tidal.jobmst where jobmst_type = 1) and not jobmst_Prntid is null
    </querytext_oracle>
    </query>
    <query>
      <queryname>TopJobGroups</queryname>
      <category>hidden</category>
      <linkquery></linkquery><querydescription></querydescription>
      <db>admiral</db>
      <chartfields></chartfields>
      <import_oracle>y</import_oracle>
      <cachetimeout>300</cachetimeout>
      <querytext_sqlserver>
        select jobmst_name  from jobmst where  jobmst_type = 1 and jobmst_prntid is null and not jobmst_dirty = 'X' order by jobmst_name
  </querytext_sqlserver>
      <querytext_oracle>
        select jobmst_name  from jobmst where  jobmst_type = 1 and jobmst_prntid is null and not jobmst_dirty = 'X' order by jobmst_name
  </querytext_oracle>
  </query>
  <query>
        <queryname>All Calendars</queryname>
        <category>calendars</category>
        <linkquery></linkquery><querydescription>All Calendars</querydescription>
        <db>admiral</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            select evntmst_id , evntmst_name entityName from evntmst order by evntmst_name
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            select evntmst_id , evntmst_name entityName from evntmst order by evntmst_name
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>All Variables</queryname>
        <category>variables</category>
        <linkquery></linkquery><querydescription>All Variables</querydescription>
        <db>admiral</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            select varmst_Name as entityName , varmst_Value as value from varmst order by varmst_Name
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            select varmst_Name as entityName , varmst_Value as value from varmst order by varmst_Name
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>All events</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription>All Events</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            Events::id,name,description,params,months,monthdays,ownername,servicename
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Events::id,name,description,params,months,monthdays,ownername,servicename
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>300 Calendars not used</queryname>
        <category>calendars</category>
        <querydoc>Based on: (1) Calendar not base on this calendar, (2) Not member of calendar, (3) Calendar not used with node outage, and (4) Calendar not assigned to job</querydoc>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      SELECT
      calendar.Evntmst_Id,
      calendar.Evntmst_Name,
      calendar.Evntmst_desc,
      calendar.Evntmst_Lstchgtm,
      owner.owner_name
      FROM
      Evntmst calendar, owner
      WHERE owner.owner_id= calendar.evntmst_owner and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM Evntmst WHERE Evntmst_Id Not In (SELECT DISTINCT Evntmst_Id FROM Nodout WHERE Evntmst_Id IS NOT NULL)) and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntchld_Prntid FROM Evntchld WHERE Evntmst_Id IS NOT NULL)) and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntmst_Calendar FROM Evntmst WHERE Evntmst_Id IS NOT NULL and evntmst_calendar is not null)) and
      Calendar.Evntmst_Id in (SELECT Evntmst_Id FROM Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntmst_Id FROM Jobmst WHERE Jobmst_Dirty not in ('X') AND Evntmst_Id IS NOT NULL))

    </querytext_sqlserver>
        <querytext_oracle>
      SELECT
      calendar.Evntmst_Id,
      calendar.Evntmst_Name,
      calendar.Evntmst_desc,
      calendar.Evntmst_Lstchgtm,
      owner.owner_name
      FROM
      tidal.Evntmst calendar, tidal.owner
      WHERE owner.owner_id= calendar.evntmst_owner and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM tidal.Evntmst WHERE Evntmst_Id Not In (SELECT DISTINCT Evntmst_Id FROM tidal.Nodout WHERE Evntmst_Id IS NOT NULL)) and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM tidal.Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntchld_Prntid FROM tidal.Evntchld WHERE Evntmst_Id IS NOT NULL)) and
      calendar.evntmst_id in (SELECT Evntmst_Id FROM tidal.Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntmst_Calendar FROM tidal.Evntmst WHERE Evntmst_Id IS NOT NULL and evntmst_calendar is not null)) and
      Calendar.Evntmst_Id in (SELECT Evntmst_Id FROM tidal.Evntmst WHERE not Evntmst_Id In (SELECT DISTINCT Evntmst_Id FROM tidal.Jobmst WHERE Jobmst_Dirty not in ('X') AND Evntmst_Id IS NOT NULL))
    </querytext_oracle>
    </query>
    <query>
        <queryname>305 Calendars that are possible duplicates</queryname>
        <category>calendars</category>
        <querydoc>The cnt will show how many are possible similar, review definitions</querydoc>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select possibledups.cnt, evntmst_name, evntmst_desc from
      (select max(evntmst.evntmst_id) evntmst_idd, count(*) chldcnt from evntmst left outer join evntchld on evntmst.evntmst_id =  evntchld.evntmst_id  group by evntmst.evntmst_id ) evntc,
      (select max(evntmst.evntmst_id) evntmst_idd, count(*) chldcond from evntmst left outer join evntcond on evntmst.evntmst_id =  evntcond.evntmst_id  group by evntmst.evntmst_id ) evntcond,
      evntmst ,
      (select  count(*) cnt, evntmst_owner, evntmst_type, evntmst_freq,coalesce(evntmst_monthdays,'') evntmst_monthdays,coalesce(evntmst_months,'') evntmst_months, coalesce(evntmst_weekdays,'') evntmst_weekdays, coalesce(evntmst_weeks,'') evntmst_weeks,evntmst_intsect,evntmst_occur
      from dbo.evntmst
      where evntmst_type != '1'
      group by  evntmst_owner, evntmst_type, evntmst_offset,evntmst_freq,evntmst_occur, evntmst_monthdays, evntmst_months, evntmst_weekdays, evntmst_weeks, evntmst_intsect,evntmst_occur, evntmst_timeframe, evntmst_calendar
      having count(*) > 1
      ) possibledups
      where  evntmst.evntmst_type =  possibledups.evntmst_type
      and evntmst.evntmst_owner =  possibledups.evntmst_owner
      and evntmst.evntmst_freq =  possibledups.evntmst_freq
      and evntmst.evntmst_monthdays =  possibledups.evntmst_monthdays
      and evntmst.evntmst_months =  possibledups.evntmst_months
      and evntmst.evntmst_weekdays =  possibledups.evntmst_weekdays
      and evntmst.evntmst_intsect =  possibledups.evntmst_intsect
      and evntmst.evntmst_occur =  possibledups.evntmst_occur
      and evntmst.evntmst_id = evntc.evntmst_idd
      and evntmst.evntmst_id = evntcond.evntmst_idd
      order by  evntmst.evntmst_owner, evntmst.evntmst_type, evntmst.evntmst_offset, evntmst.evntmst_freq, evntmst.evntmst_monthdays, evntmst.evntmst_months, evntmst.evntmst_weekdays, evntmst.evntmst_weeks, evntmst.evntmst_intsect,evntmst.evntmst_occur, evntmst_timeframe, evntmst_calendar
    </querytext_sqlserver>
        <querytext_oracle>
SELECT
* 
FROM
  (SELECT MAX(evntmst.evntmst_id) evntmst_idd,
    COUNT(*) chldcnt
  FROM tidal.evntmst
  LEFT OUTER JOIN tidal.evntchld
  ON evntmst.evntmst_id = evntchld.evntmst_id
  GROUP BY evntmst.evntmst_id
  ) evntc,
  (SELECT MAX(evntmst.evntmst_id) evntmst_idd,
    COUNT(*) chldcond
  FROM tidal.evntmst
  LEFT OUTER JOIN tidal.evntcond
  ON evntmst.evntmst_id = evntcond.evntmst_id
  GROUP BY evntmst.evntmst_id
  ) evntcond,
  tidal.evntmst ,
  (SELECT COUNT(*) cnt,
    evntmst_owner,
    evntmst_type,
    evntmst_freq,
    COALESCE(evntmst_monthdays,' ') evntmst_monthdays,
    COALESCE(evntmst_months,' ') evntmst_months,
    COALESCE(evntmst_weekdays,' ') evntmst_weekdays,
    COALESCE(evntmst_weeks,' ') evntmst_weeks,
    evntmst_intsect,
    evntmst_occur
  FROM tidal.evntmst
  WHERE evntmst_type != '1'
  GROUP BY evntmst_owner,
    evntmst_type,
    evntmst_offset,
    evntmst_freq,
    evntmst_occur,
    evntmst_monthdays,
    evntmst_months,
    evntmst_weekdays,
    evntmst_weeks,
    evntmst_intsect,
    evntmst_occur,
    evntmst_timeframe,
    evntmst_calendar
  HAVING COUNT(*) > 1
  ) possibledups
WHERE evntmst.evntmst_type    = possibledups.evntmst_type
AND evntmst.evntmst_owner     = possibledups.evntmst_owner
AND evntmst.evntmst_freq      = possibledups.evntmst_freq
AND evntmst.evntmst_monthdays = possibledups.evntmst_monthdays
AND evntmst.evntmst_months    = possibledups.evntmst_months
AND evntmst.evntmst_weekdays  = possibledups.evntmst_weekdays
AND evntmst.evntmst_intsect   = possibledups.evntmst_intsect
AND evntmst.evntmst_occur     = possibledups.evntmst_occur
AND evntmst.evntmst_id        = evntc.evntmst_idd
AND evntmst.evntmst_id        = evntcond.evntmst_idd
ORDER BY evntmst.evntmst_owner,
  evntmst.evntmst_type,
  evntmst.evntmst_offset,
  evntmst.evntmst_freq,
  evntmst.evntmst_monthdays,
  evntmst.evntmst_months,
  evntmst.evntmst_weekdays,
  evntmst.evntmst_weeks,
  evntmst.evntmst_intsect,
  evntmst.evntmst_occur,
  evntmst_timeframe,
  evntmst_calendar

    </querytext_oracle>
    </query>
    <query>
        <queryname>310 Events without Actions</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      SELECT
      Trgmst_Id, Trgmst_Type, Trgmst_Name, Trgmst_Desc
      FROM
      trgmst
      WHERE
      trgmst_id NOT IN
      (SELECT DISTINCT trgmst_id FROM trgtsk WHERE trgmst_id IS NOT NULL)

    </querytext_sqlserver>
        <querytext_oracle>
      SELECT
      Trgmst_Id, Trgmst_Type, Trgmst_Name, Trgmst_Desc
      FROM
      tidal.trgmst
      WHERE
      trgmst_id NOT IN
      (SELECT DISTINCT trgmst_id FROM tidal.trgtsk WHERE trgmst_id IS NOT NULL)
    </querytext_oracle>
    </query>
    <query>
        <queryname>315 Possible duplicate Events</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
      select * from (
      SELECT        trgmst.trgmst_name, trgmst.trgmst_trigger, sum(tskmst.tskmst_id) sumactions ,sum(tskmst.tskmst_type) tsktype
      FROM            trgmst INNER JOIN
      trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
      tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
      group by trgmst.trgmst_name, trgmst.trgmst_trigger

      ) qry1,

      (
      SELECT        trgmst.trgmst_name, trgmst.trgmst_trigger, sum(tskmst.tskmst_id) sumactions ,sum(tskmst.tskmst_type) tsktype
      FROM            trgmst INNER JOIN
      trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
      tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
      group by trgmst.trgmst_name, trgmst.trgmst_trigger

      ) qry2
      where not qry1.trgmst_name = qry2.trgmst_name and
      qry1.trgmst_trigger = qry2.trgmst_trigger and
      qry1.sumactions = qry2.sumactions
      order by  2 ,3

    </querytext_sqlserver>
        <querytext_oracle>
      select * from (
      SELECT        trgmst.trgmst_name, trgmst.trgmst_trigger, sum(tskmst.tskmst_id) sumactions ,sum(tskmst.tskmst_type) tsktype
      FROM            tidal.trgmst INNER JOIN
      tidal.trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
      tidal.tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
      group by trgmst.trgmst_name, trgmst.trgmst_trigger

      ) qry1,

      (
      SELECT        trgmst.trgmst_name, trgmst.trgmst_trigger, sum(tskmst.tskmst_id) sumactions ,sum(tskmst.tskmst_type) tsktype
      FROM            tidal.trgmst INNER JOIN
      tidal.trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
      tidal.tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
      group by trgmst.trgmst_name, trgmst.trgmst_trigger

      ) qry2
      where not qry1.trgmst_name = qry2.trgmst_name and
      qry1.trgmst_trigger = qry2.trgmst_trigger and
      qry1.sumactions = qry2.sumactions
      order by  2 ,3
    </querytext_oracle>
    </query>
    <query>
        <queryname>320 Agents not used</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
 Select
      node.Nodmst_Id,
      node.Nodmst_Name,
      node.nodmst_lstchgtm,
      node.nodmst_active,
      node.nodmst_desc
      From
      Nodmst node,
      (Select Nodmst_Id From Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From Jobdtl Where Nodmst_Id Is Not Null)) Nodenotassignedjob,
      (Select Nodmst_Id From Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From Jobdep Where Nodmst_Id Is Not Null)) Nodenotfiledepenency,
      (Select Nodmst_Id From Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From Nodlstdt Where Nodmst_Id Is Not Null)) Nodenotagentlist,
      (Select Nodmst_Id From Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From Trgmst Where Nodmst_Id Is Not Null)) Nodenotfileevent,
      (Select Nodmst_Id From Nodmst Where Nodmst_Id Not In (Select Distinct Nodlstmst_lastused From nodlstms Where Nodlstmst_lastused Is Not Null)) Nodenotagentlistms
      Where
      Node.Nodmst_Id = nodenotassignedjob.Nodmst_Id And
      Node.Nodmst_Id = Nodenotfiledepenency.Nodmst_Id And
      Node.Nodmst_Id = nodenotagentlist.Nodmst_Id And
      Node.Nodmst_Id = Nodenotfileevent.Nodmst_Id And
      Node.Nodmst_Id = Nodenotagentlistms.Nodmst_Id And
      Node.Nodmst_Id > 0
      order by NODMST_LSTCHGTM;
    </querytext_sqlserver>
        <querytext_oracle>
      Select
      node.Nodmst_Id,
      node.Nodmst_Name,
      node.nodmst_lstchgtm,
      node.nodmst_active,
      node.nodmst_desc
      From
      tidal.Nodmst node,
      (Select Nodmst_Id From tidal.Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From tidal.Jobdtl Where Nodmst_Id Is Not Null)) Nodenotassignedjob,
      (Select Nodmst_Id From tidal.Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From tidal.Jobdep Where Nodmst_Id Is Not Null)) Nodenotfiledepenency,
      (Select Nodmst_Id From tidal.Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From tidal.Nodlstdt Where Nodmst_Id Is Not Null)) Nodenotagentlist,
      (Select Nodmst_Id From tidal.Nodmst Where Nodmst_Id Not In (Select Distinct Nodmst_Id From tidal.Trgmst Where Nodmst_Id Is Not Null)) Nodenotfileevent,
      (Select Nodmst_Id From tidal.Nodmst Where Nodmst_Id Not In (Select Distinct Nodlstmst_lastused From tidal.nodlstms Where Nodlstmst_lastused Is Not Null)) Nodenotagentlistms
      Where
      Node.Nodmst_Id = nodenotassignedjob.Nodmst_Id And
      Node.Nodmst_Id = Nodenotfiledepenency.Nodmst_Id And
      Node.Nodmst_Id = nodenotagentlist.Nodmst_Id And
      Node.Nodmst_Id = Nodenotfileevent.Nodmst_Id And
      Node.Nodmst_Id = Nodenotagentlistms.Nodmst_Id And
      Node.Nodmst_Id > 0
      order by NODMST_LSTCHGTM
    </querytext_oracle>
    </query>
    <query>
        <queryname>325 Agents assigned only to inactve jobs</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      Select Nodmst_Id, nodmst_name From Nodmst Where Nodmst_id > 1 and Nodmst_Id Not In (Select Distinct Nodmst_Id From Jobdtl, jobmst Where jobmst.jobdtl_id = jobdtl.jobdtl_id and jobmst_active='Y' and  Nodmst_Id Is Not Null)
    </querytext_sqlserver>
        <querytext_oracle>
      Select Nodmst_Id, nodmst_name From tidal.Nodmst Where Nodmst_id > 1 and Nodmst_Id Not In (Select Distinct Nodmst_Id From tidal.Jobdtl, tidal.jobmst Where jobmst.jobdtl_id = jobdtl.jobdtl_id and jobmst_active='Y' and  Nodmst_Id Is Not Null)
    </querytext_oracle>
    </query>
    <query>
        <queryname>326 Agents and count of enabled, scheduled jobs</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
           <![CDATA[        
	WITH JobDtlExtract (
    jobmst_id,
    jobmst_prntid,
    JobName,
    lvls,
    prnt,
    calid,
    nodmst_id,
    nodlstmst_id,
    jobdtl_fromtm,
    jobdtl_untiltm,
    jobmst_type,
    jobdtl_cmd,
    jobdtl_params,
    jobmst_active,
    jobmst_owner,
    jobmst_alias,
    jobdtl_proxy,
    JOBDTL_INTERVAL,
    JOBDTL_INTERVALCNT,
    JOBDTL_NORMALEXIT,
    JOBDTL_PRIORITY,
    SERVICEMST_ID,
    jobdtl_inhevent,
    jobdtl_inhagent,
    jobdtl_inhtime,
    jobdtl_minrun,
    jobdtl_maxrun,
    jobdtl_concur,
    jobdtl_retnsn,
    jobdtl_rerun,
    jobdtl_carryover,
    jobdtl_extinfo,
    jobdtl_saveoutput,
    jobmst_lstchgtm)  as
  (
    SELECT m.jobmst_id,
    m.jobmst_prntid,
    m.jobmst_name as JobName,
    0 as lvls,
    case m.jobmst_type when 1 then  cast('\' as varchar(1)) + cast(m.jobmst_name as varchar(1000)) else '' end  prnt,
    M.evntmst_id calid,
    D.nodmst_id,
    nodlstmst_id,
    d.jobdtl_fromtm,
    d.jobdtl_untiltm,
    m.jobmst_type,
    d.jobdtl_cmd,
    d.jobdtl_params,
    m.jobmst_active,
    m.jobmst_owner,
    m.jobmst_alias,
    d.jobdtl_proxy,
    D.JOBDTL_INTERVAL,
    D.JOBDTL_INTERVALCNT,
    D.JOBDTL_NORMALEXIT,
    D.JOBDTL_PRIORITY,
    D.SERVICEMST_ID,
    D.jobdtl_inhevent,
    D.jobdtl_inhagent,
    D.jobdtl_inhtime,
    jobdtl_minrun,
    jobdtl_maxrun,
    jobdtl_concur,
    jobdtl_retnsn,
    jobdtl_rerun,
    jobdtl_carryover,
    jobdtl_extinfo,
    jobdtl_saveoutput,
    m.jobmst_lstchgtm
    FROM jobmst M, jobdtl D
    WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id 
    UNION ALL
    SELECT m.jobmst_id,
    m.jobmst_prntid,
    m.jobmst_name as JobName,
    mt.lvls +1 as lvls,
    case m.jobmst_type when 1 then  cast((mt.prnt + cast('\' as varchar(1)) + m.jobmst_name) as varchar(1000)) else mt.prnt end prnt  ,
    case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
    case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
    case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
    case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
    case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
    m.jobmst_type,
    d.jobdtl_cmd,
    d.jobdtl_params,
    m.jobmst_active,
    m.jobmst_owner,
    m.jobmst_alias,
    d.JOBDTL_PROXY,
    D.JOBDTL_INTERVAL,
    D.JOBDTL_INTERVALCNT,
    D.JOBDTL_NORMALEXIT,
    D.JOBDTL_PRIORITY,
    D.SERVICEMST_ID,
    D.jobdtl_inhevent,
    D.jobdtl_inhagent,
    D.jobdtl_inhtime,
    d.jobdtl_minrun,
    d.jobdtl_maxrun,
    d.jobdtl_concur,
    d.jobdtl_retnsn,
    d.jobdtl_rerun,
    d.jobdtl_carryover,
    d.jobdtl_extinfo,
    d.jobdtl_saveoutput,
    m.jobmst_lstchgtm
  FROM jobmst M, JobDtlExtract MT, jobdtl D
    where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id 
   )
  SELECT 
  n.NODMST_NAME Agent,
  Case when nodmst_type = 11 then 'Adapter' when nodmst_type=6 then 'Agent' end AgentType,
  --Case when nodlstmst_type = 11 then 'Adapter' when nodlstmst_type=6 then 'Agent' end AgentType,
  servicemst.servicemst_name  AdapterType,
  coalesce(nl.nodlstmst_name,'') AgentList,

  sum(case when jde.jobmst_type is null then 0 else 1 end)  NumberOfJobs

From nodmst n
  left outer join JobDtlExtract jde on jde.nodmst_id= n.nodmst_id and  jde.jobmst_active = 'Y'
  left outer join EVNTMST e on jde.calid= e.evntmst_id and not e.evntmst_name is null
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join servicemst on jde.SERVICEMST_ID = servicemst.servicemst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
where n.nodmst_type > 5
--where not nl.nodlstmst_type in (1,4,5)
group by n.NODMST_NAME,  n.nodmst_type, servicemst.servicemst_name, nl.nodlstmst_name
--order by n.NODMST_NAME, nl.nodlstmst_name
union 
SELECT 
  n.NODMST_NAME Agent,
  Case when nodmst_type = 11 then 'Adapter' when nodmst_type=6 then 'Agent' end AgentType,
  servicemst.servicemst_name AdapterType,
  coalesce(nl.nodlstmst_name,'') AgentList,
  count(*) - 1 NumberOfJobs
From nodlstms nl
  left outer join JobDtlExtract jde on jde.nodlstmst_id = nl.nodlstmst_id and  jde.jobmst_active = 'Y'
  left outer join EVNTMST e on jde.calid= e.evntmst_id and not e.evntmst_name is null
  left outer join nodmst n on jde.nodmst_id = n.nodmst_id
  left outer join servicemst on jde.SERVICEMST_ID = servicemst.servicemst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID
group by n.NODMST_NAME,Case when nodmst_type = 11 then 'Adapter' when nodmst_type=6 then 'Agent' end , servicemst.servicemst_name, nl.nodlstmst_name
order by n.NODMST_NAME, nl.nodlstmst_name
      ]]>
    </querytext_sqlserver>
        <querytext_oracle>
           <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
    jobmst_prntid,
    JobName,
    lvls,
    prnt,
    calid,
    nodmst_id,
    nodlstmst_id,
    jobdtl_fromtm,
    jobdtl_untiltm,
    jobmst_type,
    jobdtl_cmd,
    jobdtl_params,
    jobmst_active,
    jobmst_owner,
    jobmst_alias,
    jobdtl_proxy,
    JOBDTL_INTERVAL,
    JOBDTL_INTERVALCNT,
    JOBDTL_NORMALEXIT,
    JOBDTL_PRIORITY,
    SERVICEMST_ID,
    jobdtl_inhevent,
    jobdtl_inhagent,
    jobdtl_inhtime,
    jobdtl_minrun,
    jobdtl_maxrun,
    jobdtl_concur,
    jobdtl_retnsn,
    jobdtl_rerun,
    jobdtl_carryover,
    jobdtl_extinfo,
    jobdtl_saveoutput,
    jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  0 as lvls,
  case m.jobmst_type when 1 then  cast('\' as varchar(1)) || cast(m.jobmst_name as varchar(1000)) else '' end  prnt,
  M.evntmst_id calid,
  D.nodmst_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
	D.jobdtl_inhevent,
	D.jobdtl_inhagent,
	D.jobdtl_inhtime,
	jobdtl_minrun,
	jobdtl_maxrun,
	jobdtl_concur,
	jobdtl_retnsn,
	jobdtl_rerun,
	jobdtl_carryover,
	jobdtl_extinfo,
	jobdtl_saveoutput,
	m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty = 'X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  mt.lvls +1 as lvls,
  case m.jobmst_type when 1 then  cast((mt.prnt || cast('\' as varchar(1)) || m.jobmst_name) as varchar(1000)) else mt.prnt end prnt  ,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
    m.jobmst_type,
    d.jobdtl_cmd,
    d.jobdtl_params,
    m.jobmst_active,
    m.jobmst_owner,
    m.jobmst_alias,
    d.JOBDTL_PROXY,
    D.JOBDTL_INTERVAL,
    D.JOBDTL_INTERVALCNT,
    D.JOBDTL_NORMALEXIT,
    D.JOBDTL_PRIORITY,
    D.SERVICEMST_ID,
    D.jobdtl_inhevent,
    D.jobdtl_inhagent,
    D.jobdtl_inhtime,
    d.jobdtl_minrun,
    d.jobdtl_maxrun,
    d.jobdtl_concur,
    d.jobdtl_retnsn,
    d.jobdtl_rerun,
    d.jobdtl_carryover,
    d.jobdtl_extinfo,
    d.jobdtl_saveoutput,
    m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
  SELECT 
  n.NODMST_NAME Agent,
  Case when nodmst_type = 11 then 'Adapter' when nodmst_type=6 then 'Agent' else cast(nodmst_type as varchar(10)) end AgentType,
  servicemst.servicemst_name  AdapterType,
  coalesce(nl.nodlstmst_name,' ') AgentList,
  sum(case when jde.jobmst_type is null then 0 else 1 end)  NumberOfJobs
From tidal.nodmst n
  left outer join JobDtlExtract jde on jde.nodmst_id= n.nodmst_id and  jde.jobmst_active = 'Y'
  left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id and not e.evntmst_name is null
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.servicemst on jde.SERVICEMST_ID = servicemst.servicemst_id  
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
where n.nodmst_type > 5
group by n.NODMST_NAME, n.nodmst_type, servicemst.servicemst_name, nl.nodlstmst_name 
union 
SELECT 
  n.NODMST_NAME Agent,
  Case when nodmst_type = 11 then 'Adapter' when nodmst_type=6 then 'Agent' end AgentType,  
  servicemst.servicemst_name  AdapterType,
  coalesce(nl.nodlstmst_name, ' ') AgentList,
  count(*)  NumberOfJobs
From tidal.nodlstms nl
  left outer join JobDtlExtract jde on jde.nodlstmst_id = nl.nodlstmst_id and  jde.jobmst_active = 'Y'
  left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id and not e.evntmst_name is null
  left outer join tidal.nodmst n on jde.nodmst_id = n.nodmst_id
  left outer join tidal.servicemst on jde.SERVICEMST_ID = servicemst.servicemst_id  
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
--where n.nodmst_id > 0
group by n.NODMST_NAME,nodmst_type,servicemst.servicemst_name, nl.nodlstmst_name
--order by n.NODMST_NAME, nl.nodlstmst_name
       ]]>
    </querytext_oracle>
    </query>


    <query>
        <queryname>330 User Last Logon</queryname>
        <category>Users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <cachetimeout>300</cachetimeout>
        <querytext_sqlserver>
      select umst.usrmst_name ,
      ( SELECT max(msglog_crtdt) FROM msglog
      where msglog_text like 'User%logged onto system%' and  msglog_text like '%' + umst.usrmst_name + '%')  as LastLogon
      from usrmst as umst
    </querytext_sqlserver>
        <querytext_oracle>
SELECT usrmst.usrmst_name ,
  (SELECT MAX(msglog_crtdt)
  FROM tidal.msglog
  WHERE msglog_text LIKE 'User%logged onto system%'
  AND msglog_text LIKE concat(concat('%',usrmst.usrmst_name),'%')
  ) AS LastLogonDate
FROM tidal.usrmst
    </querytext_oracle>
    </query>
    <query>
        <queryname>333 User Workgroup membership</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
SELECT    distinct    usrmst.usrmst_domain, usrmst.usrmst_name, secmst.secmst_name, workusr.workgrp_id, workgrp.workgrp_name, usrmst.usrmst_suser, usrmst.usrmst_lstchgtm
      FROM            usrmst INNER JOIN
      secmst ON usrmst.secmst_id = secmst.secmst_id INNER JOIN
      workusr ON usrmst.usrmst_id = workusr.owner_id INNER JOIN
      workgrp ON ( workusr.workgrp_id = workgrp.workgrp_id) or usrmst.usrmst_suser ='Y'
order by usrmst.USRMST_NAME
    </querytext_sqlserver>
        <querytext_oracle>
SELECT    distinct    usrmst.usrmst_domain, usrmst.usrmst_name, secmst.secmst_name, workusr.workgrp_id, workgrp.workgrp_name, usrmst.usrmst_suser, usrmst.usrmst_lstchgtm
      FROM            usrmst INNER JOIN
      secmst ON usrmst.secmst_id = secmst.secmst_id INNER JOIN
      workusr ON usrmst.usrmst_id = workusr.owner_id INNER JOIN
      workgrp ON ( workusr.workgrp_id = workgrp.workgrp_id) or usrmst.usrmst_suser ='Y'
order by usrmst.USRMST_NAME
    </querytext_oracle>
    </query>
    <query>
        <queryname>335 Users Logon by Date</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
           <![CDATA[
      select count(msglog_text) TimesLoggedIn , Convert(varchar(10), DATEADD(dd, 0, DATEDIFF(dd, 0, msglog_crtdt)),120) ProdDate , usrmst_name
      FROM msglog
      where msglog_text like 'User%logged onto system%'
      and usrmst_name like '%<<User>>%'
       group by  usrmst_name,DATEADD(dd, 0, DATEDIFF(dd, 0, msglog_crtdt))
       ]]>
    </querytext_sqlserver>
        <querytext_oracle>
      select count(msglog_text) TimesLoggedIn ,trunc(msglog_crtdt) as proddt
      FROM tidal.msglog
      where msglog_text like 'User%logged onto system%' group by trunc(msglog_crtdt)
    </querytext_oracle>
    </query>
    <query>
        <queryname>340 User that owns no objects</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      Select distinct
      usrmst.usrmst_id,
      usrmst.usrmst_name,
      usrmst.usrmst_domain ,
      usrmst.usrmst_fullname,
      owner.owner_type
      From
      Usrmst , owner,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobmst_owner From Jobmst Where jobmst_owner Is Not Null)) Usernotownerjob,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobrun_owner From jobrun Where jobrun_owner Is Not Null)) Usernotownerjobrun,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy From Jobdtl Where jobdtl_proxy Is Not Null)) Usernotruntimeuser1,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy2 From Jobdtl Where jobdtl_proxy2 Is Not Null)) Usernotruntimeuser2,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct evntmst_owner From evntmst Where evntmst_owner Is Not Null)) UsernotownerCalendar,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From owneragt Where owner_id Is Not Null)) UsernotownerAgent,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct resmst_owner From resmst Where resmst_owner Is Not Null)) UsernotownerResource,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From tskmst Where owner_id Is Not Null)) UsernotownerTask,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From varmst Where owner_id Is Not Null)) UsernotownerVariable,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct viewmst_owner From viewmst Where viewmst_owner Is Not Null)) UsernotownerView,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct dshmst_owner From dshmst Where dshmst_owner Is Not Null)) UsernotownerDashBoard,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct prtmst_owner From prtmst Where prtmst_owner Is Not Null)) UsernotownerPrtMst,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct workgrp_owner From workgrp Where workgrp_owner Is Not Null)) UsernotownerWorkGroup,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct foldermst_owner From foldermst Where foldermst_owner Is Not Null)) UsernotownerFolder
      Where
      usrmst.usrmst_id = owner.owner_id and
      usrmst.usrmst_id = Usernotownerjob.Usrmst_Id And
      usrmst.usrmst_id = Usernotownerjobrun.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser1.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser2.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerCalendar.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerAgent.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerResource.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerTask.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerVariable.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerView.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerDashBoard.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerPrtMst.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerWorkGroup.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerFolder.Usrmst_Id
      order by usrmst.usrmst_domain, usrmst.usrmst_name
    </querytext_sqlserver>
        <querytext_oracle>
      Select distinct
      usrmst.usrmst_id,
      usrmst.usrmst_name,
      usrmst.usrmst_domain ,
      usrmst.usrmst_fullname,
      owner.owner_type
      From
      tidal.Usrmst , tidal.owner,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobmst_owner From tidal.Jobmst Where jobmst_owner Is Not Null)) Usernotownerjob,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobrun_owner From tidal.jobrun Where jobrun_owner Is Not Null)) Usernotownerjobrun,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy From tidal.Jobdtl Where jobdtl_proxy Is Not Null)) Usernotruntimeuser1,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy2 From tidal.Jobdtl Where jobdtl_proxy2 Is Not Null)) Usernotruntimeuser2,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct evntmst_owner From tidal.evntmst Where evntmst_owner Is Not Null)) UsernotownerCalendar,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.owneragt Where owner_id Is Not Null)) UsernotownerAgent,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct resmst_owner From tidal.resmst Where resmst_owner Is Not Null)) UsernotownerResource,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.tskmst Where owner_id Is Not Null)) UsernotownerTask,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.varmst Where owner_id Is Not Null)) UsernotownerVariable,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct viewmst_owner From tidal.viewmst Where viewmst_owner Is Not Null)) UsernotownerView,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct dshmst_owner From tidal.dshmst Where dshmst_owner Is Not Null)) UsernotownerDashBoard,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct prtmst_owner From tidal.prtmst Where prtmst_owner Is Not Null)) UsernotownerPrtMst,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct workgrp_owner From tidal.workgrp Where workgrp_owner Is Not Null)) UsernotownerWorkGroup,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct foldermst_owner From tidal.foldermst Where foldermst_owner Is Not Null)) UsernotownerFolder
      Where
      usrmst.usrmst_id = owner.owner_id and
      usrmst.usrmst_id = Usernotownerjob.Usrmst_Id And
      usrmst.usrmst_id = Usernotownerjobrun.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser1.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser2.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerCalendar.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerAgent.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerResource.Usrmst_Id And
            usrmst.usrmst_id = UsernotownerTask.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerVariable.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerView.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerDashBoard.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerPrtMst.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerWorkGroup.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerFolder.Usrmst_Id
      order by usrmst.usrmst_domain, usrmst.usrmst_name
    </querytext_oracle>
    </query>
    <query>
        <queryname>401 Job Dependencies</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobmst.jobmst_id, jobmst.jobmst_name, 
              jobmst.jobmst_prntname AS ParentGroup, 
						--  REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst.jobmst_prntname)), char(92), '.'), 1)) AS ParentGroup1
						--, REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst.jobmst_prntname)), char(92), '.'), 2)) AS [ParentGroup2]
						--, REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst.jobmst_prntname)), char(92), '.'), 3)) AS [ParentGroup3],
 jobdtl.jobdtl_cmd,jobmst.jobmst_active, jobmst_1.jobmst_name AS Depon_jobmst_name, 
						jobmst_1.jobmst_prntname AS Depon_ParentGroup, 
 						--  REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst_1.jobmst_prntname)), char(92), '.'), 1)) AS Depon_Parentgroup1
						--, REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst_1.jobmst_prntname)), char(92), '.'), 2)) AS Depon_Parentgroup2
						--, REVERSE(PARSENAME(REPLACE(REVERSE(trim(char(92) from jobmst_1.jobmst_prntname)), char(92), '.'), 3)) AS Depon_Parentgroup3,
                         jobdep.jobmst_id AS Depon_jobmst_id, jobmst_1.jobmst_active as Depon_jobmst_active, jobdep.jobdep_filename AS Filename,
						  nodmst.nodmst_name AS Server, varmst.varmst_name, jobdep.jobdep_value, jobdep.jobdep_type, jobdep.jobdep_ingroup
FROM            jobmst INNER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobmst_id INNER JOIN
                         jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id LEFT OUTER JOIN
                         varmst ON jobdep.varmst_id = varmst.varmst_id LEFT OUTER JOIN
                         nodmst ON jobdep.nodmst_id = nodmst.nodmst_id LEFT OUTER JOIN
                         jobmst AS jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X' and
  (jobmst.jobmst_name like '<<job_name>><<%>>')
   and (jobmst.jobmst_prntname like '\<<job_group>><<%>>')
   and jobmst.jobmst_id  like '<<jobmst_id:%>>')
ORDER BY jobmst.jobmst_prntname, jobmst.jobmst_name
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT        jobmst.jobmst_id, jobmst.jobmst_name, jobmst.jobmst_prntname, jobdtl.jobdtl_cmd, jobmst.jobmst_active, jobmst_1.jobmst_name AS Depon_jobmst_name, jobmst_1.jobmst_prntname AS Depon_jobmst_prntname, 
                         jobdep.jobmst_id AS Depon_jobmst_id, jobmst_1.jobmst_active as Depon_jobmst_active, jobdep.jobdep_filename AS Filename, nodmst.nodmst_name AS Server, varmst.varmst_name, jobdep.jobdep_value, jobdep.jobdep_type
FROM            tidal.jobmst INNER JOIN
                         tidal.jobdep ON jobmst.jobmst_id = jobdep.jobmst_id INNER JOIN
                         tidal.jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id LEFT OUTER JOIN
                         tidal.varmst ON jobdep.varmst_id = varmst.varmst_id LEFT OUTER JOIN
                         tidal.nodmst ON jobdep.nodmst_id = nodmst.nodmst_id LEFT OUTER JOIN
                         tidal.jobmst jobmst_1 ON jobdep.jobdep_jobmst = jobmst_1.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X' and  (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '\<<job_group>><<%>>'))
ORDER BY jobmst.jobmst_prntname, jobmst.jobmst_name
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>del-401 - Job Dependencies</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT  jobmst.jobmst_id, jobmst.jobmst_type, jobmst.jobmst_name, jobmst.jobmst_prntname, jobmst.jobmst_alias,jobmst.jobmst_owner, jobmst_1.jobmst_name [DependentOn-Jobname],
jobmst_1.jobmst_prntname [DependentOn-JobGroup], jobdtl.jobdtl_cmd, jobdep.jobdep_filename, jobdep.nodmst_id jobdep_nodmst_id, jobdep.jobdep_type
FROM jobdtl INNER JOIN
jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id LEFT OUTER JOIN
jobmst jobmst_1 RIGHT OUTER JOIN
jobdep ON jobmst_1.jobmst_id = jobdep.jobdep_jobmst ON jobmst.jobmst_id = jobdep.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X' and  (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '\<<job_group>><<%>>'))
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobmst.jobmst_id, jobmst.jobmst_type, jobmst.jobmst_name, jobmst.jobmst_prntname, jobmst.jobmst_alias,jobmst.jobmst_owner, jobmst_1.jobmst_name DependentOn_Jobname,
jobmst_1.jobmst_prntname DependentOn_JobGroup, jobdtl.jobdtl_cmd, jobdep.jobdep_filename, jobdep.nodmst_id jobdep_nodmst_id, jobdep.jobdep_type
 FROM jobdtl INNER JOIN
jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id LEFT OUTER JOIN
jobmst jobmst_1 RIGHT OUTER JOIN
jobdep ON jobmst_1.jobmst_id = jobdep.jobdep_jobmst ON jobmst.jobmst_id = jobdep.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X' and rownum <= @maxrec  and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '\<<job_group>><<%>>'))
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>402 Events and associated Jobs</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      SELECT trgmst.trgmst_name EVENT, jobmst.jobmst_prntname, jobmst.jobmst_name, jobmst.jobmst_id
      FROM trgjob INNER JOIN
      trgmst ON trgjob.trgmst_id = trgmst.trgmst_id INNER JOIN
      jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
      WHERE (jobmst.jobmst_dirty != '[X]') order by EVENT
    </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT trgmst.trgmst_name EVENT,
  jobmst.jobmst_prntname,
  jobmst.jobmst_name,
  jobmst.jobmst_id
FROM tidal.trgjob
INNER JOIN tidal.trgmst
ON trgjob.trgmst_id = trgmst.trgmst_id
INNER JOIN tidal.jobmst
ON trgjob.jobmst_id         = jobmst.jobmst_id
WHERE (jobmst.jobmst_dirty != '[X]')
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>403 Events not used</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
    SELECT        trgmst.trgmst_id, trgmst.trgmst_name, trgjob.trgjob_id, trgmst.trgmst_type
    FROM            trgmst LEFT OUTER JOIN
    trgjob ON trgmst.trgmst_id = trgjob.trgmst_id
    WHERE        (trgjob.trgjob_id IS NULL) and trgmst_type=1
  </querytext_sqlserver>
        <querytext_oracle>
SELECT trgmst.trgmst_id,
  trgmst.trgmst_name,
  trgjob.trgjob_id,
  trgmst.trgmst_type
FROM tidal.trgmst
LEFT OUTER JOIN tidal.trgjob
ON trgmst.trgmst_id      = trgjob.trgmst_id
WHERE (trgjob.trgjob_id IS NULL)
AND trgmst_type          =1
  </querytext_oracle>
    </query>
    <query>
        <queryname>404 Actions not used</queryname>
        <category>actions</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
    SELECT        tskmst.tskmst_id AS Expr1, tskmst.tskmst_name, tskmst.tskmst_desc, tskmst.nodmst_id, tskmst.servicemst_id, tskmst.tskmst_lstchgtm, trgtsk.trgtsk_id, tskmst.owner_id
    FROM            tskmst LEFT OUTER JOIN
    trgtsk ON tskmst.tskmst_id = trgtsk.tskmst_id
    WHERE        (trgtsk.trgtsk_id IS NULL)
  </querytext_sqlserver>
        <querytext_oracle>
SELECT tskmst.tskmst_id AS Expr1,
  tskmst.tskmst_name,
  tskmst.tskmst_desc,
  tskmst.nodmst_id,
  tskmst.servicemst_id,
  tskmst.tskmst_lstchgtm,
  trgtsk.trgtsk_id,
  tskmst.owner_id
FROM tidal.tskmst
LEFT OUTER JOIN tidal.trgtsk
ON tskmst.tskmst_id      = trgtsk.tskmst_id
WHERE (trgtsk.trgtsk_id IS NULL)
  </querytext_oracle>
    </query>
    <query>
        <queryname>405 Active Jobs with Dependencies on Inactive Jobs</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT  jobmst.jobmst_id, jobmst.jobmst_type, jobmst.jobmst_name, jobmst.jobmst_prntname, jobmst.jobmst_active active,jobmst.jobmst_alias,jobmst.jobmst_owner, jobmst_1.jobmst_name [DependentOn-Jobname],
jobmst_1.jobmst_prntname [DependentOn-JobGroup] , jobmst_1.jobmst_active active_dep,  jobdtl.jobdtl_cmd, jobdep.jobdep_filename, jobdep.nodmst_id jobdep_nodmst_id, jobdep.jobdep_type , jobdep.jobdep_canignore
FROM jobdtl INNER JOIN
jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id LEFT OUTER JOIN
jobmst jobmst_1 RIGHT OUTER JOIN
jobdep ON jobmst_1.jobmst_id = jobdep.jobdep_jobmst ON jobmst.jobmst_id = jobdep.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X' and  (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '\<<job_group>><<%>>')) and jobmst_1.jobmst_active='N' and jobmst.jobmst_active='Y'
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobmst.jobmst_id,
  jobmst.jobmst_type,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobmst.jobmst_active active,
  jobmst.jobmst_alias,
  jobmst.jobmst_owner,
  jobmst_1.jobmst_name "DependentOn-Jobname",
  jobmst_1.jobmst_prntname "DependentOn-JobGroup" ,
  jobmst_1.jobmst_active active_dep,
  jobdtl.jobdtl_cmd,
  jobdep.jobdep_filename,
  jobdep.nodmst_id jobdep_nodmst_id,
  jobdep.jobdep_type ,
  jobdep.jobdep_canignore
FROM tidal.jobdtl
INNER JOIN tidal.jobmst
ON jobdtl.jobdtl_id = jobmst.jobdtl_id
LEFT OUTER JOIN tidal.jobmst jobmst_1
RIGHT OUTER JOIN tidal.jobdep
ON jobmst_1.jobmst_id       = jobdep.jobdep_jobmst
ON jobmst.jobmst_id         = jobdep.jobmst_id
WHERE (jobmst.jobmst_dirty != 'X'
AND (jobmst.jobmst_name LIKE '<<job_name>><<%>>')
AND (jobmst.jobmst_prntname LIKE '\<<job_group>><<%>>'))
AND jobmst_1.jobmst_active='N'
AND jobmst.jobmst_active  ='Y'
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>406 Jobs with Events with email actions</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
        <![CDATA[
   SELECT    jobmst.jobmst_name, jobmst.jobmst_type, jobmst.jobmst_active, jobmst.jobmst_prntname AS [Group],
       trgmst.trgmst_id, trgmst.trgmst_type, trgmst.trgmst_name AS EventName,  tskmail.tskmail_subject AS EmailSubject, tskmail.tskmail_memo AS EmailText, 
                         tskmail.tskmail_to_ext, tskmail.tskmail_to_int, trgmst.trgmst_trigger, trgmst.trgmst_parm, strmst.strmst_desc AS EventTrigger, strmst.strmst_type, jobmst.jobmst_id,  tskmst.tskmst_name
   FROM            trgmst INNER JOIN
                         trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
                         strmst ON trgmst.trgmst_trigger = strmst.strmst_id INNER JOIN
                         trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         jobmst ON trgjob.jobmst_id = jobmst.jobmst_id INNER JOIN
                         tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id LEFT OUTER JOIN
                         tskmail ON trgtsk.tskmst_id = tskmail.tskmail_id
WHERE        (strmst.strmst_type = 12) AND (NOT (jobmst.jobmst_dirty = 'X'))
]]>
  </querytext_sqlserver>
        <querytext_oracle>
    <![CDATA[
   SELECT    jobmst.jobmst_name, jobmst.jobmst_type, jobmst.jobmst_active, jobmst.jobmst_prntname  JobGroup,
       trgmst.trgmst_id, trgmst.trgmst_type, trgmst.trgmst_name AS EventName,  tskmail.tskmail_subject AS EmailSubject, tskmail.tskmail_memo AS EmailText, 
                         tskmail.tskmail_to_ext, tskmail.tskmail_to_int, trgmst.trgmst_trigger, trgmst.trgmst_parm, strmst.strmst_desc AS EventTrigger, strmst.strmst_type, jobmst.jobmst_id,  tskmst.tskmst_name
   FROM            tidal.trgmst INNER JOIN
                         tidal.trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
                         tidal.strmst ON trgmst.trgmst_trigger = strmst.strmst_id INNER JOIN
                         tidal.trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         tidal.jobmst ON trgjob.jobmst_id = jobmst.jobmst_id INNER JOIN
                         tidal.tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id LEFT OUTER JOIN
                         tidal.tskmail ON trgtsk.tskmst_id = tskmail.tskmail_id
WHERE        (strmst.strmst_type = 12) AND (NOT (jobmst.jobmst_dirty = 'X'))
]]>
  </querytext_oracle>
    </query>
    <query>
        <queryname>407 Jobruns with Events history</queryname>
        <category>eventshistory</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
        <![CDATA[
  SELECT        trgmst.trgmst_id, trgmst.trgmst_type, trgmst.trgmst_name AS EventName, trgmst.trgmst_desc AS EventDesc, trgmst.trgmst_parm, strmst.strmst_desc AS EventTrigger, jobmst.jobmst_id, jobmst.jobmst_name, 
                         tskmst.tskmst_name, jobmst.jobmst_type, jobmst.jobmst_active, jobmst.jobmst_prntname AS [Group], trgtskrun.trgtskrun_id, trgtskrun.trgtskrun_payload, trgtskrun.trgtskrun_crtdt, trgtskrun.trgtskrun_status, 
                         trgtskrun.trgtskrun_data, trgtskrun.jobrun_id, trgtskrun.trgtskrun_rundt, trgtskrun.trgtskrun_expire, jobrun.jobrun_proddt, trgtskrun.trgtskrun_transaction, trgmst.trgmst_jobctl, trgmst.trgmst_lstchgtm
FROM            jobrun INNER JOIN
                         trgtskrun ON jobrun.jobrun_id = trgtskrun.jobrun_id INNER JOIN
                         trgmst INNER JOIN
                         trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
                         strmst ON trgmst.trgmst_trigger = strmst.strmst_id INNER JOIN
                         trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         jobmst ON trgjob.jobmst_id = jobmst.jobmst_id ON trgtskrun.jobmst_id = jobmst.jobmst_id LEFT OUTER JOIN
                         tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
WHERE        (strmst.strmst_type = 12) AND (NOT (jobmst.jobmst_dirty = 'X')) and jobrun.jobrun_proddt >= '<<from_date>>' and jobrun.jobrun_proddt <= '<<to_date>> 23:59:59'
]]>
  </querytext_sqlserver>
        <querytext_oracle>
    <![CDATA[
  SELECT        trgmst.trgmst_id, trgmst.trgmst_type, trgmst.trgmst_name AS EventName, trgmst.trgmst_desc AS EventDesc, trgmst.trgmst_parm, strmst.strmst_desc AS EventTrigger, jobmst.jobmst_id, jobmst.jobmst_name, 
                         tskmst.tskmst_name, jobmst.jobmst_type, jobmst.jobmst_active, jobmst.jobmst_prntname AS [Group], trgtskrun.trgtskrun_id, trgtskrun.trgtskrun_payload, trgtskrun.trgtskrun_crtdt, trgtskrun.trgtskrun_status, 
                         trgtskrun.trgtskrun_data, trgtskrun.jobrun_id, trgtskrun.trgtskrun_rundt, trgtskrun.trgtskrun_expire, jobrun.jobrun_proddt, trgtskrun.trgtskrun_transaction, trgmst.trgmst_jobctl, trgmst.trgmst_lstchgtm
FROM            tidal.jobrun INNER JOIN
                         tidal.trgtskrun ON jobrun.jobrun_id = trgtskrun.jobrun_id INNER JOIN
                         tidal.trgmst INNER JOIN
                         tidal.trgtsk ON trgmst.trgmst_id = trgtsk.trgmst_id INNER JOIN
                         tidal.strmst ON trgmst.trgmst_trigger = strmst.strmst_id INNER JOIN
                         tidal.trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
                         tidal.jobmst ON trgjob.jobmst_id = jobmst.jobmst_id ON trgtskrun.jobmst_id = jobmst.jobmst_id LEFT OUTER JOIN
                         tidal.tskmst ON trgtsk.tskmst_id = tskmst.tskmst_id
WHERE        (strmst.strmst_type = 12) AND (NOT (jobmst.jobmst_dirty = 'X'))
]]>
  </querytext_oracle>
    </query>
    <query>
        <queryname>408 Events with Actions</queryname>
        <category>events</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
        <![CDATA[
SELECT        j.trgtsk_id AS id, j.tskmst_id AS actionid, a.tskmst_name "Action", j.trgtsk_order AS actionorder,t.trgmst_jobctl AS jobcontrol, j.trgtsk_lstchgtm AS lastchangetime, 
                         t.trgmst_maxreruns AS rerunmax, j.trgmst_id AS triggerid,
case t.trgmst_jobctl 
  when 1 then 'Cancel'
  when 2 then 'Hold'
  when 3 then 'Override'
  when 4 then 'Release'
  when 5 then 'Rerun'
  when 6 then 'Set Completed Abnormally'
  when 7 then 'Set Completed Normally'
  when 8 then 'Set Error'
when 9 then 'Set Externally Defined'
when 10 then 'Set Orphaned'
when 11 then 'Set Skipped'
when 12 then 'Set cancel Pending'
when 13 then 'Set Waiting Operator'
when 14 then 'Set Cancel Waiting Operator' 
else to_char(t.trgmst_jobctl)
end as JobControl,
case  a.tskmst_type 
  when 1 then 'Email' 
  when 2 then 'OpAlert' 
  when 3 then 'SNMP' 
  when 4 then 'JobAdd'  
  when 5 then 'Log' 
  when 6 then 'Variable' 
  when 7 then 'ITO' 
  when 8 then 'JobAdd' 
  else to_char(tskmst_type)
end as tskmst_type,
t.trgmst_name "EventName"
FROM          dbo.trgtsk  j INNER JOIN
                         dbo.trgmst  t ON t.trgmst_id = j.trgmst_id LEFT OUTER JOIN
                         dbo.tskmst a on j.tskmst_id = a.tskmst_id
order by "EventName", actionOrder
]]>
  </querytext_sqlserver>
        <querytext_oracle>
    <![CDATA[
SELECT        j.trgtsk_id AS id, j.tskmst_id AS actionid, a.tskmst_name "Action", j.trgtsk_order AS actionorder,t.trgmst_jobctl AS jobcontrol, j.trgtsk_lstchgtm AS lastchangetime, 
                         t.trgmst_maxreruns AS rerunmax, j.trgmst_id AS triggerid,
case t.trgmst_jobctl 
  when 1 then 'Cancel'
  when 2 then 'Hold'
  when 3 then 'Override'
  when 4 then 'Release'
  when 5 then 'Rerun'
  when 6 then 'Set Completed Abnormally'
  when 7 then 'Set Completed Normally'
  when 8 then 'Set Error'
when 9 then 'Set Externally Defined'
when 10 then 'Set Orphaned'
when 11 then 'Set Skipped'
when 12 then 'Set cancel Pending'
when 13 then 'Set Waiting Operator'
when 14 then 'Set Cancel Waiting Operator' 
else to_char(t.trgmst_jobctl)
end as JobControl,
case  a.tskmst_type 
  when 1 then 'Email' 
  when 2 then 'OpAlert' 
  when 3 then 'SNMP' 
  when 4 then 'JobAdd'  
  when 5 then 'Log' 
  when 6 then 'Variable' 
  when 7 then 'ITO' 
  when 8 then 'JobAdd' 
  else to_char(tskmst_type)
end as tskmst_type,
t.trgmst_name "EventName"
FROM          tidal.trgtsk  j INNER JOIN
                         tidal.trgmst  t ON t.trgmst_id = j.trgmst_id LEFT OUTER JOIN
                         tidal.tskmst a on j.tskmst_id = a.tskmst_id
order by "EventName", actionOrder

]]>
  </querytext_oracle>
    </query>



 <query>
        <queryname>411 JobsWaitingOnResource</queryname>
        <category>monitoring</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
	   SELECT jobrun_id, jobmst.jobmst_name, jobmst.jobmst_prntname, jobrun.jobrun_stachgtm StatusChangedTime,Convert(varchar(10), jobrun_proddt,120)  as ProdDate  
       FROM jobrun, jobmst
WHERE 
 jobrun.jobmst_id = jobmst.jobmst_id 
 and (jobrun.jobrun_status like '<<jobrun_status:49>>' or '<<jobrun_status>>' = '0' )
 --and jobrun_status = 49
 AND  jobrun_proddt >= dateadd(DD, -2,GETDATE())
 AND jobrun_lstchgtm < (Select DATEADD(ss,-<<seconds:30>>,getdate()))
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobrun.jobrun_stachgtm StatusChangedTime,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
FROM tidal.jobrun,
  tidal.jobmst
WHERE jobrun.jobmst_id = jobmst.jobmst_id
and (jobrun.jobrun_status like '<<jobrun_status:49>>' or '<<jobrun_status>>' = '0' )
AND jobrun_proddt     >= sysdate - 2
AND jobrun_lstchgtm    <
  (SELECT  sysdate - <<seconds:30>>/(24*60*60) from dual)
  --(SELECT  sysdate - 30/(24*60*60) from dual)

	  ]]>
        </querytext_oracle>
    </query>
 <query>
        <queryname>411H JobsWaitingOnResource</queryname>
        <category>monitoring</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT jobrun_id, jobmst_name Jobname, jobmst_prntname jobgroup, jobrun.jobrun_stachgtm StatusChangedTime,Convert(varchar(10), jobrun_proddt,120)  as ProdDate  
       FROM jobrun, jobdata
WHERE 
 jobrun.jobmst_id = jobdata.jobmst_id 
 and jobdata.version = 0 
 --and jobrun_status = 49
 and (jobrun.jobrun_status like '<<jobrun_status:49>>' or '<<jobrun_status:49>>' = '0' )
 AND  jobrun_proddt >= dateadd(DD, -2,GETDATE())
 AND jobrun_lstchgtm < (Select DATEADD(ss,-<<seconds:30>>,getdate()))
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobrun.jobmst_name,
  jobrun.jobmst_prntname,
  jobrun.jobrun_stachgtm StatusChangedTime,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
FROM jobrun,
  jobdata
WHERE jobrun.jobmst_id = jobdata.jobmst_id and jobdata.version = 0
and (jobrun.jobrun_status like '<<jobrun_status:49>>' or '<<jobrun_status:49>>' = '0' )
AND jobrun_proddt     >= sysdate - 2
AND jobrun_lstchgtm    <
  (SELECT  sysdate - <<seconds:30>>/(24*60*60) from dual)
  --(SELECT  sysdate - 30/(24*60*60) from dual)

	  ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>412 JobsStuckinLaunched</queryname>
        <category>monitoring</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobrun_id, jobmst.jobmst_name, jobmst.jobmst_prntname, jobrun.jobrun_stachgtm StatusChangedTime , nodmst_name Agent
        FROM jobrun
        left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
		join jobmst on jobrun.jobmst_id = jobmst.jobmst_id 
WHERE 
 jobrun_status = <<jobrun_status:50>>
 AND  jobrun_proddt >= dateadd(DD, -2,GETDATE())
 AND jobrun_lstchgtm < (Select DATEADD(mi,-<<minutes:8>>,getdate()))
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobrun.jobrun_stachgtm StatusChangedTime,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
FROM tidal.jobrun,
  tidal.jobmst
WHERE jobrun.jobmst_id = jobmst.jobmst_id 
AND jobrun_status      = <<jobrun_status:50>>
--AND jobrun_status      = 49
AND jobrun_proddt     >= sysdate - 2
AND jobrun_lstchgtm    <
  (SELECT  sysdate - <<minutes:8>>/(24*60) from dual)
  --(SELECT  sysdate - 30/(24*60*60) from dual)

	  ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>412H JobsStuckinLaunched</queryname>
        <category>monitoring</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobrun_id, jobmst_name jobname, jobmst_prntname jobgroup, jobrun.jobrun_stachgtm StatusChangedTime , jobrun.nodmst_name Agent
        FROM jobrun
		--join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
WHERE 
 jobrun_status = <<jobrun_status:50>>
 --and jobdata.version = 0 
 AND  jobrun_proddt >= dateadd(DD, -2,GETDATE())
 AND jobrun_lstchgtm < (Select DATEADD(mi,-<<minutes:8>>,getdate()))
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobrun.jobmst_name,
  jobrun.jobmst_prntname,
  jobrun.jobrun_stachgtm StatusChangedTime,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
FROM jobrun,
  jobdata
WHERE jobrun.jobmst_id = jobdata.jobmst_id and jobdata.version = 0
AND jobrun_status      = <<jobrun_status:50>>
--AND jobrun_status      = 50
AND jobrun_proddt     >= sysdate - 2
AND jobrun_lstchgtm    <
  (SELECT  sysdate - <<minutes:8>>/(24*60) from dual)
  --(SELECT  sysdate - 30/(24*60*60) from dual)

	  ]]>
        </querytext_oracle>
    </query>
      <query>
        <queryname>500Dependencies</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>   
         <![CDATA[
SELECT        jobmst.jobmst_name DependentOn_Jobname, jobmst.jobmst_prntname DependentOn_JobGroup, jobdep.jobdep_type, jobdep.jobdep_filename AS FileDep, jobdep.varmst_id, jobdep.jobdep_value, 
                         jobdep.jobmst_id
FROM            jobmst  jm FULL OUTER JOIN
                         jobdtl FULL OUTER JOIN
                         jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id FULL OUTER JOIN
                         jobdep ON jobmst.jobmst_id = jobdep.jobdep_jobmst ON jm.jobmst_id = jobdep.jobmst_id
WHERE        (jm.jobmst_dirty <> 'X') AND (jobdep.jobmst_id =" + job_id + ")";
]]>
</querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
SELECT        jobmst.jobmst_name DependentOn_Jobname, jobmst.jobmst_prntname DependentOn_JobGroup, jobdep.jobdep_type, jobdep.jobdep_filename AS FileDep, jobdep.varmst_id, jobdep.jobdep_value, 
                         jobdep.jobmst_id
FROM            tidal.jobmst  jm FULL OUTER JOIN
                         tidal.jobdtl FULL OUTER JOIN
                         tidal.jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id FULL OUTER JOIN - 
                         tidal.jobdep ON jobmst.jobmst_id = jobdep.jobdep_jobmst ON jm.jobmst_id = jobdep.jobmst_id
WHERE        (jm.jobmst_dirty <> 'X') AND (jobdep.jobmst_id =" + job_id + ")";
]]>
 </querytext_oracle>
     </query> 
      <query>
        <queryname>510 Job definition data with history</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
         <![CDATA[
      select top <<rows:50>> * from jobdata where JobName like '<<job_name:%>>' and (jobmst_id = '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = '0' ) order by jobname, version
]]>
    </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
      select * from jobdata where rownum < <<rows:50>>  and JobName like '<<job_name:%>>' and (jobmst_id = '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = '0' ) order by jobname, version
]]>
    </querytext_oracle>
    </query>
    <query>
        <queryname>530 User Last Logon</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      select usrmst.usrmst_name , usrmst.usrmst_suser UserType,
      ( SELECT max(msglog_crtdt) FROM msglog with (NOLOCK)
      where msglog_text like 'User%logged onto system%' and msglog_text like '%' + usrmst.usrmst_name + '%' and msglog_type=2 and msglog_source=2)  LastLogonDate
      from usrmst with(NOLOCK)
    </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
SELECT usrmst.usrmst_name ,
  usrmst.usrmst_suser userType,
  (SELECT MAX(msglog_crtdt)
  FROM tidal.msglog
  WHERE msglog_text LIKE 'User%logged onto system%'
  AND msglog_text LIKE concat(concat('%',usrmst.usrmst_name),'%')
  ) LastLogonDate
FROM tidal.usrmst
]]>

    </querytext_oracle>
    </query>
    <query>
        <queryname>540 User that owns no objects</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
      Select distinct
      usrmst.usrmst_id,
      usrmst.usrmst_name,
      usrmst.usrmst_domain ,
      usrmst.usrmst_fullname,
      usrmst.usrmst_suser userType
      From
      Usrmst , owner,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobmst_owner From Jobmst Where jobmst_owner Is Not Null)) Usernotownerjob,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobrun_owner From jobrun Where jobrun_owner Is Not Null)) Usernotownerjobrun,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy From Jobdtl Where jobdtl_proxy Is Not Null)) Usernotruntimeuser1,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy2 From Jobdtl Where jobdtl_proxy2 Is Not Null)) Usernotruntimeuser2,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct evntmst_owner From evntmst Where evntmst_owner Is Not Null)) UsernotownerCalendar,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From owneragt Where owner_id Is Not Null)) UsernotownerAgent,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct resmst_owner From resmst Where resmst_owner Is Not Null)) UsernotownerResource,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From tskmst Where owner_id Is Not Null)) UsernotownerTask,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct owner_id From varmst Where owner_id Is Not Null)) UsernotownerVariable,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct viewmst_owner From viewmst Where viewmst_owner Is Not Null)) UsernotownerView,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct dshmst_owner From dshmst Where dshmst_owner Is Not Null)) UsernotownerDashBoard,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct prtmst_owner From prtmst Where prtmst_owner Is Not Null)) UsernotownerPrtMst,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct workgrp_owner From workgrp Where workgrp_owner Is Not Null)) UsernotownerWorkGroup,
      (Select usrmst_id From usrmst Where usrmst_id Not In (Select Distinct foldermst_owner From foldermst Where foldermst_owner Is Not Null)) UsernotownerFolder
      Where
      usrmst.usrmst_id = owner.owner_id and
      usrmst.usrmst_id = Usernotownerjob.Usrmst_Id And
      usrmst.usrmst_id = Usernotownerjobrun.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser1.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser2.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerCalendar.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerAgent.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerResource.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerTask.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerVariable.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerView.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerDashBoard.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerPrtMst.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerWorkGroup.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerFolder.Usrmst_Id
      order by usrmst.usrmst_domain, usrmst.usrmst_name
    </querytext_sqlserver>
        <querytext_oracle>
      Select distinct
      usrmst.usrmst_id,
      usrmst.usrmst_name,
      usrmst.usrmst_domain ,
      usrmst.usrmst_fullname,
      usrmst.usrmst_suser userType
      From
      tidal.Usrmst , tidal.owner,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobmst_owner From tidal.Jobmst Where jobmst_owner Is Not Null)) Usernotownerjob,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobrun_owner From tidal.jobrun Where jobrun_owner Is Not Null)) Usernotownerjobrun,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy From tidal.Jobdtl Where jobdtl_proxy Is Not Null)) Usernotruntimeuser1,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct jobdtl_proxy2 From tidal.Jobdtl Where jobdtl_proxy2 Is Not Null)) Usernotruntimeuser2,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct evntmst_owner From tidal.evntmst Where evntmst_owner Is Not Null)) UsernotownerCalendar,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.owneragt Where owner_id Is Not Null)) UsernotownerAgent,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct resmst_owner From tidal.resmst Where resmst_owner Is Not Null)) UsernotownerResource,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.tskmst Where owner_id Is Not Null)) UsernotownerTask,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct owner_id From tidal.varmst Where owner_id Is Not Null)) UsernotownerVariable,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct viewmst_owner From tidal.viewmst Where viewmst_owner Is Not Null)) UsernotownerView,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct dshmst_owner From tidal.dshmst Where dshmst_owner Is Not Null)) UsernotownerDashBoard,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct prtmst_owner From tidal.prtmst Where prtmst_owner Is Not Null)) UsernotownerPrtMst,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct workgrp_owner From tidal.workgrp Where workgrp_owner Is Not Null)) UsernotownerWorkGroup,
      (Select usrmst_id From tidal.usrmst Where usrmst_id Not In (Select Distinct foldermst_owner From tidal.foldermst Where foldermst_owner Is Not Null)) UsernotownerFolder
      Where
      usrmst.usrmst_id = owner.owner_id and
      usrmst.usrmst_id = Usernotownerjob.Usrmst_Id And
      usrmst.usrmst_id = Usernotownerjobrun.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser1.Usrmst_Id And
      usrmst.usrmst_id = Usernotruntimeuser2.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerCalendar.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerAgent.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerResource.Usrmst_Id And
      usrmst.usrmst_id = UsernotownerTask.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerVariable.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerView.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerDashBoard.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerPrtMst.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerWorkGroup.Usrmst_Id and
      usrmst.usrmst_id = UsernotownerFolder.Usrmst_Id
      order by usrmst.usrmst_domain, usrmst.usrmst_name
    </querytext_oracle>
    </query>
    <query>
        <queryname>550 Jobs that launched next prod date(based on prod date at midnight)</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobmst.jobmst_name, jobmst.jobmst_prntname,
 Convert(varchar(10), jobrun_proddt,120)  as ProdDate,
 jobrun.jobrun_carryover CarryOver, DATEADD(day, 1, schmst.schmst_proddt) nextday,
jobrun.jobrun_launchtm, jobrun.jobrun_esttime,
jobrun.jobrun_id
FROM schmst INNER JOIN
jobrun ON schmst.schmst_proddt = jobrun.jobrun_proddt AND DATEADD(day, 1, schmst.schmst_proddt) <= jobrun.jobrun_launchtm INNER JOIN
jobmst ON jobrun.jobmst_id = jobmst.jobmst_id
where jobrun.jobrun_proddt between '<<from_date>>' and '<<to_date>> 23:59:59'
ORDER BY schmst.schmst_proddt, jobmst.jobmst_name
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT schmst.schmst_proddt,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobrun.jobrun_proddt Expr1,
  jobrun.jobrun_carryover Expr2,
  schmst.schmst_proddt + 1  nextday,
  jobrun.jobrun_launchtm,
  jobrun.jobrun_esttime
FROM tidal.schmst
INNER JOIN tidal.jobrun
ON schmst.schmst_proddt = jobrun.jobrun_proddt
AND schmst.schmst_proddt + 1 <= jobrun.jobrun_launchtm
INNER JOIN tidal.jobmst
ON jobrun.jobmst_id = jobmst.jobmst_id
WHERE jobrun.jobrun_proddt BETWEEN to_date('2018-12-07','yyyy-mm-dd') AND to_date('2018-12-07 23:59:59','yyyy-mm-dd HH24:MI:SS')
--WHERE jobrun.jobrun_proddt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
ORDER BY schmst.schmst_proddt,
  jobmst.jobmst_name

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>560 Jobs owned by users</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobmst.jobmst_owner, owner.owner_name, owner.owner_type, jobmst.jobmst_id, jobmst.jobmst_name, jobmst.jobmst_prntname, jobmst.jobmst_dirty
FROM jobmst INNER JOIN
owner ON jobmst.jobmst_owner = owner.owner_id
WHERE (jobmst.jobmst_dirty <> 'X') AND (owner.owner_type = 1)
ORDER BY owner.owner_name, jobmst.jobmst_prntname, jobmst.jobmst_name, owner.owner_type
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobmst.jobmst_owner,
  owner.owner_name,
  owner.owner_type,
  jobmst.jobmst_id,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobmst.jobmst_dirty
FROM tidal.jobmst
INNER JOIN tidal.owner
ON jobmst.jobmst_owner      = owner.owner_id
WHERE (jobmst.jobmst_dirty <> 'X')
AND (owner.owner_type       = 1)
ORDER BY owner.owner_name,
  jobmst.jobmst_prntname,
  jobmst.jobmst_name,
  owner.owner_type
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>561 User list</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
            SELECT   
            usrmst_id,
            usrmst.usrmst_fullname FullName, 
            usrmst.usrmst_name Name,
            usrmst.usrmst_domain Domain,
            case  when usrmst_suser = 'Y' then 'Superuser' else secmst.secmst_name  end Security , 
            usrmst.usrmst_crttm Created,
            usrmst.usrmst_lstchgtm Updated
            FROM            usrmst left outer JOIN
                            secmst ON usrmst.secmst_id = secmst.secmst_id
            WHERE        (not usrmst.usrmst_wingroup = 'Y' and not usrmst_suser = 'R')
              and (not secmst_name is null or usrmst_suser='Y')
            order by FullName
            ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select * from tidal.usrmst
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>565 Object count owned by selected user</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
Select 
usrmst.usrmst_id,
usrmst.usrmst_name,
usrmst.usrmst_domain,
(Select 'jobmst = ' + cast(count(*) as varchar) From Jobmst Where usrmst.usrmst_id= jobmst_owner) CNT_JOBMST,
(Select 'jobrun = ' + cast(count(*) as varchar) From Jobrun Where usrmst.usrmst_id= jobrun_owner) CNT_JOBRUN,
(Select 'jobdtl_proxy = ' + cast(count(*) as varchar) From Jobdtl Where usrmst.usrmst_id= jobdtl_proxy) CNT_JOBDTL_PROXY,
(Select 'jobdtl_proxy2 = ' + cast(count(*) as varchar) From Jobdtl Where usrmst.usrmst_id= jobdtl_proxy2) CNT_JOBDTL_PROXY2,
(Select 'evntmst_owner = ' + cast(count(*) as varchar) From evntmst Where usrmst.usrmst_id= evntmst_owner) CNT_EVNTMST,
(Select 'owneragt = ' + cast(count(*) as varchar) From owneragt Where usrmst.usrmst_id= owner_id) CNT_OWNERAGT,
(Select 'resmst = ' + cast(count(*) as varchar) From resmst Where usrmst.usrmst_id= resmst_owner) CNT_RESMST,
(Select 'tskmst = ' + cast(count(*) as varchar) From tskmst Where usrmst.usrmst_id= owner_id) CNT_TSKMST,
(Select 'varmst = ' + cast(count(*) as varchar) From varmst Where usrmst.usrmst_id= owner_id) CNT_VARMST,
(Select 'viewmst = ' + cast(count(*) as varchar) From viewmst Where usrmst.usrmst_id= viewmst_owner) CNT_VIEWMST,
(Select 'dshmst = ' + cast(count(*) as varchar) From dshmst Where usrmst.usrmst_id= dshmst_owner) CNT_DSHMST,
(Select 'prtmst = ' + cast(count(*) as varchar) From prtmst Where usrmst.usrmst_id= prtmst_owner) CNT_PRTMST,
(Select 'workgrp = ' + cast(count(*) as varchar) From workgrp Where usrmst.usrmst_id= workgrp_owner) CNT_WORKGRP,
(Select 'foldermst = ' + cast(count(*) as varchar) From foldermst Where usrmst.usrmst_id= foldermst_owner) CNT_FOLDERMST
From
Usrmst usrmst
where usrmst.usrmst_name like '<<user_name>>'
order by usrmst.usrmst_domain, usrmst.usrmst_name

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
Select 
usrmst.usrmst_id,
usrmst.usrmst_name,
usrmst.usrmst_domain,
(Select 'jobmst = ' || cast(count(*) as varchar(10)) From tidal.Jobmst Where usrmst.usrmst_id= jobmst_owner) CNT_JOBMST,
(Select 'jobrun = ' || cast(count(*) as varchar(10)) From tidal.Jobrun Where usrmst.usrmst_id= jobrun_owner) CNT_JOBRUN,
(Select 'jobdtl_proxy = ' || cast(count(*) as varchar(10)) From tidal.Jobdtl Where usrmst.usrmst_id= jobdtl_proxy) CNT_JOBDTL_PROXY,
(Select 'jobdtl_proxy2 = ' || cast(count(*) as varchar(10)) From tidal.Jobdtl Where usrmst.usrmst_id= jobdtl_proxy2) CNT_JOBDTL_PROXY2,
(Select 'evntmst_owner = ' || cast(count(*) as varchar(10)) From tidal.evntmst Where usrmst.usrmst_id= evntmst_owner) CNT_EVNTMST,
(Select 'owneragt = ' || cast(count(*) as varchar(10)) From tidal.owneragt Where usrmst.usrmst_id= owner_id) CNT_OWNERAGT,
(Select 'resmst = ' || cast(count(*) as varchar(10)) From tidal.resmst Where usrmst.usrmst_id= resmst_owner) CNT_RESMST,
(Select 'tskmst = ' || cast(count(*) as varchar(10)) From tidal.tskmst Where usrmst.usrmst_id= owner_id) CNT_TSKMST,
(Select 'varmst = ' || cast(count(*) as varchar(10)) From tidal.varmst Where usrmst.usrmst_id= owner_id) CNT_VARMST,
(Select 'viewmst = ' || cast(count(*) as varchar(10)) From tidal.viewmst Where usrmst.usrmst_id= viewmst_owner) CNT_VIEWMST,
(Select 'dshmst = ' || cast(count(*) as varchar(10)) From tidal.dshmst Where usrmst.usrmst_id= dshmst_owner) CNT_DSHMST,
(Select 'prtmst = ' || cast(count(*) as varchar(10)) From tidal.prtmst Where usrmst.usrmst_id= prtmst_owner) CNT_PRTMST,
(Select 'workgrp = ' || cast(count(*) as varchar(10)) From tidal.workgrp Where usrmst.usrmst_id= workgrp_owner) CNT_WORKGRP,
(Select 'foldermst = ' || cast(count(*) as varchar(10)) From tidal.foldermst Where usrmst.usrmst_id= foldermst_owner) CNT_FOLDERMST
From
tidal.Usrmst usrmst
where usrmst.usrmst_name like '<<user_name>>'
order by usrmst.usrmst_domain, usrmst.usrmst_name
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>566 Objects owned by selected user</queryname>
        <category>users</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
Select 
usrmst.usrmst_id usrmst_id,
usrmst.usrmst_name usrmst_name,
usrmst.usrmst_domain usrmst_domain,
' ' as TableName,
' ' as TableData
from usrmst  where usrmst_id in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%' )
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'jobmst', cast(jobmst_id as varchar) + ':' + jobmst_name  From Jobmst Where  jobmst_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain, 'jobrun', cast(jobrun_id as varchar) + ':' + cast(jobrun_rundt as varchar)  From Jobrun Where jobrun_owner = <<usrmst_id>>
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'jobdtl_proxy', cast(jobdtl_id as varchar) + ':' + cast(jobdtl_proxy as varchar)  From Jobdtl Where  jobdtl_proxy = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'jobdtl_proxy2', cast(jobdtl_id as varchar) + ':' + cast(jobdtl_proxy2 as varchar) From Jobdtl Where  jobdtl_proxy = <<usrmst_id>>
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'evntmst', cast(evntmst_id as varchar) + ':' + cast(evntmst_owner as varchar) From evntmst Where  evntmst_owner = <<usrmst_id>>
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'owneragt', cast(owneragt_id as varchar) + ':' + cast(owner_id as varchar) From owneragt Where  owner_id = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'resmst', cast(resmst_id as varchar) + ':' + resmst_name  From resmst Where  resmst_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'tskmst', cast(tskmst_id as varchar) + ':' + tskmst_name  From tskmst Where  owner_id = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'varmst', cast(varmst_id as varchar) + ':' + varmst_name  From varmst Where  owner_id = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'viewmst', cast(viewmst_id as varchar) + ':' + viewmst_name  From viewmst Where viewmst_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'dshmst', cast(dshmst_id as varchar) + ':' + dshmst_name  From dshmst Where dshmst_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'prtmst', cast(prtmst_id as varchar) + ':' + prtmst_name  From prtmst Where prtmst_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'workgrp', cast(workgrp_id as varchar) + ':' + workgrp_name  From workgrp Where workgrp_owner = <<usrmst_id>> 
union select '' usrmst_id,'' usrmst_name , '' usrmst_domain,'foldermst', cast(foldermst_id as varchar) + ':' + foldermst_name  From foldermst Where foldermst_owner = <<usrmst_id>> 

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
Select 
cast(usrmst.usrmst_id as varchar(50)) usrmst_id,
usrmst.usrmst_name usrmst_name,
usrmst.usrmst_domain usrmst_domain,
' ' as TableName,
' ' as TableData
from tidal.usrmst  where usrmst_id in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'jobmst', cast(jobmst_id as varchar(50)) || ':' || jobmst_name  From tidal.Jobmst Where  jobmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain, 'jobrun', cast(jobrun_id as varchar(50)) || ':' || cast(jobrun_rundt as varchar(50))  From tidal.Jobrun Where jobrun_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'jobdtl_proxy', cast(jobdtl_id as varchar(50)) || ':' || jobdtl_proxy  From tidal.Jobdtl Where  jobdtl_proxy in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'jobdtl_proxy2', cast(jobdtl_id as varchar(50)) || ':' || jobdtl_proxy2  From tidal.Jobdtl Where  jobdtl_proxy in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'evntmst', cast(evntmst_id as varchar(50)) || ':' || evntmst_owner  From tidal.evntmst Where  evntmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'owneragt', cast(owneragt_id as varchar(50)) || ':' || owner_id  From tidal.owneragt Where  owner_id in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'resmst', cast(resmst_id as varchar(50)) || ':' || resmst_name  From tidal.resmst Where  resmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'tskmst', cast(tskmst_id as varchar(50)) || ':' || tskmst_name  From tidal.tskmst Where  owner_id in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'varmst', cast(varmst_id as varchar(50)) || ':' || varmst_name  From tidal.varmst Where  owner_id in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'viewmst', cast(viewmst_id as varchar(50)) || ':' || viewmst_name  From tidal.viewmst Where viewmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'dshmst', cast(dshmst_id as varchar(50)) || ':' || dshmst_name  From tidal.dshmst Where dshmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'prtmst', cast(prtmst_id as varchar(50)) || ':' || prtmst_name  From tidal.prtmst Where prtmst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'workgrp', cast(workgrp_id as varchar(50)) || ':' || workgrp_name  From tidal.workgrp Where workgrp_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%') 
union select ' ' usrmst_id,' ' usrmst_name , ' ' usrmst_domain,'foldermst', cast(foldermst_id as varchar(50)) || ':' || foldermst_name  From tidal.foldermst Where foldermst_owner in (select usrmst_id ursmst_id from usrmst where usrmst_name like '<<usrmst_name>>%')

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>570 Frequency of command in jobs where not variable is used</queryname>
        <category>variables</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT count(*) cnt , jobdtl.jobdtl_cmd
FROM jobmst INNER JOIN
jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE (jobmst.jobmst_dirty <> 'X') AND (jobmst.jobmst_type = 2) AND (NOT (jobdtl.jobdtl_cmd LIKE '%<%>%'))
group BY jobdtl.jobdtl_cmd
order by cnt desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT count(*) cnt , jobdtl.jobdtl_cmd
FROM tidal.jobmst INNER JOIN
tidal.jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE (jobmst.jobmst_dirty <> 'X') AND (jobmst.jobmst_type = 2) AND (NOT (jobdtl.jobdtl_cmd LIKE '%<%>%'))
group BY jobdtl.jobdtl_cmd
order by cnt desc
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>571 Jobs where variable is not used part of command</queryname>
        <category>variables</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobmst_name, jobmst_prntname, jobmst_alias, jobdtl.jobdtl_cmd
FROM jobmst INNER JOIN
jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE (jobmst.jobmst_dirty <> 'X') AND (jobmst.jobmst_type = 2) AND (NOT (jobdtl.jobdtl_cmd LIKE '%<%>%'))
order by jobmst_name desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobmst_name, jobmst_prntname, jobmst_alias, jobdtl.jobdtl_cmd
FROM tidal.jobmst INNER JOIN
tidal.jobdtl ON jobmst.jobdtl_id = jobdtl.jobdtl_id
WHERE (jobmst.jobmst_dirty <> 'X') AND (jobmst.jobmst_type = 2) AND (NOT (jobdtl.jobdtl_cmd LIKE '%<%>%'))
order by jobmst_name desc
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>572 Total Jobs defined</queryname>
        <category>jobs</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT count(*) TotalJobs, jobmst_active
FROM jobmst
WHERE (jobmst_dirty <> 'X')
group by jobmst_active
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT count(*) TotalJobs, jobmst_active
FROM tidal.jobmst
WHERE (jobmst_dirty <> 'X')
group by jobmst_active
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>573 Total Jobs per day</queryname>
        <category>analysis</category>
        <linkquery>715HJobActivity</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>ProdDate,JobRuns</chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT Convert(varchar(10), jobrun_rundt,120) ProdDate, sum(jobrun.jobrun_reruns+1) JobRuns, sum(1) as UniqueJobRuns
FROM jobrun
where jobrun.jobrun_proddt between '<<from_date>>' and '<<to_date>> 23:59:59'
group BY jobrun.jobrun_rundt
order by jobrun.jobrun_rundt
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_rundt "ProdDate", sum(jobrun.jobrun_reruns+1) "JobRuns", sum(1) as "UniqueJobRuns"
FROM jobrun
where jobrun.jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
group BY jobrun.jobrun_rundt
order by jobrun.jobrun_rundt
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>574 Total Jobs defined by Owner</queryname>
        <category>owners</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT Owner_name, count(*) TotalJobs, jobmst_active
FROM jobdata  
WHERE 
jobdata.version = 0 
group by Owner_name,jobmst_active
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT Owner_name, count(*) "TotalJobs", jobmst_active
FROM jobdata  
WHERE 
jobdata.version = 0 
group by Owner_name,jobmst_active
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>580 Frequency of parameters in jobs where no variable is used</queryname>
        <category>variables</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT count(*) cnt , cast(jobdata.jobdtl_cmd as varchar(1000)) cmd, cast(jobdata.jobdtl_params as varchar(1000)) job_parms
FROM jobdata 
WHERE  jobdata.version = 0  AND (jobdata.jobmst_type = 2) AND (NOT (jobdata.jobdtl_params LIKE '%<%>%'))
group BY cast(jobdata.jobdtl_params as varchar(1000)), cast(jobdata.jobdtl_cmd as varchar(1000))
order by cnt desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT count(*) cnt , cast(jobdata.jobdtl_cmd as varchar(1000)) cmd, cast(jobdata.jobdtl_params as varchar(1000)) job_parms
FROM jobdata 
WHERE  jobdata.version = 0  AND (jobdata.jobmst_type = 2) AND (NOT (jobdata.jobdtl_params LIKE '%<%>%'))
group BY cast(jobdata.jobdtl_params as varchar(1000)), cast(jobdata.jobdtl_cmd as varchar(1000))
order by cnt desc
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>582 Frequency of variables with same value</queryname>
        <category>variables</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select varmst_name , varmst_value from varmst where varmst_value in(
Select varmst_value
from dbo.varmst where not varmst_value is null
group by varmst_value
having count(*) > 1)
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select varmst_name , varmst_value from tidal.varmst where varmst_value in(
Select varmst_value
from tidal.varmst where not varmst_value is null
group by varmst_value
having count(*) > 1)
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>590 Compare jobs not in schedule between two dates</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT CONVERT(VARCHAR(10), jobrun_proddt,120) ProdDate,
  jobdata.JobName,
  jobdata.JobGroup,
  jobdata.jobmst_id,
  jobrun_id,
  Calendar
FROM jobrun
INNER JOIN jobdata
ON jobrun.jobmst_id         = jobdata.jobmst_id
WHERE (jobrun.jobrun_proddt = CONVERT(DATETIME, '<<from_date>>', 102))
AND NOT jobdata.jobmst_id  IN
  (SELECT jobdata.jobmst_id
  FROM jobrun
  INNER JOIN jobdata
  ON jobrun.jobmst_id         = jobdata.jobmst_id
  WHERE (jobrun.jobrun_proddt = CONVERT(DATETIME, '<<to_date>>', 102))
  AND jobdata.version         = 0
  )
GROUP BY jobrun.jobrun_proddt,
  jobdata.JobName,
  jobdata.JobGroup,
  jobdata.jobmst_id,
  jobrun.jobrun_id,
  jobdata.Calendar
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
  jobdata.JobName "JobName",
  cast(jobdata.JobGroup as varchar(4000)) "JobGroup",
  jobdata.jobmst_id,
  jobrun_id,
  Calendar "Calendar"
FROM jobrun
INNER JOIN jobdata
ON jobrun.jobmst_id         = jobdata.jobmst_id
WHERE (jobrun.jobrun_proddt = to_date('<<from_date>>', 'yyyy-mm-dd'))
AND NOT jobdata.jobmst_id  IN
  (SELECT jobdata.jobmst_id
  FROM jobrun
  INNER JOIN jobdata
  ON jobrun.jobmst_id         = jobdata.jobmst_id
  WHERE (jobrun.jobrun_proddt = to_date('<<to_date>>','yyyy-mm-dd'))
  AND jobdata.version         = 0
  )
GROUP BY jobrun.jobrun_proddt,
  jobdata.JobName,
  cast(jobdata.JobGroup as varchar(4000)),
  jobdata.jobmst_id,
  jobrun.jobrun_id, 
  Calendar
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>600 Jobs first time on schedule for specific date</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select * from
(
SELECT min(jobrun_proddt) firstproddt, jobdata.JobName, jobdata.JobGroup, jobdata.jobmst_id
FROM jobrun INNER JOIN
jobdata ON jobrun.jobmst_id = jobdata.jobmst_id and jobdata.version = 0
group BY jobdata.JobName, jobdata.JobGroup, jobdata.jobmst_id
) s1
where s1.firstproddt like '<<prod_date>>%'

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select * from
(
SELECT min(jobrun_proddt) firstproddt, jobdata.JobName "JobName", cast(jobdata.JobGroup as varchar(4000)) "JobGroup", jobdata.jobmst_id
FROM jobrun INNER JOIN
jobdata ON jobrun.jobmst_id = jobdata.jobmst_id and jobdata.version = 0
group BY jobdata.JobName, cast(jobdata.JobGroup as varchar(4000)), jobdata.jobmst_id
) s1
where s1.firstproddt = to_date('<<prod_date>>','yyyy-mm-dd')

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>del-610 Job output by Job and date</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select * , totoutput/(cnt + reruns) avgsize from (
SELECT jobmst.jobmst_name, jobmst.jobmst_prntname, Convert(varchar(10), jobrun.jobrun_proddt,120) ProdDate ,min([jobrun_fromtm]) fromtime,min(datepart(hour,jobrun_stachgtm)) hr
 ,max(jobrun_stachgtm) complete_time, sum(joboutput.jobrun_outputlen) totoutput,count(*) cnt, max(jobrun_reruns) reruns, max(jobrun_interval) interval, jobrun.jobrun_id
FROM jobrun INNER JOIN
joboutput ON jobrun.jobrun_id = joboutput.jobrun_id INNER JOIN
jobmst ON jobrun.jobmst_id = jobmst.jobmst_id
where jobrun.jobrun_proddt between '<<from_date>>' and '<<to_date>> 23:59:59'
group BY jobrun.jobrun_proddt, jobmst.jobmst_prntname, jobmst.jobmst_name, jobrun.jobrun_id
) s1 where totoutput > 1
 order by ProdDate , complete_time asc

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select jobmst_name, jobmst_prntname , fromtime, complete_time,totoutput, totoutput/(cnt + reruns) avgsize from (
SELECT jobmst.jobmst_name, jobmst.jobmst_prntname, jobrun.jobrun_proddt,min(jobrun_fromtm) fromtime ,max(jobrun_stachgtm) complete_time, sum(joboutput.jobrun_outputlen) totoutput,count(*) cnt, max(jobrun_reruns) reruns, max(jobrun_interval) interval
FROM jobrun INNER JOIN
joboutput ON jobrun.jobrun_id = joboutput.jobrun_id INNER JOIN
jobmst ON jobrun.jobmst_id = jobmst.jobmst_id
group BY jobrun.jobrun_proddt, jobmst.jobmst_prntname, jobmst.jobmst_name
) s1 where totoutput> 1 order by jobrun_proddt , complete_time asc
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>610H Job output by Job and date</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select * , totoutput/(cnt + reruns) avgsize from (
SELECT jobrun.jobmst_name, jobrun.jobmst_prntname,jobrun.jobmst_id, Convert(varchar(10), jobrun.jobrun_proddt,120) ProdDate ,min([jobrun_fromtm]) fromtime,min(datepart(hour,jobrun_stachgtm)) hr
 ,max(jobrun_stachgtm) complete_time, sum(jobrun.jobrun_outputlen) totoutput,count(*) cnt, max(jobrun_reruns) reruns, max(jobrun_interval) interval
FROM jobrun
where jobrun.jobrun_proddt between '<<from_date>>' and '<<to_date>> 23:59:59'
group BY jobrun.jobrun_proddt, jobrun.jobmst_prntname, jobrun.jobmst_name, jobrun.jobrun_id, jobrun.jobmst_id
) s1 where not totoutput  is null
 order by ProdDate , complete_time asc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT     s1.*, (totoutput/(cnt + reruns)) avgsize
FROM
  (SELECT min(jobrun.jobmst_name) jobmst_name,
    min(jobrun.jobmst_prntname) jobmst_prntname,
    min(jobrun.jobmst_id) jobmst_id,
    min(TO_CHAR( jobrun.jobrun_proddt, 'yyyy-mm-dd')) "ProdDate",
    MIN(jobrun_fromtm) fromtime,
    MIN(extract(hour from cast(jobrun_stachgtm as timestamp))) hr ,
    MAX(jobrun_stachgtm) complete_time,
    SUM(jobrun.jobrun_outputlen) totoutput,
    COUNT(*) cnt,
    MAX(jobrun_reruns) reruns,
    MAX(jobrun_interval) interval,
    min(jobrun.jobrun_id) jobrun_id
  FROM jobrun
  where jobrun.jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS') and not jobrun_stachgtm is null
  GROUP BY jobrun.jobrun_proddt,
    jobrun.jobmst_prntname,
    jobrun.jobmst_name,
    jobrun.jobrun_id,
    jobrun.jobmst_id
  ) s1
WHERE totoutput > 1
ORDER BY "ProdDate" ,
  complete_time ASC


]]>
        </querytext_oracle>
    </query>    
    <query>
        <queryname>620 WorkGroup with agents assigned</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT     workgrp.workgrp_name workgroup ,nodmst.nodmst_name agent, owner.owner_allagents
FROM         owneragt, workgrp, owner, nodmst  
where
           ( owneragt.nodmst_id = nodmst.nodmst_id and
            owneragt.owner_id = workgrp.workgrp_id and
            owneragt.owner_id = owner.owner_id AND workgrp.workgrp_id = owner.owner_id)
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT     workgrp.workgrp_name workgroup ,nodmst.nodmst_name agent, owner.owner_allagents
FROM         tidal.owneragt, tidal.workgrp, tidal.owner, tidal.nodmst  
where
           ( owneragt.nodmst_id = nodmst.nodmst_id and
            owneragt.owner_id = workgrp.workgrp_id and
            owneragt.owner_id = owner.owner_id AND workgrp.workgrp_id = owner.owner_id)
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>700H JobRuns count by status per production day</queryname>
        <querytotals>All Jobs:sum(Count);</querytotals>
        <category>analysis</category>
        <linkquery>710HAllJobRuns</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>ProdDate,jobrun_status,Cnt</chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select  Convert(varchar(10), proddt,120) ProdDate, sum(jobruns) as Cnt, jobrun_status from 
	(
	SELECT        jobrun_id, jobrun.jobmst_id, jobrun_instance,jobrun_proddt as proddt, 1 as jobruns,
	 statusname jobrun_status
	FROM            jobrun, jobrunstatus
	where jobrun.jobmst_type > 1
              and jobrun.jobrun_status = jobrunstatus.statusid 
              and jobrun_status like '<<jobrun_status:%>>'
              and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
	) subsel 
	group by proddt ,jobrun_status
order by proddt asc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
  select proddt as ProdDate,sum(jobruns) as Count, JobRun_Status from 
  (
  SELECT        jobrun_id, jobrun.jobmst_id, jobrun_instance,jobrun_proddt as proddt,1 as jobruns,
   case when jobrun_status=53 then 'Deferred' when jobrun_status=66 then 'Error Occurred' when jobrun_status=101 then 'Completed Normally' when jobrun_status=103 then 'Completed Abnormally'  when jobrun_status=104 then 'Skipped' when jobrun_status=105 then 'Orphaned' when jobrun_status=106 then 'Aborted' when jobrun_status=107 then 'Externally Defined'  when jobrun_status=108 then 'TimedOut' when jobrun_status <= 50 then 'Waiting' when jobrun_status = 54 then 'Deferred'  when jobrun_status=109 then 'Cancelled' else cast(jobrun_status as varchar(20))  end as jobrun_status
  FROM            jobrun, jobdata
  where  jobrun.jobmst_id = jobdata.jobmst_id and jobdata.version = 0
              and jobrun.jobmst_type>1
              --and jobrun_proddt >= to_date('2018-12-07','yyyy-mm-dd') and jobrun_proddt <= to_date('2018-12-07','yyyy-mm-dd')
              and jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd') and jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd')
	) subsel 
	group by proddt ,jobrun_status
	order by proddt asc
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>702 JobRuns by status for select production day range</queryname>
        <querytotals>All Jobs:sum(Count);</querytotals>
        <category>analysis</category>
        <linkquery>9700H All JobRuns by status per production day</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select JobStatus jobrun_status, jobruns Count , UniqueJobRuns from 
	(
	SELECT        rtrim(statusname) JobStatus,sum(case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end) jobruns, sum(1) as UniqueJobRuns
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type > 1
              and jobrun_proddt >='<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
			  and JOBRUNSTATUS.statusid=jobrun_status
			  and JOBDATA.version = 0
			  --and jobrun_owner = usrmst_id
			  group by statusname
	) subsel 
	group by JobStatus, UniqueJobRuns, jobruns
	--order by JobStatus
union 
select '_Total', sum(jobruns) Count , sum(UniqueJobRuns) from 
	(
	SELECT        rtrim(statusname) JobStatus,sum(case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end) jobruns, sum(1) as UniqueJobRuns
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type > 1
              and jobrun_proddt >='<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
  			  and JOBRUNSTATUS.statusid=jobrun_status
			  group by statusname
	) subsel 
order by 1	
	
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select JobStatus jobrun_status, jobruns Count , UniqueJobRuns from 
	(
	SELECT        rtrim(statusname) JobStatus,sum(case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end) jobruns, sum(1) as UniqueJobRuns
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type > 1
              and jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd')  and jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd')
			  and JOBRUNSTATUS.statusid=jobrun_status
			  and JOBDATA.version = 0
			  --and jobrun_owner = usrmst_id
			  group by statusname
	) subsel 
	group by JobStatus, UniqueJobRuns, jobruns
	--order by JobStatus
union 
select '_Total', sum(jobruns) Count , sum(UniqueJobRuns) from 
	(
	SELECT        rtrim(statusname) JobStatus,sum(case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end) jobruns, sum(1) as UniqueJobRuns
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type > 1
              and jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd')  and jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd')
  			  and JOBRUNSTATUS.statusid=jobrun_status
			  group by statusname
	) subsel 
order by 1
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>703 JobRuns by Owner, Status for select production day range</queryname>
        <querytotals>All Jobs:sum(Executions);</querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select JobOwner, jobruns Executions, max(unique_jobs) NumJobs, Jobrun_Status from 
	(
	SELECT        rtrim(statusname) Jobrun_Status,sum(1) jobruns,count( distinct jobdata.jobmst_id) unique_jobs, jobdata.owner_name  jobowner
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type>1
              and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
			  and statusid=jobrun_status
              and JOBDATA.version = 0
			  group by jobdata.owner_name, statusname
	) subsel 
	group by JobOwner,Jobrun_Status, jobruns
	order by Jobrun_Status, JobOwner
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select JobOwner, jobruns Executions, max(unique_jobs) NumJobs, Jobrun_Status from 
	(
	SELECT        rtrim(statusname) Jobrun_Status,sum(1) jobruns,count( distinct jobdata.jobmst_id) unique_jobs, jobdata.owner_name  jobowner
	FROM            jobrun, jobdata, JOBRUNSTATUS
	where  jobrun.jobmst_id = jobdata.jobmst_id
			  and jobdata.jobmst_type>1
              and jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd')  and jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd')
			  and statusid=jobrun_status
              and JOBDATA.version = 0
			  group by jobdata.owner_name, statusname
	) subsel 
	group by JobOwner,Jobrun_Status, jobruns
	order by Jobrun_Status, JobOwner
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>704H JobRuns Status Change Count</queryname>
        <querytotals>All Jobs:sum(Executions);</querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>Status,StartDate,Count</chartfields>
        <import_oracle>n</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
declare @StartTime datetime = '<<from_date>> 00:00:00',
      @EndTime datetime = '<<to_date>> 23:59:59',
      @Interval int = <<interval:60>> -- this can be changed.

      ;WITH cSequence AS
      (
      SELECT
      @StartTime AS StartDate,
      DATEADD(minute, @Interval, @StartTime) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
 /* insert into tmp_IRange */
SELECT StartDate, count(*)Count,  replace(SUBSTRING(msglog_text, charindex('status change to', msglog_text ) + len('status change to' ), 100),'.','') Status FROM msglog,cSequence 
		  where msglog_crtdt between StartDate and EndRange 
		  and msglog_text like '%status change to%'
		  group by StartDate,
		  SUBSTRING(msglog_text, charindex('status change to', msglog_text ) + len('status change to' ), 100) order by StartDate
		  OPTION (MAXRECURSION 0) ;
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
declare @StartTime datetime = '<<from_date>> 00:00:00',
      @EndTime datetime = '<<to_date>> 23:59:59',
      @Interval int = <<interval:60>> -- this can be changed.

      ;WITH cSequence AS
      (
      SELECT
      @StartTime AS StartDate,
      DATEADD(minute, @Interval, @StartTime) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
 /* insert into tmp_IRange */
SELECT StartDate, count(*)Count,  replace(SUBSTRING(msglog_text, charindex('status change to', msglog_text ) + len('status change to' ), 100),'.','') Status FROM msglog,cSequence 
		  where msglog_crtdt between StartDate and EndRange 
		  and msglog_text like '%status change to%'
		  group by StartDate,
		  SUBSTRING(msglog_text, charindex('status change to', msglog_text ) + len('status change to' ), 100)  order  by StartDate
		  OPTION (MAXRECURSION 0) ;
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>705 Jobs canceled, aborted or completed abnormal for selected production day</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT      coalesce(jobdata.JobGroup,'') as JobGroup, jobdata.Jobname as JobName, jobrun_esttime EstStartTime, jobrun_duration Duration,  jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end  jobruns,
	 statusname as jobrun_status
     --case when jobrun_status=53 then 'Deferred' when jobrun_status=101 then 'Completed Normally' when jobrun_status=103 then 'Completed Abnormally'  when jobrun_status=104 then 'Skipped' when jobrun_status=106 then 'Aborted'  when jobrun_status=108 then 'TimedOut' when jobrun_status <= 50 then 'Waiting' when jobrun_status = 53 then 'Deferred' when jobrun_status=106 then 'Aborted' when jobrun_status=107 then 'Externally Defined'  when jobrun_status=108 then 'TimedOut'  when jobrun_status=109 then 'Cancelled' else cast(jobrun_status as varchar(20))  end as JobStatus
	FROM   jobrun, jobdata , JOBRUNSTATUS
	where jobrun.jobmst_id = jobdata.jobmst_id
      and jobrun.jobrun_status = statusid 
	and  jobrun.jobrun_status in(103,106,109)
	and JOBDATA.version = 0
	and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
  order by ProdDate, jobrun_status, EstStartTime
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT COALESCE(CAST(jobdata.JobGroup AS VARCHAR(4000)),'') AS JobGroup,
  jobdata.Jobname                                           AS JobName,
  jobrun_esttime EstStartTime,
  jobrun_duration Duration,
  jobrun_id,
  jobrun.jobmst_id,
  jobrun_instance,
  TO_CHAR( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
  CASE
    WHEN jobrun_reruns=0
    THEN 1
    ELSE jobrun_reruns + 1
  END jobruns,
  statusname AS jobrun_status
  --case when jobrun_status=53 then 'Deferred' when jobrun_status=101 then 'Completed Normally' when jobrun_status=103 then 'Completed Abnormally'  when jobrun_status=104 then 'Skipped' when jobrun_status=106 then 'Aborted'  when jobrun_status=108 then 'TimedOut' when jobrun_status <= 50 then 'Waiting' when jobrun_status = 53 then 'Deferred' when jobrun_status=106 then 'Aborted' when jobrun_status=107 then 'Externally Defined'  when jobrun_status=108 then 'TimedOut'  when jobrun_status=109 then 'Cancelled' else cast(jobrun_status as varchar(20))  end as JobStatus
FROM jobrun,
  jobdata ,
  JOBRUNSTATUS
WHERE jobrun.jobmst_id    = jobdata.jobmst_id
AND jobrun.jobrun_status  = statusid
AND jobrun.jobrun_status IN(103,106,109)
AND JOBDATA.version       = 0
AND jobrun_proddt        >= to_date('<<from_date>>','yyyy-mm-dd')
AND jobrun_proddt        <= to_date('<<to_date>>','yyyy-mm-dd')
ORDER BY "ProdDate",
  jobrun_status,
  EstStartTime

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>710AllJobRuns</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields>ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver>
            <![CDATA[
	SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup,
     jobmst.jobmst_name as JobName,
      owner_name,
jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
     Case when jobrun.jobmst_type = 1 then 'JobGroup' 
        when jobrun.jobmst_type=2 then 'Job' 
        when jobrun.jobmst_type=6 then 'FTP'     
        when jobrun.jobmst_type=7 then 'AS400' 
        when jobrun.jobmst_type=8 then 'Adapter' 
        else cast(jobrun.jobmst_type as varchar) end JobType,
    strmst_desc + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
    nodmst.nodmst_name, 
    quemst.quemst_name,
    jobdtl_cmd command, 
    coalesce(jobrun.jobrun_extinfo,'') ExtInfo
  FROM   jobrun
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          --and  (jobrun.jobmst_type > 1 or not <<jobrun_id:0>> = 0)
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (quemst.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (nodmst.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobmst.jobmst_name like '<<job_name:%>>') and (coalesce(jobmst.jobmst_prntname,'') like '<<job_group:%>>')
		  and ((jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') 
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
	SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup, jobmst.jobmst_name as JobName, owner_name, jobrun_esttime EstStartTime,
      CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, jobrun.jobrun_launchtm StartTime,  jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
      case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,jobrun_duration,
     Case when jobrun.jobmst_type = 1 then 'JobGroup' 
        when jobrun.jobmst_type=2 then 'Job' 
        when jobrun.jobmst_type=6 then 'FTP'             
        when jobrun.jobmst_type=7 then 'AS400' 
        when jobrun.jobmst_type=8 then 'Adapter' 
        else cast(jobrun.jobmst_type as varchar) end JobType,

    strmst_desc + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
    nodmst.nodmst_name, quemst.quemst_name,  jobdtl_cmd command, coalesce(jobrun.jobrun_extinfo,'') ExtInfo
  FROM   tidal.jobrun
   left join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
   join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join tidal.strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join tidal.owner on  jobmst.jobmst_owner = owner.owner_id
   left join tidal.nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join tidal.jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          --and  (jobrun.jobmst_type > 1 or not <<jobrun_id:0>> = 0)
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (quemst.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (nodmst.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobmst.jobmst_name like '<<job_name:%>>') and (coalesce(jobmst.jobmst_prntname,' ') like '<<job_group:%>>')
		  --and ((jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') 
          and ((jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd')            
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>710HAllJobRuns</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns for production date range</querydescription>
        <db>reporting</db>
        <chartfields>jobrun_status,ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver> 
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,

jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
DATEADD(MINUTE, ROUND(DATEDIFF(MINUTE, 0, jobrun.jobrun_launchtm) / 15.0, 0) * 15, 0) StartTimeQtr,
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
DATEADD(MINUTE, ROUND(DATEDIFF(MINUTE, 0, jobrun.jobrun_stachgtm) / 15.0, 0) * 15, 0) EndTimeQtr,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 

   jobrun.owner_name,
  --JOBRUNSTATUS.statusname as jobrun_status,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job'
    when jobrun.jobmst_type=6 then 'FTP'          
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar) end JobType,
    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    jobrun_outputlen OutputSize,
    jobrun.nodmst_name, 
    quemst_name,  
    jobdtl_cmd command 
    --coalesce(jobrun.jobrun_extinfo,'') ExtInfo,
    --jobrun.jobrun_joboutput JobOutput
  FROM   jobrun with(nolock)
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          --(jobrun.jobmst_type > 1 or not <<jobrun_id:0>> = 0)  and
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.quemst_name like '<<queue:%>>' or '<<queue:%>>' = '%')
          and (jobrun.nodmst_name like '<<agent:%>>' or '<<agent:%>>' = '%')          
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,'') like '<<job_group:%>>')
		  and ((jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') 
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
          and (jobrun_joboutput like '<<joboutput:%>>' or '<<joboutput:%>>' = '%')
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status

]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
 jobrun_esttime "EstStartTime", 
  jobrun_duration Duration, 
 jobrun.jobrun_launchtm "StartTime", 
 COALESCE(jobrun_launchtm,jobrun_time,jobrun_esttime) + numToDSInterval( COALESCE(jobrun_duration, jobrun_estduration,0), 'second' ) "EndTime",
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
  case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,jobrun_duration,
   jobrun.owner_name,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job' 
    when jobrun.jobmst_type=6 then 'FTP'         
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar(2000)) end JobType,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    jobrun_outputlen "OutputSize",
    jobrun.nodmst_name, quemst_name,
    cast(jobdtl_cmd as varchar(1000)) command 
    --coalesce(cast(jobrun.jobrun_extinfo as varchar(4000)),'') "ExtInfo",
    --jobrun.jobrun_joboutput JobOutput
  FROM   jobrun
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,' ') like '<<job_group:%>>')
		  and (
		  (
            jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') 
		  ) 
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
          and (jobrun_joboutput like '<<joboutput:%>>' or '<<joboutput:%>>' = '%')
  order by "ProdDate", jobrun.jobrun_launchtm,  "EstStartTime", jobrun_status
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>AllJobRuns</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns for production date range</querydescription>
        <db>reporting</db>
        <template_type>jinja</template_type>
        <chartfields>jobrun_status,ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver> 
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,

jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
DATEADD(MINUTE, ROUND(DATEDIFF(MINUTE, 0, jobrun.jobrun_launchtm) / 15.0, 0) * 15, 0) StartTimeQtr,
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
DATEADD(MINUTE, ROUND(DATEDIFF(MINUTE, 0, jobrun.jobrun_stachgtm) / 15.0, 0) * 15, 0) EndTimeQtr,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 

   jobrun.owner_name,
  --JOBRUNSTATUS.statusname as jobrun_status,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job'
    when jobrun.jobmst_type=6 then 'FTP'          
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar) end JobType,
    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    jobrun_outputlen OutputSize,
    jobrun.nodmst_name, quemst_name,  jobdtl_cmd command
    --coalesce(jobrun.jobrun_extinfo,'') ExtInfo,
    --jobrun.jobrun_joboutput JobOutput
  FROM   jobrun with(nolock)
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          (jobrun.jobrun_id = '{{jobrun_id|default("0",true)}}' or {{jobrun_id|default("0",true)}} = 0 )
          and (jobrun.jobmst_id = '{{jobmst_id|default("0",true)}}' or {{jobmst_id|default("0",true)}} = 0 )
          and (jobrun.quemst_name like '{{queue|default("%",true)}}' or '{{queue|default("%",true)}}' = '%')
          and (jobrun.nodmst_name like '{{agent|default("%",true)}}' or '{{agent|default("%",true)}}' = '%')          
          and (jobrun.jobmst_name like '{{job_name|default("%",true)}}') and (coalesce(jobrun.jobmst_prntname,'') like '{{job_group|default("%",true)}}')
		  and ((jobrun_proddt >= '{{from_date}}'  and jobrun_proddt <= '{{to_date}}') 
            or ((not '{{jobrun_id|default("0",true)}}' = '0' ) ))
          and (jobrun.jobrun_status like '{{jobrun_status}}' or '{{jobrun_status}}' = '0' )
          and (jobrun_joboutput like '{{joboutput|default("%",true)}}' or '{{joboutput|default("%",true)}}' = '%')
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status

]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
{% block inherit_top %}{% endblock %}            
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
 jobrun_esttime "EstStartTime", 
  jobrun_duration Duration, 
 jobrun.jobrun_launchtm "StartTime", 
 COALESCE(jobrun_launchtm,jobrun_time,jobrun_esttime) + numToDSInterval( COALESCE(jobrun_duration, jobrun_estduration,0), 'second' ) "EndTime",
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
  case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,jobrun_duration,
   jobrun.owner_name,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job' 
    when jobrun.jobmst_type=6 then 'FTP'         
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar(2000)) end JobType,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    jobrun_outputlen "OutputSize",
    jobrun.nodmst_name, quemst_name,
    cast(jobdtl_cmd as varchar(1000)) command
    --coalesce(cast(jobrun.jobrun_extinfo as varchar(4000)),'') "ExtInfo",
    --jobrun.jobrun_joboutput JobOutput
  FROM   jobrun
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,' ') like '<<job_group:%>>')
		  and (
		  (
            jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') 
		  ) 
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
          and (jobrun_joboutput like '<<joboutput:%>>' or '<<joboutput:%>>' = '%')
  --order by "ProdDate", jobrun.jobrun_launchtm,  "EstStartTime", jobrun_status
  {% block inherit_bottom %}{% endblock %}            
]]>
        </querytext_oracle>
    </query>
<query>
        <queryname>JobrunSummary</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns summary for production date range</querydescription>
        <db>admiral</db> 
        <template_type></template_type>
        <chartfields>jobrun_status,ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver> 
            <![CDATA[
select m.jobmst_prntname Parent_Name, m.jobmst_name Job_Name,r.agent Agent,  r.avg_dur Average_Duration_Seconds, r.min_dur Minimum_Duration_Seconds, r.max_dur Maximum_Duration_Seconds, r.Runs Job_Runs	
from jobmst m		
inner join jobdtl d on m.jobdtl_id = d.jobdtl_id		
inner join (	SELECT [jobid]	,
		min(isnull(agentlistname, agentname)) agent
      ,avg(isnull(duration,0)) avg_dur		
      ,min(isnull(duration,0)) min_dur		
      ,max(isnull(duration,0)) max_dur		
	  ,sum(reruns + 1) Runs	
  FROM [jobrun_view]		
  where 
  productiondate between '<<from_date>>' and '<<to_date>>'
	and status > 10 	
	group by jobid ) r on m.jobmst_id = r.jobid	
order by r.avg_dur desc	
]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select m.jobmst_prntname Parent_Name, m.jobmst_name Job_Name,r.agent Agent,  r.avg_dur Average_Duration_Seconds, r.min_dur Minimum_Duration_Seconds, r.max_dur Maximum_Duration_Seconds, r.Runs Job_Runs	
from jobmst m		
inner join jobdtl d on m.jobdtl_id = d.jobdtl_id		
inner join (	SELECT [jobid]	,
		min(isnull(agentlistname, agentname)) agent
      ,avg(isnull(duration,0)) avg_dur		
      ,min(isnull(duration,0)) min_dur		
      ,max(isnull(duration,0)) max_dur		
	  ,sum(reruns + 1) Runs	
  FROM [jobrun_view]		
  where 
  productiondate between '<<from_date:20200101>>' and '<<to_date:20200101>>'
	and status > 10 	
	group by jobid ) r on m.jobmst_id = r.jobid	
order by r.avg_dur desc	
]]>
        </querytext_oracle>
    </query>    
<query>
        <queryname>JobrunSummaryByDay</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns summary for production date range</querydescription>
        <db>admiral</db> 
        <template_type></template_type>
        <chartfields>jobrun_status,ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver> 
            <![CDATA[
select m.jobmst_prntname Parent_Name, m.jobmst_name Job_Name,r.agent Agent,  r.avg_dur Average_Duration_Seconds, r.min_dur Minimum_Duration_Seconds, r.max_dur Maximum_Duration_Seconds, r.Runs Job_Runs, r.productiondate
from jobmst m		
inner join jobdtl d on m.jobdtl_id = d.jobdtl_id		
inner join (	SELECT [jobid]	,
		min(isnull(agentlistname, agentname)) agent
      ,avg(isnull(duration,0)) avg_dur		
      ,min(isnull(duration,0)) min_dur		
      ,max(isnull(duration,0)) max_dur	
	  ,sum(reruns + 1) Runs	,productiondate
  FROM [jobrun_view]		
  where 
  productiondate between '<<from_date:20200101>>' and '<<to_date:20200101>>'
	and status > 10 	
	group by jobid,productiondate) r on m.jobmst_id = r.jobid	
order by r.avg_dur desc	
]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select m.jobmst_prntname Parent_Name, m.jobmst_name Job_Name,r.agent Agent,  r.avg_dur Average_Duration_Seconds, r.min_dur Minimum_Duration_Seconds, r.max_dur Maximum_Duration_Seconds, r.Runs Job_Runs, r.productiondate
from jobmst m		
inner join jobdtl d on m.jobdtl_id = d.jobdtl_id		
inner join (	SELECT [jobid]	,
		min(isnull(agentlistname, agentname)) agent
      ,avg(isnull(duration,0)) avg_dur		
      ,min(isnull(duration,0)) min_dur		
      ,max(isnull(duration,0)) max_dur	
	  ,sum(reruns + 1) Runs	,productiondate
  FROM [jobrun_view]		
  where 
  productiondate between '<<from_date:20200101>>' and '<<to_date:20200101>>'
	and status > 10 	
	group by jobid,productiondate) r on m.jobmst_id = r.jobid	
order by r.productiondate, r.avg_dur desc	
]]>
        </querytext_oracle>
    </query>    

<query>
        <queryname>Job Size Metrics</queryname>
        <category>explorer</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>Job Output size for job runs</querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
<![CDATA[   
{% extends "AllJobRuns.sql" %}     
select jobmst_id, first(jobrun_id), first(JobName), first(JobGroup), sum(OutputSize) from 
{{AllJobRuns}}
group by jobmst_id
]]>
     </querytext_sqlserver>
        <querytext_oracle>
<![CDATA[        
select jobmst_id, first(jobrun_id), first(JobName), first(JobGroup), sum(OutputSize) from 
{{AllJobRuns}}
group by jobmst_id
]]>
     </querytext_oracle>
</query>


    <query> 
        <queryname>711HAllJobRunsOneDay</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns for one production day</querydescription>
        <db>reporting</db>
        <chartfields>jobrun_status,ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, 
jobrun.jobmst_id, 
coalesce(jobrun.jobmst_prntname,'') as JobGroup,
jobrun.jobmst_name as JobName,
JOBRUNSTATUS.statusname + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
jobrun_duration,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
   jobrun.owner_name,
  --JOBRUNSTATUS.statusname as jobrun_status,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job' 
    when jobrun.jobmst_type=6 then 'FTP'     
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar) end JobType,
    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    jobrun.nodmst_name,
    quemst_name,
    coalesce(jobrun.jobclass,'') jobclass,  
    jobdtl_cmd command, 
    coalesce(jobrun.jobrun_extinfo,'') ExtInfo,
    jobrun_successors
  FROM   jobrun with(nolock)
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          jobrun.jobmst_type > 1 and
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,'') like '<<job_group:%>>')
		  and (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status

]]>
        </querytext_sqlserver>

        <querytext_oracle>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as "JobGroup", jobrun.jobmst_name as "JobName",
  JOBRUNSTATUS.statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
 jobrun_esttime "EstStartTime", 
  jobrun_duration "Duration", 
 jobrun.jobrun_launchtm "StartTime", 
 COALESCE(jobrun_launchtm,jobrun_time,jobrun_esttime) + numToDSInterval( COALESCE(jobrun_duration, jobrun_estduration,0), 'second' ) "EndTime",
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
  case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,jobrun_duration,
   jobrun.owner_name,
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job'
    when jobrun.jobmst_type=6 then 'FTP'          
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar(2000)) end "JobType",
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    jobrun_outputlen OutputSize,
    jobrun.nodmst_name, quemst_name, 
    coalesce(jobrun.jobclass,'') jobclass,  
    cast(jobdtl_cmd as varchar(1000)) command,
    coalesce(cast(jobrun.jobrun_extinfo as varchar(4000)),'') "ExtInfo"
  FROM   jobrun
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          jobdata.version = 0 and
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,' ') like '<<job_group:%>>')
		  and (
		  (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
		  ) 
            or ((not '<<jobrun_id:0>>' = '0' ) ))
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
  order by "ProdDate", jobrun.jobrun_launchtm,  "EstStartTime", jobrun_status
]]>
        </querytext_oracle>
    </query>
<query>
        <queryname>712 Daily Schedule</queryname>
        <category>jobactivity</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
        select jobrun_id jobrun_id, JobGroup, Jobname, jobmst_id, EstStartTime, nodmst_name,ProdDate from 
{{711HAllJobRunsOneDay}}
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
        select jobrun_id, "JobGroup", "JobName", jobmst_id, "EstStartTime", nodmst_name,"ProdDate" from 
{{711HAllJobRunsOneDay}}
	  ]]>
        </querytext_oracle>
    </query>
    
    <query>
        <queryname>del-710AllJobRuns</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery>716 JobRun with Detailed Messages</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields>ProdDate,jobrun_duration</chartfields>
        <querytext_sqlserver>
            <![CDATA[
	SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup, jobmst.jobmst_name as JobName, owner_name, jobrun_esttime EstStartTime,  CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, jobrun.jobrun_launchtm StartTime,  jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,jobrun_duration,
  strmst_desc as jobrun_status,
    nodmst.nodmst_name, 
    quemst.quemst_name,  
    jobdtl_cmd command, 
    coalesce(jobrun.jobrun_extinfo,'') ExtInfo
  FROM   jobrun
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
          --jobmst.jobmst_type > 1
          (jobrun.jobrun_id = '<<jobrun_id:0>>' or <<jobrun_id:0>> = 0 )
          and (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (quemst.quemst_name like '<<queue:%>>' or jobrun.quemst_id is null)
          and (nodmst.nodmst_name like '<<agent:%>>' or jobrun.nodmst_id is null)          
	      --and (jobrun.jobrun_id = jobrunx.jobrun_id or jobrunx.jobrun_id is null)
          and (jobmst.jobmst_name like '<<job_name:%>>') and (coalesce(jobmst.jobmst_prntname,'') like '<<job_group:%>>')
		  and ((jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') 
            --or ((not '<<job_name:%>>' like '%') or (not '<<job_group:%>>' like '%' ))
            or ((not '<<jobrun_id:0>>' = '0' )  or (not '<<jobmst_id:0>>' = '0' ))
                )
          and (jobrun.jobrun_status like '<<jobrun_status>>' or '<<jobrun_status>>' = '0' )
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
		SELECT      coalesce(jobmst.jobmst_prntname,'') as JobGroup, jobmst.jobmst_name as JobName, owner_name, jobrun_esttime EstStartTime, jobrun_duration Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, jobrun_instance,jobrun_proddt as ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	case  when jobrun_status=101 then 'Completed Normally' when jobrun_status=103 then 'Completed Abnormally'  when jobrun_status=104 then 'Skipped' when jobrun_status=66 then 'Error' when jobrun_status=105 then 'Orphaned' when jobrun_status=53 then 'Deferred' when jobrun_status=106 then 'Aborted' when jobrun_status=107 then 'Externally Defined'   when jobrun_status=108 then 'TimedOut' when jobrun_status <= 50 then 'Waiting' when jobrun_status = 54 then '54' when jobrun_status=106 then 'Aborted'  when jobrun_status=109 then 'Cancelled' else cast(jobrun_status as varchar(20))  end as jobrun_status,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo
	FROM   jobrun
	inner join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	left outer join jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id
	left outer join evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	inner join owner on jobmst.jobmst_owner = owner.owner_id
	inner join nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	inner join quemst on jobrun.quemst_id = quemst.quemst_id
	inner join jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
        and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '<<job_group>><<%>>' or jobmst.jobmst_prntname is null)
   			and (jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd'))
        and case  when jobrun_status=101 then 'Completed Normally' when jobrun_status=103 then 'Completed Abnormally'  when jobrun_status=104 then 'Skipped' when jobrun_status=66 then 'Error' when jobrun_status=105 then 'Orphaned' when jobrun_status=53 then 'Deferred' when jobrun_status=106 then 'Aborted' when jobrun_status=107 then 'Externally Defined'   when jobrun_status=108 then 'TimedOut' when jobrun_status <= 50 then 'Waiting' when jobrun_status = 54 then '54' when jobrun_status=106 then 'Aborted'  when jobrun_status=109 then 'Cancelled' else cast(jobrun_status as varchar(20))  end like '<<jobrun_status>><<%>>'
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>713 SearchJoboutput</queryname>
        <category>jobactivity</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription>All Jobruns for production date range where joboutput matches</querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver> 
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
    jobrun_outputlen OutputSize,
    jobrun.jobrun_joboutput JobOutput
    ,'<<search_joboutput:%>>' FoundJobOutput
  FROM   jobrun with(nolock)
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          (jobrun.jobmst_id = '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = '0' )
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,'') like '<<job_group:%>>')
		      and (jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>')
          and (jobrun_joboutput like '<<search_joboutput:%>>' or '<<search_joboutput:%>>' = '%')
  order by jobrun.jobrun_id, jobrun.jobrun_launchtm

]]>
         </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, jobrun.jobmst_name as JobName,
  JOBRUNSTATUS.statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
    Case when jobrun.jobmst_type = 1 then 'JobGroup' 
    when jobrun.jobmst_type=2 then 'Job' 
    when jobrun.jobmst_type=6 then 'FTP' 
    when jobrun.jobmst_type=7 then 'AS400' 
    when jobrun.jobmst_type=8 then 'Adapter' 
    else cast(jobrun.jobmst_type as varchar(2000)) end JobType,
    jobrun_outputlen "OutputSize",
    jobrun.jobrun_joboutput JobOutput
  FROM   jobrun
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where
          (jobrun.jobmst_id = '<<jobmst_id:0>>' or <<jobmst_id:0>> = 0 )
          and (jobrun.jobmst_name like '<<job_name:%>>') and (coalesce(jobrun.jobmst_prntname,' ') like '<<job_group:%>>')
          and 
          (
                jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') or 
                jobrun_rundt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') 
          ) 
            
          and (jobrun_joboutput like '<<search_joboutput:%>>' or '<<search_joboutput:%>>' = '%')
  order by jobrun.jobrun_id, jobrun.jobrun_launchtm,  "EstStartTime"
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>old715 All JobRuns for current production day</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery>716 JobRun with Detailed Messages</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 select  jobrun_id, jobmst_id, JobName Job_Name, JobGroup Job_Group ,jobmst_type, StartTime, Duration, jobrun_status Jobrun_Status,  jobrun_cmd, nodmst_name,jobrun_deps, launch_time, queue_time, JobRun_Messages from (
	SELECT      coalesce(jobmst.jobmst_prntname,'') JobGroup, jobmst.jobmst_name JobName,  jobrun_esttime EstStartTime, datediff(minute, jobrun.jobrun_launchtm,current_timestamp) Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id, jobrun.jobmst_id jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
  jobrun_cmd, nodmst_name, strmst_desc jobrun_status, jobrun_deps, jobrun_launchtm launch_time, jobrun.jobrun_queuetm queue_time, jobrun_id Jobrun_Messages, '' job_dependencies
	FROM   jobrun, jobmst, nodmst, strmst
	where jobrun.jobmst_id = jobmst.jobmst_id
        and jobrun.nodmst_id = nodmst.nodmst_id
        and jobrun.jobrun_status = strmst_id and strmst_type = '7'
        and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '<<job_group>><<%>>' or jobmst.jobmst_prntname is null)
				and jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>'
        and strmst_desc like '<<job_status>><<%>>'
        and (jobrun.jobrun_id like '<<jobrun_id>><<%>>')
         and (jobrun.jobmst_id like '<<jobmst_id>><<%>>')
        ) intermediate_result
    order by Jobrun_Status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select JobName, JobGroup ,StartTime, Duration, jobrun_status Jobrun_Status,  jobrun_cmd, jobrun_id, jobmst_id, nodmst_name, EstStartTime  from (      
		SELECT      coalesce(jobmst.jobmst_prntname,'') as JobGroup, jobmst.jobmst_name as JobName, owner_name, jobrun_esttime EstStartTime, jobrun_duration Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo , strmst_desc jobrun_status
	FROM   jobrun
	    inner join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	    left outer join jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id  
	    left outer join evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	    inner join owner on jobmst.jobmst_owner = owner.owner_id
	    inner join nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	    inner join quemst on jobrun.quemst_id = quemst.quemst_id
      inner join strmst on strmst_id=jobrun_status and strmst_type = '7'
	    inner join jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
      and (jobmst.jobmst_name like '<<job_name>>') and (jobmst.jobmst_prntname like '<<job_group>>' or jobmst.jobmst_prntname is null)
			and (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd'))
      and strmst_desc like '<<job_status>>'
   ) intermediate_result
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, Jobrun_Status

]]>
        </querytext_oracle>
    </query>
       <query>
        <queryname>715AllJobRunsProductionDay</queryname>
        <category>admin</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id, 
 jobrun.jobmst_id jobmst_id, 
 coalesce(jobmst.jobmst_prntname,'') as JobGroup, 
 jobmst.jobmst_name as JobName, 
 --strmst_desc as jobrun_status,
 strmst_desc + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
 jobrun.jobmst_type, 
 owner_name, 
jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
jobrun_instance,
 datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    nodmst.nodmst_name, quemst.quemst_name,  jobdtl_cmd command, jobrun.jobrun_status sc,  '' job_dependencies
  FROM   jobrun with(nolock)
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
         (jobrun.jobrun_id like '<<jobrun_id>><<%>>')
          and (jobrun.jobmst_id like '<<jobmst_id>><<%>>')
          and (quemst.quemst_name like '<<queue>><<%>>' or jobrun.quemst_id is null)
          and (nodmst.nodmst_name like '<<agent>><<%>>' or jobrun.nodmst_id is null)          
          and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '<<job_group>><<%>>' or jobmst.jobmst_prntname is null)
          and (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or (not '<<jobrun_id>><<%>>' = '%%' ) or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>' and jobrun.jobrun_status < 50) or (not '<<jobrun_id>><<%>>' = '%%' )
           )
  order by ProdDate,
   jobrun_fullpath
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select JobName, 
    JobGroup ,
    StartTime, 
    Duration, 
    jobrun_status Jobrun_Status,  
    jobrun_cmd, 
    jobrun_id, 
    jobmst_id, 
    nodmst_name, 
    EstStartTime  from (      
		SELECT      coalesce(jobmst.jobmst_prntname,'') JobGroup, jobmst.jobmst_name JobName, owner_name, jobrun_esttime EstStartTime, jobrun_duration Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo ,
       --strmst_desc jobrun_status
       strmst_desc || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status
	FROM   tidal.jobrun
	    inner join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	    left outer join tidal.jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id  
	    left outer join tidal.evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	    inner join tidal.owner on jobmst.jobmst_owner = owner.owner_id
	    inner join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	    inner join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
      inner join tidal.strmst on strmst_id=jobrun_status and strmst_type = '7'
	    inner join tidal.jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
      and (jobmst.jobmst_name like '<<job_name>>') and (jobmst.jobmst_prntname like '<<job_group>>' or jobmst.jobmst_prntname is null)
			and (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd'))
      and strmst_desc like '<<job_status>>'
   ) intermediate_result
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, Jobrun_Status

]]>
        </querytext_oracle>
    </query> 
       <query>
        <queryname>715AllJobRunsProductionDayNG</queryname>
        <category>hidden</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup, 
 jobmst.jobmst_name as JobName, 
 --strmst_desc as jobrun_status,
 strmst_desc + case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,
 jobrun.jobmst_type,
  owner_name, 
jobrun_esttime EstStartTime,  
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
jobrun_instance,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    jobrun.jobrun_prntid,
    nodmst.nodmst_name, quemst.quemst_name,  jobdtl_cmd command, jobrun.jobrun_status sc,  '' job_dependencies
  FROM   jobrun with(nolock)
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
         (jobrun.jobrun_id like '<<jobrun_id>><<%>>')
          and (jobrun.jobmst_id like '<<jobmst_id>><<%>>')
          and (quemst.quemst_name like '<<queue>><<%>>' or jobrun.quemst_id is null)
          and (nodmst.nodmst_name like '<<agent>><<%>>' or jobrun.nodmst_id is null)          
          and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '<<job_group>><<%>>' or jobmst.jobmst_prntname is null)
          and (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or (not '<<jobrun_id>><<%>>' = '%%' ) or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>' and jobrun.jobrun_status < 50) or (not '<<jobrun_id>><<%>>' = '%%' )
           )
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select "JobName", "JobGroup" ,"StartTime", "Duration", jobrun_status "Jobrun_Status",  jobrun_cmd, jobrun_id, jobmst_id, nodmst_name, EstStartTime  from (      
		SELECT      coalesce(jobmst.jobmst_prntname,'') "JobGroup", 
        jobmst.jobmst_name JobName, owner_name, jobrun_esttime "EstStartTime",
         jobrun_duration Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  
         jobrun.jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) "ProdDate",
          case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo ,
       --strmst_desc jobrun_status
       strmst_desc || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status
	FROM   tidal.jobrun
	    inner join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	    left outer join tidal.jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id  
	    left outer join tidal.evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	    inner join tidal.owner on jobmst.jobmst_owner = owner.owner_id
	    inner join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	    inner join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
      inner join tidal.strmst on strmst_id=jobrun_status and strmst_type = '7'
	    inner join tidal.jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
      and (jobmst.jobmst_name like '<<job_name>>') and (jobmst.jobmst_prntname like '<<job_group>>' or jobmst.jobmst_prntname is null)
			and (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd'))
      and strmst_desc like '<<job_status>>'
   ) intermediate_result
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, Jobrun_Status

]]>
        </querytext_oracle>
    </query>

       <query>
        <queryname>del-715HAllJobRunsProductionDay</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery>716H JobRun with Detailed Messages</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobdata.JobName,'') as JobGroup, 
 jobdata.JobName as JobName, 
 concat(statusname, case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 jobrun.jobmst_type, jobrun.owner_name,
 
jobrun_esttime EstStartTime,  
jobrun.jobrun_launchtm StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
jobrun_instance,Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
jobrun_instance,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,

    len(coalesce(jobdata.JobGroup,'')) -  len(replace(coalesce(jobdata.JobName,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    jobrun.nodmst_name, jobrun.quemst_name,  jobdtl_cmd command, jobrun.jobrun_status sc,  '' job_dependencies
  FROM   jobrun with(nolock)
   join jobrunstatus on  jobrun.jobrun_status = jobrunstatus.statusid
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id 
   where
            (jobrun.jobrun_id like '<<jobrun_id>><<%>>')
          and (jobrun.jobmst_id like '<<jobmst_id>><<%>>')
          and (jobrun.quemst_name like '<<queue>><<%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent>><<%>>' or jobrun.nodmst_id is null)          
          and (jobdata.JobName like '<<job_name>><<%>>') and (jobdata.JobGroup like '<<job_group>><<%>>' or jobdata.JobName is null)
          and (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or (not '<<jobrun_id>><<%>>' = '%%' ) or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>' and jobrun.jobrun_status < 50) or (not '<<jobrun_id>><<%>>' = '%%' )
           )
            and jobrun.jobrun_status like '<<jobrun_status>>'
            and jobdata.version = 0
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup, 
 jobmst.jobmst_name as JobName, 
 concat(strmst_desc, case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 jobrun.jobmst_type, owner_name, jobrun_esttime EstStartTime,
   CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration,
   CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
   jobrun.jobrun_launchtm StartTime,  jobrun_instance,
   Convert(varchar(10), jobrun_proddt,120)  as "ProdDate", case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    len(coalesce(jobrun.JobGroup,'')) -  len(replace(coalesce(jobrun.JobName,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    jobrun.nodmst_name, jobrun.quemst_name,  jobdtl_cmd command, jobrun.jobrun_status sc,  '' job_dependencies
  FROM   jobrun with(nolock)
   join jobrunstatus on  jobrun.jobrun_status = jobrunstatus.status_id

   where
         (jobrun.jobrun_id like '<<jobrun_id>><<%>>')
          and (jobrun.jobmst_id like '<<jobmst_id>><<%>>')
          and (jobrun.quemst_name like '<<queue>><<%>>' or jobrun.quemst_id is null)
          and (jobrun.nodmst_name like '<<agent>><<%>>' or jobrun.nodmst_id is null)          
          and (jobdata.jobmst_name like '<<job_name>><<%>>') and (jobdata.JobGroup like '<<job_group>><<%>>' or jobdata.JobName is null)
          and (
          (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd')) or (not '<<jobrun_id>><<%>>' = '%%' ) or 
          (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') and jobrun.jobrun_status < 50) or (not '<<jobrun_id>><<%>>' = '%%' )
           )
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status

]]>
        </querytext_oracle>
    </query>
       <query>
        <queryname>715JobActivity</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery>
        <querydescription>715JobActivity</querydescription> 
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id, 
 jobrun.jobrun_instance instance, 
 jobrun.jobmst_id jobmst_id, 
 --coalesce(jobmst.jobmst_prntname,'') as [Group],
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end as [Group],
jobmst.jobmst_name as JobName,
 rtrim(strmst_desc +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'Group' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
 owner_name Owner,
 jobmst.jobmst_runbook,
--dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime,
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
--CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
--CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
--jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
Convert(varchar(10), jobrun_rundt,120)  as RunDate, 
--jobrun_instance,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
--    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
case when not  jobrun.jobrun_prntid is null then len(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end) -
        len(replace(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end,'\','')) - 1 else 0 end [$$treeLevel],
case when not  jobrun.jobrun_prntid is null then len(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end) -
        len(replace(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end,'\','')) - 1 else 0 end lvl,
case when 	jobrun.jobmst_type = 1 then 
    case  when jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name + '\'
        else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name +'\' end
else
    coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end as [Group],

--  jobrun.jobrun_prntid,
    nodmst.nodmst_name,
--    quemst.quemst_name,  
--    coalesce(jobcls.jobcls_name,'') JobClass,
--    jobdtl_cmd command, 
-- jobrun.jobrun_status sc,  
-- '' job_dependencies,
--    DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
--    jobrun_lstchgtm,
    '<<master>>' master
  FROM   jobrun with(nolock)
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   left join jobcls on jobmst.jobcls_id = jobcls.jobcls_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where         
          (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
          )
         and jobrun_dirty is null
         --and jobrun.jobmst_type > 1
  order by ProdDate desc,
    case when jobrun.jobmst_type = 1 then jobrun_fullPath else reverse(concat(reverse(jobmst.jobmst_name), '\', substring(reverse(jobrun_fullPath),charindex('\',reverse(jobrun_fullPath)),9999))) end

--  instance, 
--[Group]
--case when jobrun.jobmst_type = 1 then jobrun_fullPath else reverse(concat(reverse(jobmst.jobmst_name), '\', substring(reverse(jobrun_fullPath),charindex('\',reverse(jobrun_fullPath)),9999))) end
--replace(replace(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end,' ','_'),'\','!'), 
--Jobname

--jobrun.jobrun_launchtm,  
--EstStartTime, 
--jobrun_status

        
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  jobrun.jobrun_id "jobrun_id", jobrun.jobmst_id "jobmst_id",
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' || jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') || '\' || jobmst.jobmst_name end as "JobGroup",
 coalesce(jobmst.jobmst_prntname,'') as "JobGroup", 
 jobmst.jobmst_name as "JobName", 
 jobrun_instance,
 rtrim(strmst_desc || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
 owner_name "Owner", 
 jobrun_esttime "EstStartTime",  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') "Duration", 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  "EstDuration", 
 jobrun.jobrun_launchtm "StartTime",
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
    case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as "jobruns",
    jobrun_rundt - jobrun_proddt "carryover_days",
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  "Successors",
    coalesce(length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')),0) "$$treeLevel",
    jobrun.jobrun_prntid,
    nodmst.nodmst_name, quemst.quemst_name,  jobrun_cmd command, jobrun.jobrun_status sc,  
    '' job_dependencies,
    jobrun_lstchgtm,
    '<<master>>' master
  FROM   tidal.jobrun
   left join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
   join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id and not jobmst_dirty = 'X'
   join tidal.strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join tidal.owner on  jobmst.jobmst_owner = owner.owner_id
   left join tidal.nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   --join tidal.jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where         
          (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
          )
          and jobrun_dirty is null
  order by "ProdDate", jobrun_fullpath, jobrun.jobrun_launchtm,  "EstStartTime", jobrun_status
]]>
        </querytext_oracle>
    </query>

       <query>
        <queryname>715JobActivityNG</queryname>
        <category>hidden</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription></querydescription> 
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id,jobrun.jobrun_instance instance, jobrun.jobmst_id jobmst_id, 
 coalesce(jobmst_prntname,'') as [Group], 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end as [Group],
 jobmst_name as JobName,  
 rtrim(strmst_desc +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'Group' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
  owner_name Owner,
dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime,
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
jobrun_instance,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    jobrun.jobrun_prntid,
    nodmst.nodmst_name, 
    quemst.quemst_name,  
    coalesce(jobcls.jobcls_name,'') JobClass,
    jobdtl_cmd command, jobrun.jobrun_status sc,
    '' job_dependencies,
    DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
    jobrun_lstchgtm,
    '<<master>>' master
  FROM   jobrun with(nolock)
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id  and not jobmst_dirty = 'X'
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   left join jobcls on jobmst.jobcls_id = jobcls.jobcls_id   
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where         
          (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
          )
          and jobrun_dirty is null
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  jobrun.jobrun_id "jobrun_id", 
 jobrun.jobmst_id "jobmst_id", 
 coalesce(jobmst.jobmst_prntname,'') as "JobGroup", 
 jobmst.jobmst_name as "JobName",
 owner_name "Owner",
 jobrun_instance "jobrun_instance",
 trim(strmst_desc || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) "jobrun_status",
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end "job_type",
 jobrun_esttime "EstStartTime",  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') "Duration", 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  "EstDuration", 
 jobrun.jobrun_launchtm "StartTime",
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
    case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as "jobruns",
    jobrun_rundt - jobrun_proddt "carryover_days",
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  "Successors",
    jobrun.jobrun_prntid "jobrun_prntid",
    nodmst.nodmst_name "nodmst_name", 
    quemst.quemst_name "quemst_name",  
    jobrun_cmd "command", 
    '' "job_dependencies",
    jobrun_lstchgtm "jobrun_lstchgtm" ,
    '<<master>>' "master"
  FROM   tidal.jobrun
   left join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
   join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id 
   join tidal.strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join tidal.owner on  jobmst.jobmst_owner = owner.owner_id
   left join tidal.nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   --join tidal.jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where         
          (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
          )
          and jobrun_dirty is null
order by "ProdDate", jobrun_fullpath, "StartTime",  "EstStartTime", "jobrun_status"
]]>
        </querytext_oracle>
    </query> 
       <query>
        <queryname>715HJobActivity</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  
 jobrun.jobrun_id jobrun_id,
 jobrun.jobrun_instance instance,
 jobrun.jobmst_id jobmst_id, 
 --coalesce(jobrun.jobmst_prntname,'') as [Group], 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') + '\' + jobrun.jobmst_name end as [Group],
 jobrun.jobmst_name as JobName, 
 rtrim(statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'Group' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
 JOBRUN.owner_name as Owner,

--dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime, 
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
--CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
Convert(varchar(10), jobrun_rundt,120)  as RunDate, 
coalesce(jobrun.jobclass,'') JobClass,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
--len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
len(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end) -
        len(replace(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end,'\','')) - 1 [$$treeLevel],
len(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end) -
        len(replace(case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobmst.jobmst_name else coalesce(jobmst.jobmst_prntname,'') + '\' + jobmst.jobmst_name end,'\','')) - 1 lvl,
--jobrun.jobrun_prntid,
nodmst_name,
quemst_name,  
--cast(jobrun_cmd as varchar(1000))  command,
--    jobrun.jobrun_status sc,
--    '' job_dependencies,
--    DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
    '<<master>>' master
  FROM   jobrun  with(nolock)
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
         (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
          )
		  --and JOBDATA.version = 0 
  order by 
  ProdDate, 
  case when jobrun.jobmst_type = 1 then jobrun_fullPath else reverse(concat(reverse(jobmst.jobmst_name), '\', substring(reverse(jobrun_fullPath),charindex('\',reverse(jobrun_fullPath)),9999))) end
  
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  jobrun.jobrun_id "jobrun_id",jobrun.jobrun_instance "instance", jobrun.jobmst_id "jobmst_id", 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' || jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') || '\' || jobrun.jobmst_name end as "JobGroup",
 --coalesce(jobmst_prntname,'') as "JobGroup", 
 jobmst_name as "JobName", 
 jobrun_instance "jobrun_instance",
 trim(statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end ) jobrun_status,
  Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type, 
 jobrun.owner_name "Owner",
 jobrun_esttime "EstStartTime",  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') Duration, 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  EstDuration, 
 jobrun.jobrun_launchtm StartTime,
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
   case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    jobrun_rundt - jobrun_proddt carryover_days,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    coalesce(length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')),0) "$$treeLevel",
    jobrun.jobrun_prntid,
    jobrun.nodmst_name,
    jobrun.quemst_name,  
    jobrun.jobrun_cmd command,
    coalesce(jobrun.jobclass,'') "JobClass",
    jobrun.jobrun_status sc,  
    '' job_dependencies, '<<master>>' master
  FROM   jobrun
   --left join quemst on jobrun.quemst_id = quemst.quemst_id
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id  and jobdata.version = 0
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
          (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
          )
  order by 
  "ProdDate" desc, 
  case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' || jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') || '\' || jobrun.jobmst_name end,
  JobName
  
]]>
        </querytext_oracle>
        <querytext_sqlite3>
<![CDATA[
        SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobdata.JobGroup,'') as JobGroup, 
 jobdata.JobName as JobName,  jobrun_instance,
 statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,jobrun.jobmst_type, 
 JOBRUN.owner_name, jobrun_esttime EstStartTime,  
 jobrun_duration Duration, jobrun_estduration EstDuration, jobrun.jobrun_launchtm StartTime,
 jobrun_proddt ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    JulianDay(jobrun_proddt) - JulianDay(jobrun_rundt) carryover_days,
    length(coalesce(jobrun_successors,'|')) - length(replace(coalesce(jobrun_successors,'|'), '|', '')) - 1  Successors,
    length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    nodmst_name,
    quemst_name,  
    jobdtl_cmd command,
    coalesce(jobrun.jobclass,'') jobclass,
    jobrun.jobrun_status sc,
    '' job_dependencies,
    length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')) lvl
  FROM   jobrun
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
         (
          (date(jobrun_proddt) >= '<<prod_date>>'  and date(jobrun_proddt) <= '<<prod_date>>') or 
          (date(jobrun_rundt) >= '<<prod_date>>'  and date(jobrun_rundt) <= '<<prod_date>>')
          )
		  and JOBDATA.version = 0
          
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlite3>
    </query>
       <query>
        <queryname>715HJobactivityNG</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription>Job activity not grouped by parent </querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT  jobrun.jobrun_id jobrun_id, 
jobrun.jobrun_instance instance, 
jobrun.jobmst_id jobmst_id, 
coalesce(jobrun.jobmst_prntname,'') as [Group], 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') + '\' + jobrun.jobmst_name end as [Group],
case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') + '\' + jobrun.jobmst_name end as JobGroup,
 coalesce(jobrun.jobmst_prntname,'') + '\' + jobrun.jobmst_name as JobGroup,
 --jobrun.jobmst_name as JobName,  jobrun_instance,
rtrim(statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type, 
JOBRUN.owner_name as Owner,
--dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime, 
--convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
--CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
--jobrun_duration,
coalesce(jobrun.jobclass,'') JobClass,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
--CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
--jobrun_successors,
--    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    --jobrun.jobrun_prntid,
    nodmst_name, 
    quemst_name,  
    --jobrun_cmd command, 
    --jobrun.jobrun_status sc,  
    --'' job_dependencies,
    len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) lvl,
--DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
    '<<master>>' master
  FROM   jobrun  with(nolock)
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
         (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
          )
		  --and jobrun.jobmst_type > 0
  order by ProdDate, 
  jobrun_fullpath
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT  jobrun.jobrun_id "jobrun_id",jobrun.jobrun_instance "instance", jobrun.jobmst_id "jobmst_id",
 coalesce(jobrun.jobmst_prntname,'') as JobGroup, 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' || jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') || '\' || jobrun.jobmst_name end as "JobGroup",
 jobrun.jobmst_name as "JobName",  jobrun_instance,
 rtrim(statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end ) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,  
 jobrun.owner_name "Owner", jobrun_esttime "EstStartTime",  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') Duration, 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  "EstDuration", 
 jobrun.jobrun_launchtm StartTime,
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    jobrun_rundt - jobrun_proddt carryover_days,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    jobrun.jobrun_prntid,
    jobrun.nodmst_name,
    jobrun.quemst_name,  
    jobrun.jobrun_cmd command, 
    coalesce(jobrun.jobclass,'') as "JobClass",
    jobrun.jobrun_status sc,  
    '' job_dependencies,
    '<<master>>' master
  FROM   jobrun
   --left join quemst on jobrun.quemst_id = quemst.quemst_id
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id  and jobdata.version = 0
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where 
          (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
          )
  order by "ProdDate", cast(jobrun_fullpath as varchar(4000)), jobrun.jobrun_launchtm,  "EstStartTime", jobrunstatus.statusname

]]>
        </querytext_oracle>
    </query>
       <query>
        <queryname>715QB JobRunInformation</queryname>
        <category>hidden</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
 SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobmst.jobmst_prntname,'') as JobGroup, 
 jobmst.jobmst_name as JobName, 
 strmst_desc as jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,  
 owner_name "Owner",
 dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime,
   CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration,
   CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
   jobrun.jobrun_launchtm StartTime,  jobrun_instance,
   Convert(varchar(10), jobrun_proddt,120)  as ProdDate,
    case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    nodmst.nodmst_name, quemst.quemst_name,  jobdtl_cmd command, jobrun.jobrun_status,  '' job_dependencies
  FROM   jobrun
   left join quemst on jobrun.quemst_id = quemst.quemst_id
   join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   join strmst on  jobrun.jobrun_status = strmst_id and strmst_type = '7'
   join owner on  jobmst.jobmst_owner = owner.owner_id
   left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
   join jobdtl on  jobmst.jobdtl_id = jobdtl.jobdtl_id
   where
    <<qbwhere_string>>
    and jobrun_dirty is null
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select JobName, JobGroup ,StartTime, Duration, jobrun_status Jobrun_Status,  jobrun_cmd, jobrun_id, jobmst_id, nodmst_name, EstStartTime  from (      
		SELECT      coalesce(jobmst.jobmst_prntname,'') JobGroup, jobmst.jobmst_name JobName, owner_name "Owner", jobrun_esttime EstStartTime, jobrun_duration Duration,
         jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id, jobrun.jobmst_id, jobrun_instance,
         to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
          case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo , strmst_desc jobrun_status
	FROM   tidal.jobrun
	    inner join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	    left outer join tidal.jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id  
	    left outer join tidal.evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	    inner join tidal.owner on jobmst.jobmst_owner = owner.owner_id
	    inner join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	    inner join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
      inner join tidal.strmst on strmst_id=jobrun_status and strmst_type = '7'
	    inner join tidal.jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
        where
        <<qbwhere_string>>
      and jobrun_dirty is null
  order by "ProdDate", jobrun.jobrun_launchtm,  EstStartTime, Jobrun_Status

]]>
        </querytext_oracle>
    </query>




    <query>
        <queryname>716 JobRun with Detailed Messages</queryname>
        <category>hidden</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  
  jobmst.jobmst_name JobName, jobmst.jobmst_prntname JobGroup,
  msglog.msglog_text msglog_text,coalesce(usrmst_name,' ') [UserName],
  msglog.msglog_crtdt,Convert(varchar(10), jobrun_proddt,120)  as ProdDate,
  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id 
FROM         jobrun INNER JOIN
                         msglog ON jobrun.jobrun_id = msglog.jobrun_id 
                    INNER JOIN
                         jobmst ON jobrun.jobmst_id = jobmst.jobmst_id
                    INNER JOIN 
                        strmst on jobrun.jobrun_status = strmst_id 
					          left join 
					              usrmst on msglog.usrmst_id = usrmst.usrmst_id
where 
(jobrun.jobrun_id like '<<jobrun_id>>')                       
and 
strmst_type = 7

ORDER BY jobrun.jobrun_id, msglog.msglog_id asc

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  
  jobmst.jobmst_name "JobName", jobmst.jobmst_prntname "JobGroup",
  msglog.msglog_text msglog_text,
  msglog.msglog_crtdt,
  to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id 
FROM         tidal.jobrun INNER JOIN
                         tidal.msglog ON jobrun.jobrun_id = msglog.jobrun_id 
                    INNER JOIN
                         jobmst ON jobrun.jobmst_id = jobmst.jobmst_id
                    INNER JOIN 
                        strmst on jobrun.jobrun_status = strmst_id 
where 
(jobrun.jobrun_id like '<<jobrun_id>>')                       
and 
strmst_type = 7

ORDER BY jobrun.jobrun_id, msglog.msglog_id desc

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>716H JobRun with Detailed Messages</queryname>
        <category>hidden</category>
        <querytotals></querytotals>
        <linkquery>710HAllJobRuns</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  
  jobrun.jobmst_name JobName, jobrun.jobmst_prntname JobGroup,
  msglog.msglog_text msglog_text,usrmst_name,
  msglog.msglog_crtdt,Convert(varchar(10), jobrun_proddt,120)  as ProdDate,
  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, msglog_id
  FROM         jobrun INNER JOIN
                         msglog ON jobrun.jobrun_id = msglog.jobrun_id 

                    INNER JOIN 
                        JOBRUNSTATUS on jobrun.jobrun_status = JOBRUNSTATUS.statusid 
where 
(jobrun.jobrun_id = '<<jobrun_id>>')    
and msglog_text like '<<msglog_text:%>>'                   
ORDER BY jobrun.jobrun_id, msglog.msglog_id desc

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  
  jobrun.jobmst_name "JobName", jobrun.jobmst_prntname "JobGroup",
  msglog.msglog_text msglog_text,usrmst_name,
  msglog.msglog_crtdt,to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, msglog_id
  FROM         jobrun INNER JOIN
                         msglog ON jobrun.jobrun_id = msglog.jobrun_id 

                    INNER JOIN 
                        JOBRUNSTATUS on jobrun.jobrun_status = JOBRUNSTATUS.statusid 
where 
(jobrun.jobrun_id = '<<jobrun_id>>')    
and msglog_text like '<<msglog_text:%>>'                   
ORDER BY jobrun.jobrun_id, msglog.msglog_id desc

]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>717 JobRuns for selected Jobs current production day</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 select JobName, JobGroup ,StartTime, Duration, jobrun_status Jobrun_Status,  jobrun_cmd, jobrun_id, jobmst_id, nodmst_name,jobrun_deps, launch_time, queue_time from (
	SELECT      coalesce(jobmst.jobmst_prntname,'') JobGroup, jobmst.jobmst_name JobName,  jobrun_esttime EstStartTime, datediff(minute, jobrun.jobrun_launchtm,current_timestamp) Duration, jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations ,  jobrun.jobrun_id, jobrun.jobmst_id jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
  jobrun_cmd, nodmst_name, strmst_desc jobrun_status, jobrun_deps, jobrun_launchtm launch_time, jobrun.jobrun_queuetm queue_time
	FROM   jobrun, jobmst, nodmst, strmst
	where jobrun.jobmst_id = jobmst.jobmst_id
        and jobrun.nodmst_id = nodmst.nodmst_id
        and jobrun.jobmst_id in(63494,22562)
        and jobrun.jobrun_status = strmst_id and strmst_type = '7'
        and (jobmst.jobmst_name like '<<job_name>><<%>>') and (jobmst.jobmst_prntname like '<<job_group>><<%>>' or jobmst.jobmst_prntname is null)
				and jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>'
        and strmst_desc like '<<job_status>><<%>>'
        ) intermediate_result
    order by Jobrun_Status
]]>
        </querytext_sqlserver> 
        <querytext_oracle>
            <![CDATA[
select "JobName", "JobGroup" ,"StartTime", "Duration", jobrun_status "Jobrun_Status",  "jobrun_cmd", "jobrun_id", "jobmst_id", "nodmst_name", "EstStartTime"  from (      
		SELECT      jobmst.jobmst_prntname as JobGroup, jobmst.jobmst_name as JobName, owner_name "Owner", jobrun_esttime EstStartTime, jobrun_duration Duration, 
        jobrun.jobrun_launchtm StartTime, jobrun_reruns + 1 Iterations , 
        jobrun.jobrun_id, jobrun.jobmst_id, jobrun_instance,
        to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
        case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	  nodmst.nodmst_name, quemst.quemst_name, evntmst.evntmst_name, jobdtl_cmd command, nvl(jobrunx.jobrun_extinfo,'') ExtInfo , strmst_desc jobrun_status
	FROM   tidal.jobrun
	    inner join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
	    left outer join tidal.jobrunx on  jobrun.jobrun_id = jobrunx.jobrun_id  
	    left outer join tidal.evntmst on jobmst.evntmst_id = evntmst.evntmst_id
	    inner join tidal.owner on jobmst.jobmst_owner = owner.owner_id
	    inner join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
	    inner join tidal.quemst on jobrun.quemst_id = quemst.quemst_id
        inner join tidal.strmst on strmst_id=jobrun_status and strmst_type = '7'
	    inner join tidal.jobdtl on jobmst.jobdtl_id = jobdtl.jobdtl_id
      and (jobmst.jobmst_name like '<<job_name>>') and (jobmst.jobmst_prntname like '<<job_group>>' or jobmst.jobmst_prntname is null)
			and (jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd'))
      and strmst_desc like '<<job_status>>'
   ) intermediate_result
  order by ProdDate, jobrun.jobrun_launchtm,  EstStartTime, Jobrun_Status

]]>
        </querytext_oracle>
    </query>
    <query> 
        <queryname>718 JobRun Summary</queryname>
        <category>analysis</category>
        <querytotals></querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>CurrentStatus,ProdDate,Cnt</chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT       JOBDATA.jobname, jobrun_id, ReRun, Type, Active, CompletedNormally, CompletedAbnormally, Completed, 
Launched, Aborted, WaitingonResource, Skipped, TimedOut, Final, FinalStatus, ErrorOccured, CurrentStatus, 
jobdata.jobmst_id, 
ProdDt ProdDate, CarryOver, Owner, Queue, jobdata.Agent, 
CONVERT(varchar,(Active - Launched), 108) LauchStatusTime,
CONVERT(varchar,(CompletedNormally - Active), 108) Runtime,
DATEDIFF(SECOND,Active,CompletedNormally) RunSeconds,
1 Cnt
FROM            JOBRUN_STATUS_SUMMARY, jobdata
where 
jobdata.jobmst_id = JOBRUN_STATUS_SUMMARY.jobmst_id
and jobdata.version  = 0
and (jobrun_id like '<<jobrun_id:0>>' or '0' like '<<jobrun_id:0>>')  
and jobname like '<<job_name:%>><<%>>'
and (JOBRUN_STATUS_SUMMARY.jobmst_id like '<<jobmst_id:0>>' or '0' like '<<jobmst_id:0>>')
and proddt between '<<from_date:%>>' and '<<to_date:%>> 23:59:59'
--and  not Launched is null
order by jobmst_id

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT       JOBDATA.jobname, jobrun_id, ReRun, Type, Active, CompletedNormally, CompletedAbnormally, Completed, 
Launched, Aborted, WaitingonResource, Skipped, TimedOut, Final, FinalStatus, ErrorOccured, CurrentStatus, 
jobdata.jobmst_id, 
ProdDt ProdDate, CarryOver, Owner, Queue, jobdata.Agent, 
(Active - Launched) * 1440 * 60 "LaunchStatusTime",
(CompletedNormally - Active) * 1440 * 60 "RunTime",
1 Cnt
FROM            JOBRUN_STATUS_SUMMARY, jobdata
where 
jobdata.jobmst_id = JOBRUN_STATUS_SUMMARY.jobmst_id
and jobdata.version  = 0
and (jobrun_id = '<<jobrun_id:0>>' or '<<jobrun_id:0>>' = 0 )
and jobname like '<<job_name:%>>'
and (JOBRUN_STATUS_SUMMARY.jobmst_id like '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = 0)
and proddt between  to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
order by jobmst_id
]]>
        </querytext_oracle>
    </query>
    <query> 
      <queryname>718 JobRun Summary By JobGroup</queryname>
      <category>analysis</category>
      <querytotals></querytotals>
      <linkquery></linkquery><querydescription></querydescription>
      <db>reporting</db>
      <chartfields>CurrentStatus,ProdDate,Cnt</chartfields>
      <import_oracle>y</import_oracle>
      <querytext_sqlserver>
          <![CDATA[
SELECT       JOBDATA.jobgroup,JOBDATA.jobname, jobrun_id, ReRun, Type, Active, CompletedNormally, CompletedAbnormally, Completed, 
Launched, Aborted, WaitingonResource, Skipped, TimedOut, Final, FinalStatus, ErrorOccured, CurrentStatus, 
jobdata.jobmst_id, 
ProdDt ProdDate, CarryOver, Owner, Queue, jobdata.Agent, 
CONVERT(varchar,(Active - Launched), 108) LauchStatusTime,
CONVERT(varchar,(CompletedNormally - Active), 108) Runtime,
DATEDIFF(SECOND,Active,CompletedNormally) RunSeconds,
1 Cnt
FROM            JOBRUN_STATUS_SUMMARY, jobdata
where 
jobdata.jobmst_id = JOBRUN_STATUS_SUMMARY.jobmst_id
and jobdata.version  = 0
and (jobrun_id like '<<jobrun_id:0>>' or '0' like '<<jobrun_id:0>>')  
and jobgroup like '<<jobgroup:%>><<%>>'
and (JOBRUN_STATUS_SUMMARY.jobmst_id like '<<jobmst_id:0>>' or '0' like '<<jobmst_id:0>>')
and proddt between '<<from_date:%>>' and '<<to_date:%>> 23:59:59'
--and  not Launched is null
order by jobmst_id

]]>
      </querytext_sqlserver>
      <querytext_oracle>
          <![CDATA[
SELECT       JOBDATA.jobname, jobrun_id, ReRun, Type, Active, CompletedNormally, CompletedAbnormally, Completed, 
Launched, Aborted, WaitingonResource, Skipped, TimedOut, Final, FinalStatus, ErrorOccured, CurrentStatus, 
jobdata.jobmst_id, 
ProdDt ProdDate, CarryOver, Owner, Queue, jobdata.Agent, 
(Active - Launched) * 1440 * 60 "LaunchStatusTime",
(CompletedNormally - Active) * 1440 * 60 "RunTime",
1 Cnt
FROM            JOBRUN_STATUS_SUMMARY, jobdata
where 
jobdata.jobmst_id = JOBRUN_STATUS_SUMMARY.jobmst_id
and jobdata.version  = 0
and (jobrun_id = '<<jobrun_id:0>>' or '<<jobrun_id:0>>' = 0 )
and jobname like '<<job_name:%>>'
and (JOBRUN_STATUS_SUMMARY.jobmst_id like '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = 0)
and proddt between  to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
order by jobmst_id
]]>
      </querytext_oracle>
  </query>
  <query>
        <queryname>719 Jobrun status count last 30 days</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
          
select CalendarDate, STATUS_FL Status, Count(*) 'Count' from (
SELECT    msglog.jobrun_id JOB_RUN_ID,
      case
           when msgmst_id between 1204 and 1217 then 'OperatorAction'
           when msglog.msglog_text like 'Job%Completed Abnor%' then 'Completed Abnormally'
           when msglog_text like '%Error Occurred%' then 'Error Occured'
           when msglog_text like 'Job%status change to Aborted%' then 'Aborted'
           when msglog_text like 'Job%status change to Skipped%' then 'Skipped'
		   when msglog.msglog_text like 'Job%Completed Nor%' then 'Completed Normally'
      else 'Error'
      end STATUS_FL,
	  convert(varchar, msglog_crtdt, 23) CalendarDate	,
 
      msglog_crtdt FAIL_TM,
 'N' RESOLVED_STATUS_FL
FROM            msglog 
  
where ((msglog_text like 'Job%Completed Nor%') or (msglog_text like 'Job%Completed Abnor%') or (msglog_text like '%Error Occurred%') or (msglog_text like 'Job%status change to Aborted%') or(msgmst_id between 1204 and 1217) or (msglog_text like 'Job%status change to Skipped%')) 
and msglog_crtdt >  DateADD(day, -30, Current_TimeStamp) 
) as res
group by CalendarDate , STATUS_FL
order by CalendarDate, Count desc
        ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>720H Job fail percentage</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery>710HAllJobRuns</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
 select jobdata.JobName, jobdata.JobGroup, sumrun.jobmst_id , sumrun.totrun, sumrun.errrun, case sumrun.errrun when 0 then 0 else  (sumrun.errrun * 100) / sumrun.totrun   end  pct 
  from (
	select jobmst_id, count(jobmst_id) totrun, sum(case jobrun.jobrun_status when 103  then 1 else 0 end)  errrun from jobrun where 
		jobrun.jobmst_type > 1
		and jobrun.jobrun_proddt >= '<<from_date>>'  and jobrun.jobrun_proddt <= '<<to_date>>'
	group by jobmst_id) sumrun,
jobdata where jobdata.jobmst_id=sumrun.jobmst_id and jobdata.version = 0 and  case sumrun.errrun when 0 then 0 else  (sumrun.errrun * 100) / sumrun.totrun   end  > 0
order by pct desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 select jobdata.JobName, jobdata.JobGroup, sumrun.jobmst_id , sumrun.totrun, sumrun.errrun, case sumrun.errrun when 0 then 0 else  (sumrun.errrun * 100) / sumrun.totrun   end  pct 
  from (
	select jobmst_id, count(jobmst_id) totrun, sum(case jobrun.jobrun_status when 103  then 1 else 0 end)  errrun from jobrun where 
		jobrun.jobmst_type > 1
        and jobrun.jobrun_proddt between to_date ('<<from_date>>', 'yyyy-mm-dd') and to_date ('<<to_date>>', 'yyyy-mm-dd')
	group by jobmst_id) sumrun,
jobdata where jobdata.jobmst_id=sumrun.jobmst_id and jobdata.version = 0 and  case sumrun.errrun when 0 then 0 else  (sumrun.errrun * 100) / sumrun.totrun   end  > 0
order by pct desc
]]>
        </querytext_oracle>
    </query>

        <query>
        <queryname>del-721 JobRuns for selected Jobs current production day</queryname>
        <querytotals></querytotals>
        <category>hidden</category>
        <linkquery>716 JobRun with Detailed Messages</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
    SELECT jobrun_id, jobmst.jobmst_name, jobmst.jobmst_prntname, jobrun.jobrun_stachgtm StatusChangedTime  FROM jobrun, jobmst
WHERE 
 jobrun.jobmst_id = jobmst.jobmst_id 
 --and jobrun_status = 50
 and jobrun.jobmst_id in(<<jobrun_ids:0,0>>)
 AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
 AND jobrun_lstchgtm < (Select DATEADD(mi,-8,getdate()))
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select jobmst.jobmst_name, jobmst.jobmst_prntname, sumrun.jobmst_id , sumrun.totrun, sumrun.errrun,
case sumrun.errrun when 0 then 0 else  (sumrun.errrun * 100) / sumrun.totrun   end  pct 
from ( select jobmst_id, count(jobmst_id) totrun, sum(case jobrun.jobrun_status
when 103  then 1 else 0 end)  errrun from jobrun
where jobrun.jobmst_type > 1
and jobrun.jobrun_proddt between to_date ('<<from_date>>', 'yyyy-mm-dd') and to_date ('<<to_date_yyyy/mm/dd>>', 'yyyy-mm-dd')
 group by jobmst_id) sumrun, jobmst
where jobmst.jobmst_id=sumrun.jobmst_id
order by pct desc
]]>
        </querytext_oracle>
    </query>
        <query>  
        <queryname>722 JobRuns carried over maximum time</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select 
	jobgroup,
	jobname, 
	statusname jobrun_status,
	jobrun_cmd,
	carryover_days,
	jobrun_reruns,
    jobrun_id, jobrun_proddt,
	jobrun_rundt 
from (
select datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,  JOBDATA.jobname, jobdata.jobgroup, jobrun_id, jobrun_proddt, jobrun_rundt, jobrun_status,jobrun_cmd,jobrun_reruns, statusname 
	from jobrun with(nolock), jobdata with(nolock), jobrunstatus with(nolock) 
	where 
	cast(jobrun_proddt as date ) < cast(jobrun_rundt as date ) 
	and DATEDIFF(day,getdate(), jobrun_rundt) = -<<daysback:1>>
and jobrun.jobmst_id = jobdata.jobmst_id 
and jobrun.jobrun_status = statusid and jobrun.jobmst_type > 1 
and jobrun_status < 100
and jobdata.version = 0
) q1 
order by q1.jobrun_proddt desc, jobgroup, JobName, q1.carryover_days
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobmst_prntname,
  jobmst_name,
  statusname jobrun_status,
  jobrun_cmd,
  carryover_days,
  jobrun_reruns,
  jobrun_id,
  jobrun_proddt,
  jobrun_rundt
FROM
  (SELECT jobrun_rundt - jobrun_proddt carryover_days,
    jobrun.jobmst_name,
    jobrun.jobmst_prntname,
    jobrun_id,
    jobrun_proddt,
    jobrun_rundt,
    jobrun_status,
    jobrun_cmd,
    jobrun_reruns,
    statusname
  FROM jobrun,
    jobdata,
    jobrunstatus
  WHERE CAST(jobrun_proddt AS DATE )        < CAST(jobrun_rundt AS DATE )
  AND sysdate - jobrun_rundt                = -1
  AND jobrun.jobmst_id                      = jobdata.jobmst_id and jobdata.version = 0
  AND jobrun.jobrun_status                  = jobrunstatus.statusid
  AND jobrun.jobmst_type                    > 1
  AND jobrun_status                         < 100
  ) q1
ORDER BY q1.jobrun_proddt DESC,
  jobmst_prntname,
  jobmst_name,
  q1.carryover_days
]]>
        </querytext_oracle>
    </query>    
    <query>
        <queryname>730 Job last RunDate</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
          <![CDATA[
       select jobdata.JobName,jobdata.JobGroup, jobdata.jobmst_id,jobrunlast.lastproddt LastScheduledDate, jobrunlast.jobrun_time LastRunTime from jobdata
left join  
(select jobmst_id,  max(jobrun_proddt) lastproddt, max(jobrun_time) jobrun_time from jobrun where jobrun_status in(101,103,105,106) and
jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>' 
 group by jobmst_id ) jobrunlast 
on  jobdata.jobmst_id = jobrunlast.jobmst_id 
 where 
 jobdata.version = 0 
 order by lastproddt desc
 ]]>
    </querytext_sqlserver>
        <querytext_oracle>
<![CDATA[        
SELECT
     jobdata.jobname,
     jobdata.jobgroup,
     jobdata.jobmst_id,
     jobrunlast.lastproddt    lastscheduleddate,
     jobrunlast.jobrun_time   lastruntime
 FROM
     jobdata left
     JOIN (
         SELECT
             jobmst_id,
             MAX(jobrun_proddt) lastproddt,
             MAX(jobrun_time) jobrun_time
         FROM
             jobrun
         WHERE
             jobrun_status IN (
                 101,
                 103,
                 105,
                 106
             )
             AND jobrun_proddt BETWEEN TO_DATE('<<from_date>>','yyyy-mm-dd') AND TO_DATE('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS'
             )
         GROUP BY
             jobmst_id
     ) jobrunlast ON jobdata.jobmst_id = jobrunlast.jobmst_id
 WHERE
     jobdata.version = 0
 ORDER BY
     lastproddt DESC
]]>
    </querytext_oracle>
    </query>
    <query>
        <queryname>740H Adhoc jobs for selected date</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
      select jobrun_id, jobrun.jobmst_id, jobmst_name, jobrun.OWNER_NAME Owner, jobrun_cmd , Convert(varchar(10), jobrun_proddt,120) ProdDate from jobrun 
      where  jobrun.JOBRUN_ADHOC = 'Y' 
      and jobrun.jobrun_proddt = '<<prod_date>>';
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select jobrun_id, jobrun.jobmst_id, jobmst_name, jobrun.OWNER_NAME "Owner", jobrun_cmd , 
      to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
       from jobrun 
      where  jobrun.JOBRUN_ADHOC = 'Y' 
      and jobrun.jobrun_proddt = to_date('<<prod_date>>', 'yyyy/mm/dd')
]]>
        </querytext_oracle>
    </query>
    <query>
      <queryname>750 Jobrun status times for selected day</queryname>
      <querytotals></querytotals>
      <category>analysis</category>
      <linkquery></linkquery><querydescription></querydescription>
      <db>admiral</db>
      <chartfields></chartfields>
      <import_oracle>y</import_oracle>
      <querytext_sqlserver>
          <![CDATA[
          select jobrun_id,jobmst_id, 
          jobmst_name, 
          jobmst_prntname, 
          jobcls_name, 
          owner, 
          FORMAT([jobrun_rundt],'yyyyMMdd') jobrun_rundt,
          FORMAT([jobrun_proddt],'yyyyMMdd') jobrun_proddt, 
          jobrun_status,
          jobmst_type,
          WaitingOndependencies, WaitingOnResource, Launched, Active, CompletedNormally, CompletedAbnormally, Skipped,
          DATEDIFF(ss,WaitingOndependencies,WaitingOnResource  ) TimeWaitOnDep,
          DATEDIFF(ss,WaitingOnResource,Launched  ) TimeWaitOnResource,
          DATEDIFF(ss,Launched,Active  ) TimeWaitLaunched,
          DATEDIFF(ss,Active, CompletedNormally  ) TimeActiveNormal,
          DATEDIFF(ss,Active, CompletedAbnormally  ) TimeActiveAbnormal,
          DATEDIFF(ss,coalesce(WaitingOnResource, WaitingOndependencies ), Skipped  ) TimeSkipped
        from (
          select jobrun_id,jobmst.jobmst_id, jobmst.jobmst_name, jobmst.jobmst_prntname , coalesce(jobcls.jobcls_name,'') jobcls_name, owner.owner_name owner,jobrun_rundt,jobrun_proddt,
          (select strmst_desc from strmst where strmst_type=7 and strmst_id = jobrun.jobrun_status) jobrun_status, 
          (select top 1 msglog_crtdt from msglog where msglog_text like '%Waiting On Dep%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) WaitingOndependencies,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%Waiting On Resource%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) WaitingOnResource,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%status change to Launched%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) Launched,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%status change to Active%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) Active,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%status change to Completed Normally%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) CompletedNormally,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%status change to Completed AbNormally%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) CompletedAbnormally,
          (select top 1 msglog_crtdt from msglog where msglog_text like '%status change to Skipped%' and jobrun_id = jobrun.jobrun_id order by msglog_crtdt) Skipped,
          jobmst.jobmst_type
          from jobrun 
          join jobmst on  jobmst.jobmst_id =  jobrun.jobmst_id
          left outer join jobcls on jobmst.jobcls_id = jobcls.jobcls_id
          left outer join owner on jobmst.jobmst_owner = owner.owner_id
          WHERE   
          jobrun.jobmst_id = jobmst.jobmst_id and jobrun.jobrun_rundt  =  '<<prod_date>>' 
          --(select sysval_time - 1 from sysval where sysval_id = 84) 
        ) 
        as v1
        order by owner, jobmst_prntname, jobmst_name
                  ]]>
      </querytext_sqlserver>
      <querytext_oracle>
          <![CDATA[
    select jobrun_id, jobrun.jobmst_id, jobmst_name, jobrun.OWNER_NAME "Owner", jobrun_cmd , 
    to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate"
     from jobrun 
    where  jobrun.JOBRUN_ADHOC = 'Y' 
    and jobrun.jobrun_proddt = to_date('<<prod_date>>', 'yyyy/mm/dd')
]]>
      </querytext_oracle>
  </query>
  <query>
        <queryname>802 Jobs that have increased runtime</queryname>
        <category>hidden</category>
        <linkquery>9802 Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select * , ((duration - prevmonth) * 100) / case  when duration < 1 then 1 else duration end pct_increase, DATEDIFF(mm, '20170101', GETDATE()) currmonth from (
  select 
   --lead(duration) over (partition by jobmst_id order by month) nextmonth,
   lag(duration) over (partition by jobmst_id order by month) prevmonth,
  * from (
    select jobrun.jobmst_id,
        jobrun.jobmst_type,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
		datepart(yyyy,jobrun.jobrun_proddt) year,
        DATEDIFF(mm, '20170101', jobrun.jobrun_proddt) month from jobrun
    where 
      jobrun.jobmst_type > 1 and not jobrun.jobrun_duration is null and jobrun_status = 101 
        --and jobrun_proddt >= '20161201' and  jobrun_proddt <= '20170331'
    group by jobmst_id, datepart(yyyy,jobrun.jobrun_proddt), jobrun.jobmst_type,DATEDIFF(mm, '20170101', jobrun.jobrun_proddt)
 --order by jobmst_id, dayofyear 
 )
 as sql1) as sql2 
 where 
 --((nextmonth - duration) * 100) / case  when duration < 1 then 1 else duration end > 10 and (nextmonth - duration) > 60 order by jobmst_id, month
  ((duration - prevmonth) * 100) / case  when duration < 1 then 1 else duration end ><<pct_increase>> and (duration - prevmonth) > 60 and DATEDIFF(mm, '20170101', GETDATE()) - month < <<months_back>>
 order by jobmst_id

	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>803H Jobs runtime comparison with previous months</queryname>
        <category>analysis</category>
        <linkquery>9803H Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
 
 with cte as (
  select jobrun.jobmst_id,
        jobrun.jobmst_type,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101) yy_mm,
        DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt) month from jobrun
    where 
       jobrun.jobmst_type > 1 and
       not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%') and
	   not jobrun.jobrun_duration is null and jobrun_status = 101 
      
        --and jobrun_proddt >= '20131201' and  jobrun_proddt <= '20170331'
    group by jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101), jobrun.jobmst_type,DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt)
	) 
	select 
		convert(varchar(250),cur_month.jobmst_id) +'_'+ cur_month.yy_mm linkkey,
		cur_month.jobmst_id, 
	    jobdata.jobname Job_Name, coalesce(jobdata.jobgroup,'') Job_Group,
		cur_month.yy_mm,
        round(cast((cur_month.duration - prev_month.duration) as float) / prev_month.duration * 100,0) pct_difference,
        cur_month.cnt current_month_cnt,
		prev_month.cnt previous_month_cnt, 
		cur_month.duration current_month_duration,
		prev_month.duration previous_month_duration,
		cur_month.duration - prev_month.duration diff
	from cte as prev_month , 
			cte as  cur_month,
			--jobmst
            jobdata
		where 
		cur_month.month - <<months_back:1>> = prev_month.month and 
        cur_month.yy_mm = '<<year_mm:2018_06>>' and
		cur_month.jobmst_id = prev_month.jobmst_id  and 
		cur_month.jobmst_id = jobdata.jobmst_id and
        --abs(((cur_month.duration - prev_month.duration) * 100) / case  when cur_month.duration < 1 then 1 else cur_month.duration end) < 100 and 
        jobdata.version = 0      
		order by abs(cast((cur_month.duration - prev_month.duration) as float) / prev_month.duration * 100) desc,
		 cur_month.jobmst_id,
		 cur_month.month
          
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
with cte as (
  select jobrun.jobmst_id,
        jobrun.jobmst_type,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
     to_char(jobrun.jobrun_proddt, 'YY_MM')  yy_mm,
     round(MONTHS_BETWEEN(to_date('2013-01-01','yyyy-mm-dd'), jobrun.jobrun_proddt),0) month  from jobrun
    where 
       jobrun.jobmst_type > 1 and
       not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%') and
	   not jobrun.jobrun_duration is null and jobrun_status = 101 
      
        --and jobrun_proddt >= '20131201' and  jobrun_proddt <= '20170331'
    group by jobmst_id, to_char(jobrun.jobrun_proddt, 'YY_MM'), jobrun.jobmst_type,MONTHS_BETWEEN(to_date('2013-01-01','yyyy-mm-dd'), jobrun.jobrun_proddt)
	) 
	select 
		cast(cur_month.jobmst_id as varchar(10)) || '_' || cur_month.yy_mm linkkey,
		cur_month.jobmst_id, 
	    jobdata.jobname Job_Name, coalesce(cast(jobdata.jobgroup as varchar(4000)),'') Job_Group,
		cur_month.yy_mm,
        round(cast((cur_month.duration - prev_month.duration) as float) / prev_month.duration * 100,0) pct_difference,
    --((cur_month.duration - prev_month.duration) * 100) / case  when cur_month.duration < 1 then 1 else cur_month.duration end pct_difference,
		cur_month.cnt current_month_cnt,
		prev_month.cnt previous_month_cnt, 
		cur_month.duration current_month_duration,
		prev_month.duration previous_month_duration,
		cur_month.duration - prev_month.duration diff
	from cte  prev_month , 
			cte   cur_month,
			--jobmst
            jobdata
		where 
		cur_month.month - <<months_back:1>> = prev_month.month and 
        --cur_month.month - 1 = prev_month.month and 
        cur_month.yy_mm = '<<year_mm:2018_12>>' and
        --cur_month.yy_mm = '2018_12' and
        cur_month.jobmst_id = prev_month.jobmst_id  and 
		cur_month.jobmst_id = jobdata.jobmst_id and
        --abs(((cur_month.duration - prev_month.duration) * 100) / case  when cur_month.duration < 1 then 1 else cur_month.duration end) < 100 and 
        jobdata.version = 0      
		order by abs(cast((cur_month.duration - prev_month.duration) as float) / prev_month.duration * 100) desc,
		 cur_month.jobmst_id,
		 cur_month.month
 
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>804H Jobs runtime comparison with previous week</queryname>
        <category>analysis</category>
        <linkquery>9802 Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[

 with cte as (
  select jobrun.jobmst_id,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),datepart(wk,jobrun.jobrun_proddt)) yy_ww,
        DATEDIFF(week, '20160101', jobrun.jobrun_proddt) week from jobrun
    where 
      jobrun.jobmst_type > 1 and not jobrun.jobrun_duration is null and jobrun_status = 101 
       and not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%')
       and (jobrun_proddt between '<<from_date>>' and '<<to_date>>')
        --and jobrun_proddt >= '20161201' and  jobrun_proddt <= '20170331'
    group by jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' +  CONVERT(varchar(2),datepart(wk,jobrun.jobrun_proddt)), DATEDIFF(week, '20160101', jobrun.jobrun_proddt)
	) 
  select cur_week.jobmst_id, 
      jobdata.jobname Job_Name, coalesce(jobdata.jobgroup,'') Job_Group,
    cur_week.yy_ww,
        cur_week.duration cur_week_duration,
    prev_week.duration prev_week_duration,
    cur_week.duration - prev_week.duration diff,
    round(cast((cur_week.duration - prev_week.duration) as float) / prev_week.duration * 100,0) pct_difference,
    --((cur_week.duration - prev_week.duration) * 100) / case  when cur_week.duration < 1 then 1 else cur_week.duration end pct_difference,
    cur_week.cnt cur_week_cnt,
    prev_week.cnt prev_week_cnt
    
  from cte as prev_week , 
      cte as  cur_week,
      jobdata
    where 
    cur_week.week - 1 = prev_week.week and 
    cur_week.jobmst_id = prev_week.jobmst_id  and 
    cur_week.jobmst_id = jobdata.jobmst_id and 
	jobdata.version = 0 
    order by abs(cast((cur_week.duration - prev_week.duration) as float) / prev_week.duration * 100) desc,
     cur_week.jobmst_id,
     cur_week.week
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
with cte as (
  select jobrun.jobmst_id,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
        to_char(jobrun.jobrun_proddt, 'YY_WW')  yy_ww,
     min(round((to_date('2016-01-01','yyyy-mm-dd') - jobrun.jobrun_proddt )/7,0)) week from jobrun
    where 
      jobrun.jobmst_type > 1 and not jobrun.jobrun_duration is null and jobrun_status = 101 
       and not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%')
        and jobrun_proddt >= to_date('<<from_date>>','YYYY-MM-DD') and jobrun_proddt <= to_date('<<to_date>>','YYYY-MM-DD')
    group by jobmst_id, to_char(jobrun.jobrun_proddt, 'YY_WW') , round((to_date('2013-01-01','yyyy-mm-dd') - jobrun.jobrun_proddt )/7,0)
	)            
  select cur_week.jobmst_id, 
      jobdata.jobname Job_Name, coalesce(cast(jobdata.jobgroup as varchar(4000)),'') Job_Group,
    cur_week.yy_ww,
        cur_week.duration cur_week_duration,
    prev_week.duration prev_week_duration,
    cur_week.duration - prev_week.duration diff,
    round(cast((cur_week.duration - prev_week.duration) as float) / prev_week.duration * 100,0) pct_difference,
    cur_week.cnt cur_week_cnt,
    prev_week.cnt prev_week_cnt
  from cte prev_week , 
      cte  cur_week,
      jobdata
    where 
    cur_week.week - 1 = prev_week.week and 
    cur_week.jobmst_id = prev_week.jobmst_id  and 
    cur_week.jobmst_id = jobdata.jobmst_id and 
	jobdata.version = 0 
    order by abs(cast((cur_week.duration - prev_week.duration) as float) / prev_week.duration * 100) desc,
     cur_week.jobmst_id,
     cur_week.week

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>805H Job runtime by month</queryname>
        <category>analysis</category>
        <linkquery>9803H Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
    select jobrun.jobmst_id,
        jobrun.jobmst_type,
        jobrun.jobmst_name, jobrun.jobmst_prntname,		
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101) yy_mm,
        DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt) month from jobrun
    where 
       jobrun.jobmst_type > 1 and
       not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%') and
	   not jobrun.jobrun_duration is null and jobrun_status = 101 
        and (jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') 
    group by jobrun.jobmst_prntname, jobrun.jobmst_name,  jobrun.jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101), jobrun.jobmst_type,DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt)
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      SELECT
     jobrun.jobmst_id,
     jobrun.jobmst_type,
     jobrun.jobmst_name,
     jobrun.jobmst_prntname,
     COUNT(*) cnt,
     AVG(jobrun.jobrun_duration) duration,
     to_char(jobrun.jobrun_proddt,'YYYY_MM') yy_mm,
     --CAST(datepart(yyyy,jobrun.jobrun_proddt) AS VARCHAR) + '_' + convert(VARCHAR(2),jobrun.jobrun_proddt,101) yy_mm,
     --datediff(month,'20130101',jobrun.jobrun_proddt) month
     round(MONTHS_BETWEEN(to_date('2013-01-01','yyyy-mm-dd'),jobrun.jobrun_proddt),0) month

 FROM
     jobrun
 WHERE
     jobrun.jobmst_type > 1
     AND NOT jobrun_id IN (
         SELECT
             jobrun_id
         FROM
             msglog
         WHERE
             jobrun_id = jobrun.jobrun_id
             AND msglog_text LIKE '%Abnormally%'
     )
     AND NOT jobrun.jobrun_duration IS NULL
     AND jobrun_status = 101
     AND ( jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd') 
           AND jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd') )
 GROUP BY
     jobrun.jobmst_prntname,
     jobrun.jobmst_name,
     jobrun.jobmst_id,
     to_char(jobrun.jobrun_proddt,'YYYY_MM'),
     jobrun.jobmst_type,
     round(MONTHS_BETWEEN(to_date('2013-01-01','yyyy-mm-dd'),jobrun.jobrun_proddt),0)
     --datediff(month,'20130101',jobrun.jobrun_proddt)
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>del-806H Job runtime by month</queryname>  
        <category>hidden</category>
        <linkquery>9803H Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>n</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
    select jobrun.jobmst_id,
        jobrun.jobmst_type,
        jobdata.JobGroup, jobdata.JobName,		
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101) yy_mm,
        DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt) month from jobrun, jobdata
    where 
       jobrun.jobmst_type > 1 and
	   jobdata.jobmst_id = jobrun.jobmst_id and
	   jobdata.version = 0 and
       (jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>') and
       not jobrun_id in (select jobrun_id from msglog where jobrun_id = jobrun.jobrun_id and msglog_text like '%Abnormally%') and
	   not jobrun.jobrun_duration is null and jobrun_status = 101 
    group by jobdata.JobGroup, jobdata.JobName,	jobrun.jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),jobrun.jobrun_proddt, 101), jobrun.jobmst_type,DATEDIFF(MONTH, '20130101', jobrun.jobrun_proddt)
		   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>    
    <query>
        <queryname>9802 Jobdetails that have increased runtime</queryname>
        <category>hidden</category>
        <linkquery>9803 Jobdetails that have increased runtime</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
    select jobrun.jobmst_id,
        jobrun.jobmst_type,
        count(*) cnt,
        avg(jobrun.jobrun_duration) duration,
		datepart(yyyy,jobrun.jobrun_proddt) year,
        DATEDIFF(mm, '20170101', jobrun.jobrun_proddt) month from jobrun
    where 
      jobrun.jobmst_type > 1 and not jobrun.jobrun_duration is null and jobrun_status = 101 
      and jobmst_id = <<jobmst_id>>
        --and jobrun_proddt >= '20161201' and  jobrun_proddt <= '20170331'
    group by jobmst_id, datepart(yyyy,jobrun.jobrun_proddt), jobrun.jobmst_type,DATEDIFF(mm, '20170101', jobrun.jobrun_proddt)

	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>9803 Jobdetails that have increased runtime</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields>jobrun_proddt,duration</chartfields>
        <querytext_sqlserver>
            <![CDATA[
    select 
      jobrun.jobmst_id,
      jobmst.jobmst_name,
      jobmst.jobmst_prntname,
      jobrun.jobrun_proddt,
      jobrun.jobrun_id,
      count(*) Count,
      avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),datepart(mm,jobrun.jobrun_proddt)) yy_mm,
        DATEDIFF(week, '20100101', jobrun.jobrun_proddt) week from jobrun, jobmst
    where 
      jobrun.jobmst_type > 1 
      and not jobrun.jobrun_duration is null 
      --and jobrun_status = 101 
      and jobrun.jobmst_id = <<jobmst_id>>
      and jobrun.jobmst_id = jobmst.jobmst_id
    group by  jobmst.jobmst_name, jobmst.jobmst_prntname, jobrun.jobrun_proddt,jobrun.jobrun_id,jobrun.jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' +  CONVERT(varchar(2),datepart(wk,jobrun.jobrun_proddt)), DATEDIFF(week, '20100101', jobrun.jobrun_proddt)
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>9803H Jobdetails that have increased runtime</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>ProdDate,duration</chartfields>
        <querytext_sqlserver>
            <![CDATA[
    select 
      jobrun.jobmst_id,
      jobrun.jobmst_name JobName,
      jobrun.jobmst_prntname JobGroup,
      jobrun.jobrun_proddt ProdDate,
      jobrun.jobrun_id,
      count(*) Count,
      avg(jobrun.jobrun_duration) duration,
     cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' + CONVERT(varchar(2),datepart(mm,jobrun.jobrun_proddt)) yy_mm,
        DATEDIFF(week, '20100101', jobrun.jobrun_proddt) week 
    from jobrun
    where 
      jobrun.jobmst_type > 1 
      and not jobrun.jobrun_duration is null 
      --and jobrun_status = 101 
      and jobrun.jobmst_id = <<jobmst_id>>
    group by  jobrun.jobmst_name, jobrun.jobmst_prntname, jobrun.jobrun_proddt,jobrun.jobrun_id,jobrun.jobmst_id, cast(datepart(yyyy,jobrun.jobrun_proddt) as varchar) + '_' +  CONVERT(varchar(2),datepart(wk,jobrun.jobrun_proddt)), DATEDIFF(week, '20100101', jobrun.jobrun_proddt)
    order by ProdDate
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>    
    <query>
        <queryname>999 adhoc test</queryname>
        <category>test</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
      declare @StartTime datetime = '2014-01-01 00:00:00',
      @EndTime datetime = '2014-01-10 15:37:34',
      @Interval int = <<interval:60>> -- this can be changed.

      ;WITH cSequence AS
      (
      SELECT
      @StartTime AS StartDate,
      DATEADD(minute, @Interval, @StartTime) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
 /* insert into tmp_IRange */
SELECT * FROM cSequence OPTION (MAXRECURSION 0);
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      declare @StartTime datetime = '2016-01-01 12:00:00',
      @EndTime datetime = '2014-01-10 15:37:34',
      @Interval int = <<interval:60>> -- this can be changed.

      ;WITH cSequence AS
      (
      SELECT
      @StartTime AS StartDate,
      DATEADD(minute, @Interval, @StartTime) AS EndRange
      UNION ALL
      SELECTqueryJobrun
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
 /* insert into tmp_IRange */
SELECT * FROM cSequence OPTION (MAXRECURSION 0);
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>GetJobrunInfoRep</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id JobrunID, jobmst_prntname JobGroup, jobrun.jobmst_id, jobrun.jobmst_name JobName,  jobmst_runbook RunBook, jobrun_instance Instance ,statusname JobRunStatus, jobrun_stachgtm LastStatusChanged, jobrun_lstchgtm LastChanged, jobrun_joboutput JobOutput, jobrun_met DependenciesMet, 
Case when jobdata.jobmst_type = 1 then 'JobGroup' when jobdata.jobmst_type=2 then 'Job' when jobdata.jobmst_type=6 then 'FTP' when jobdata.jobmst_type=8 then 'Adapter' end JobType,coalesce(jobrun_envfile,'') EnvironmentFile,
 jobrun_proddt ProdDate, jobrun_estduration EstDuration, jobrun_duration ActDuration, jobrun_esttime EstTime, jobrun_time ActTime, nodmst_name Agent , quemst_name Queue, jobrun_adhoc Adhoc, jobrun_waitop WaitingOnOperator, jobrun_fromtm FromTime, jobrun_untiltm UntilTime, jobrun.owner_name Owner, jobrun_concur Concurrent,
 jobrun_priority Priority, jobrun_cmd Command, jobrun_params Parameters, jobrun_envfile EnvironmentFile, jobrun_exitcode ExitCode, jobrun_timewin TimeWindow, jobrun_saveoutput SaveOutput, jobrun_reruns Reruns, jobrun_hasdependents HasDependents, jobrun_rundt RunDate, jobrun_minrun MinRun, jobrun_maxrun MaxRun, jobrun_deplogic DependencyLogic, jobrun.jobcls_id ClassId, jobrun.jobclass JobClass, jobrun_interval Interval, jobrun_intervalcnt IntervalCount, jobrun_rerun Rerun, jobrun_timediff TimeDifference, jobrun_outputlen OutputLength, jobrun_normalexit NormalExitcode, jobrun_deprerun DependencyRerun, jobrun_carryover CarryOver, jobrun_ignoretime IngnoreTime, jobrun_savelogonly SaveLogOnly, jobrun_expire JobRunExpireDate, jobrun_deps Dependencies, jobrun_cputime CPUTime, jobrun_extinfo ExtendedInfo, jobrun_reslock ResourceLock,  jobrun_nearoutage NearOutage, jobrun_queuetm QueueTime, jobrun_launchtm LaunchTime, jobrun_fullpath FullPath, jobrun_usrmodtm UserModifiedTime, jobrun_startrundt, jobrun_proddt prod_date from jobrun, jobrunstatus, jobdata where jobrun_status = jobrunstatus.statusid and jobdata.jobmst_id = jobrun.jobmst_id and jobdata.version = 0 and jobrun_id = <<jobrun_id>>
 
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select jobrun_id "JobrunID", jobmst_prntname "JobGroup", jobmst_id, jobmst_name "JobName", jobrun_instance "Instance" ,statusname "JobRunStatus", jobrun_stachgtm "LastStatusChanged", jobrun_lstchgtm "LastChanged", jobrun_joboutput "JobOutput", jobrun_met "DependenciesMet", 
      Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end "JobType",
      jobrun_proddt "ProdDate", jobrun_estduration "EstDuration", jobrun_duration "ActDuration", jobrun_esttime "EstTime", jobrun_time "ActTime", nodmst_name "Agent" , quemst_name "Queue", jobrun_adhoc "Adhoc", jobrun_waitop "WaitingOnOperator", jobrun_fromtm "FromTime", jobrun_untiltm "UntilTime", owner_name "Owner", jobrun_concur "Concurrent",
 jobrun_priority "Priority", jobrun_cmd "Command",jobrun_params "Parameters", jobrun_envfile "EnvironmentFile", jobrun_exitcode "ExitCode", jobrun_timewin "TimeWindow", jobrun_saveoutput "SaveOutput", jobrun_reruns "Reruns", jobrun_output "JobRunOutput", jobrun_hasdependents "HasDependents", jobrun_rundt "RunDate", jobrun_minrun "MinRun", jobrun_maxrun "MaxRun", jobrun_deplogic "DependencyLogic", jobcls_id "ClassId",jobclass "JobClass", jobrun_interval "Interval", jobrun_intervalcnt "IntervalCount", jobrun_rerun "Rerun", jobrun_timediff "TimeDifference", jobrun_outputlen "OutputLength", jobrun_normalexit "NormalExitcode", jobrun_deprerun "DependencyRerun", jobrun_carryover "CarryOver", jobrun_ignoretime "IngnoreTime", jobrun_savelogonly "SaveLogOnly", jobrun_expire "JobRunExpireDate", jobrun_deps "Dependencies", jobrun_cputime "CPUTime", jobrun_extinfo "ExtendedInfo", jobrun_reslock "ResourceLock",  jobrun_nearoutage "NearOutage", jobrun_queuetm "QueueTime", jobrun_launchtm "LaunchTime", jobrun_fullpath "FullPath", jobrun_usrmodtm "UserModifiedTime", jobrun_successors "Successors", jobrun_startrundt, jobrun_proddt "prod_date" from jobrun, jobrunstatus where jobrun_status = jobrunstatus.statusid  and jobrun_id = <<jobrun_id>>

]]>
        </querytext_oracle>
        <querytext_sqlite3>
            <![CDATA[
      select jobrun_id JobrunID, jobmst_prntname JobGroup, jobmst_id, jobmst_name JobName, jobrun_instance Instance ,statusname JobRunStatus, jobrun_stachgtm LastStatusChanged, jobrun_lstchgtm LastChanged, jobrun_joboutput JobOutput, jobrun_met DependenciesMet, jobmst_type JobType, jobrun_proddt ProdDate, jobrun_estduration EstDuration, jobrun_duration ActDuration, jobrun_esttime EstTime, jobrun_time ActTime, nodmst_name Agent , quemst_name Queue, jobrun_adhoc Adhoc, jobrun_waitop WaitingOnOperator, jobrun_fromtm FromTime, jobrun_untiltm UntilTime, owner_name Owner, jobrun_concur Concurrent,
 jobrun_priority Priority, jobrun_cmd Command,jobrun_params Parameters, jobrun_envfile EnvironmentFile, jobrun_exitcode ExitCode, jobrun_timewin TimeWindow, jobrun_saveoutput SaveOutput, jobrun_reruns Reruns, jobrun_output JobRunOutput, jobrun_hasdependents HasDependents, jobrun_rundt RunDate, jobrun_minrun MinRun, jobrun_maxrun MaxRun, jobrun_deplogic DependencyLogic, jobcls_id ClassId, jobclass JobClass, jobrun_interval Interval, jobrun_intervalcnt IntervalCount, jobrun_rerun Rerun, jobrun_timediff TimeDifference, jobrun_outputlen OutputLength, jobrun_normalexit NormalExitcode, jobrun_deprerun DependencyRerun, jobrun_carryover CarryOver, jobrun_ignoretime IngnoreTime, jobrun_savelogonly SaveLogOnly, jobrun_expire JobRunExpireDate, jobrun_deps Dependencies, jobrun_cputime CPUTime, jobrun_extinfo ExtendedInfo, jobrun_reslock ResourceLock,  jobrun_nearoutage NearOutage, jobrun_queuetm QueueTime, jobrun_launchtm LaunchTime, jobrun_fullpath FullPath, jobrun_usrmodtm UserModifiedTime, jobrun_successors Successors, jobrun_startrundt from jobrun, jobrunstatus where jobrun_status = jobrunstatus.statusid  and jobrun_id = <<jobrun_id>>

]]>
        </querytext_sqlite3>
    </query>
    <query>
        <queryname>GetJobrunInfo</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobrun.jobrun_id jobrun_id, jobmst_prntname JobGroup, jobrun.jobmst_id, jobmst.jobmst_name JobName,  coalesce(jobmst_runbook,'') RunBook, jobrun_instance Instance ,strmst_desc JobRunStatus, 
jobrun_stachgtm LastStatusChanged, jobrun_lstchgtm LastChanged, coalesce(joboutput.jobrun_output,'') JobRunOutput, 
jobrun_met DependenciesMet, 
Case when jobmst.jobmst_type = 1 then 'JobGroup' when jobmst.jobmst_type=2 then 'Job' when jobmst.jobmst_type=6 then 'FTP' when jobmst.jobmst_type=8 then 'Adapter' end JobType,
 jobrun_proddt ProdDate, jobrun_estduration EstDuration, jobrun_duration ActDuration, jobrun_esttime EstTime, jobrun_time ActTime, nodmst_name Agent ,coalesce(jobrun_proxy,0) RuntimeUser, jobrun_adhoc Adhoc, 
 jobrun_waitop WaitingOnOperator, jobrun_fromtm FromTime, jobrun_untiltm UntilTime, 
 jobrun_concur Concurrent, coalesce(jobrun_envfile,'') EnvironmentFile,
 jobrun_priority Priority, jobrun_cmd Command, jobrun_params Parameters, jobrun_exitcode ExitCode, jobrun_timewin TimeWindow, 
 jobrun_saveoutput SaveOutput, jobrun_reruns Reruns, jobrun_hasdependents HasDependents,
  jobrun_rundt RunDate, jobrun_minrun MinRun, jobrun_maxrun MaxRun, jobrun_deplogic DependencyLogic, jobrun.jobcls_id ClassId, 
  jobrun_interval Interval, jobrun_intervalcnt IntervalCount, jobrun_rerun Rerun, jobrun_timediff TimeDifference,
   jobrun.jobrun_outputlen OutputLength, jobrun_normalexit NormalExitcode, jobrun_deprerun DependencyRerun, jobrun_carryover CarryOver,
   jobrun_ignoretime IngnoreTime, jobrun_savelogonly SaveLogOnly, jobrun_expire JobRunExpireDate, jobrun_deps Dependencies, 
   jobrun_cputime CPUTime, jobrun_extinfo ExtendedInfo, jobrun_reslock ResourceLock,  jobrun_nearoutage NearOutage, jobrun_queuetm QueueTime, 
   jobrun_launchtm LaunchTime, jobrun_fullpath FullPath, jobrun_usrmodtm UserModifiedTime, jobrun_startrundt, jobrun_proddt prod_date 
   from jobrun
   join strmst on jobrun_status = strmst.strmst_id and strmst_type = 7 
   join  jobmst on jobmst.jobmst_id = jobrun.jobmst_id
   left join joboutput on jobrun.jobrun_id = joboutput.jobrun_id
   left join nodmst on jobrun.nodmst_id = nodmst.nodmst_id  
   where jobrun.jobrun_id = <<jobrun_id>>
 
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[

]]>
        </querytext_oracle>
        <querytext_sqlite3>
            <![CDATA[

]]>
        </querytext_sqlite3>
    </query>    
    <query>
        <queryname>GetJobInfo</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT jobmst_id , '0' jobrunid , jobtype  JobType , jobname JobName , jobgroup jobmst_prntname ,calendar Calendar , coalesce(jobmst_runbook,'') RunBook, agent Agent , agentlist AgentList, jobclass JobClass, fromtime FromTime , untiltime UntilTime , jobdtl_cmd Command , jobdtl_params Parameters, jobmst_active  Active, owner_name Owner , jobmst_lstchgtm LastUpdated, jobmst_alias Alias , runtimeuser RuntimeUser , jobdtl_interval Interval , jobdtl_intervalcnt IntervalCount , jobdtl_normalexit NormalExitCode , jobdtl_priority Priority , servicemst_name , jobdtl_inhagent InheritAgent , jobdtl_inhevent InheritCalendar, jobdtl_inhtime InheritTime , jobdtl_minrun MinRunTime, jobdtl_maxrun MaxRuntime , jobdtl_concur ConcurrentOption, coalesce(jobdtl_envfile, '') EnvironmentFile , jobdtl_retnsn RetentionDays , jobdtl_rerun Rerun , jobdtl_carryover CarryOver , jobdtl_extinfo ExtendedInfo , jobdtl_saveoutput SaveOutput FROM JOBDATA where version = 0 and jobmst_id = <<jobmst_id>>
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      SELECT jobmst_id ,
      Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end "JobType",
       jobname "JobName" , jobgroup "JobGroup" ,calendar "Calendar" ,agent "Agent" , agentlist "AgentList", jobclass "JobClass", fromtime "FromTime" , untiltime "UntilTime" , jobdtl_cmd "Command" , jobdtl_params "Parameters", jobmst_active  "Active", owner_name "Owner" , jobmst_lstchgtm "LastUpdated", jobmst_alias "Alias" , runtimeuser "RuntimeUser" , jobdtl_interval "Interval" , jobdtl_intervalcnt "IntervalCount" , jobdtl_normalexit "NormalExitCode" , jobdtl_priority "Priority" , servicemst_name , jobdtl_inhagent "InheritAgent" , jobdtl_inhevent "InheritCalendar", jobdtl_inhtime "InheritTime" , jobdtl_minrun "MinRunTime", jobdtl_maxrun "MaxRuntime" , jobdtl_concur "ConcurrentOption" , jobdtl_retnsn "RetentionDays" , jobdtl_rerun "Rerun" , jobdtl_carryover "CarryOver" , jobdtl_extinfo "ExtendedInfo" , jobdtl_saveoutput "SaveOutput", jobmst_runbook "RunBook" FROM JOBDATA where version = 0 and jobmst_id = <<jobmst_id>>
]]>
        </querytext_oracle>
        <querytext_sqlite3>
            <![CDATA[
      SELECT jobmst_id , jobtype  JobType , jobname JobName , jobgroup JobGroup ,calendar Calendar ,agent Agent , agentlist AgentList, jobclass JobClass, fromtime FromTime , untiltime UntilTime , jobdtl_cmd Command , jobdtl_params Parameters, jobmst_active  Active, owner_name Owner , jobmst_lstchgtm LastUpdated, jobmst_alias Alias , runtimeuser RuntimeUser , jobdtl_interval Interval , jobdtl_intervalcnt IntervalCount , jobdtl_normalexit NormalExitCode , jobdtl_priority Priority , servicemst_name , jobdtl_inhagent InheritAgent , jobdtl_inhevent InheritCalendar, jobdtl_inhtime InheritTime , jobdtl_minrun MinRunTime, jobdtl_maxrun MaxRuntime , jobdtl_concur ConcurrentOption , jobdtl_retnsn RetentionDays , jobdtl_rerun Rerun , jobdtl_carryover CarryOver , jobdtl_extinfo ExtendedInfo , jobdtl_saveoutput SaveOutput, jobmst_runbook RunBook FROM JOBDATA where version = 0 and jobmst_id = <<jobmst_id>>
]]>
        </querytext_sqlite3>
    </query>
    <query>
        <queryname>1000 test jobrun</queryname>
        <category>test</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select count(*) from jobrun where jobrun_proddt = '2017-10-25'
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>1001 sqlstatement</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
	   <<sqlstatement>>
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
<<sqlstatement>>
	  ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>del-9700 All JobRuns by status per production day</queryname>
        <querytotals>All Jobs:sum(Count);</querytotals>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobmst_id, jobrun_instance,jobruns,jobrun_status, ProdDate from
  (
  SELECT        jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
   strmst_desc jobrun_status, jobrun_status js 
  FROM            jobrun, jobmst, strmst
  where jobrun.jobmst_id = jobmst.jobmst_id
              and jobmst.jobmst_type>1
              and jobrun.jobrun_status = strmst_id and strmst_type = '7'
              and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
  ) subsel
  where js like '<<jobrun_status>>'
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT        jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
	 strmst_desc jobrun_status
	FROM            jobrun, jobmst, strmst
	where jobrun.jobmst_id = jobmst.jobmst_id
						  and jobmst.jobmst_type > 1
              and jobrun.jobrun_status = strmst_id and strmst_type = '7'              
              and jobrun_proddt >= to_date('<<from_date>>','yyyy-mm-dd') and jobrun_proddt <= to_date('<<to_date>>','yyyy-mm-dd')
	) subsel 
	where jobrun_status like '<<jobrun_status>>'
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>9700H All JobRuns by status per production day</queryname>
        <querytotals>All Jobs:sum(Count);</querytotals>
        <category>analysis</category>
        <linkquery>716H JobRun with Detailed Messages</linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobmst_id, jobrun_instance,jobruns,jobrun_status from
  (
  SELECT        jobrun_id, jobrun.jobmst_id, jobrun_instance,Convert(varchar(10), jobrun_proddt,120) ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
   statusname jobrun_status, jobrun_status js 
  FROM            jobrun, jobrunstatus
  where  jobrun.jobmst_type > 1
              and jobrun.jobrun_status = jobrunstatus.statusid  
              and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
  ) subsel
  where js like '<<jobrun_status>>'
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobmst_id,
  jobrun_instance,
  jobruns,
  jobrun_status
FROM
  (SELECT jobrun_id,
    jobrun.jobmst_id,
    jobrun_instance,
    to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate",
    CASE
      WHEN jobrun_reruns=0
      THEN 1
      ELSE jobrun_reruns + 1
    END AS jobruns,
    statusname jobrun_status,
    jobrun_status js
  FROM jobrun,
    jobrunstatus
  WHERE jobrun.jobmst_type >1
  AND jobrun.jobrun_status = jobrunstatus.statusid
  AND jobrun_proddt       >= to_date('<<from_date>>','yyyy-mm-dd')
  AND jobrun_proddt       <= to_date('<<to_date>>','yyyy-mm-dd')
  ) subsel
WHERE js LIKE '<<jobrun_status>>'
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>9701 All JobRuns datas per production day for jobrun_id</queryname>
        <querytotals></querytotals>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
SELECT    jobmst.jobmst_prntname as JobGroup, jobmst.jobmst_name as JobName,jobmst.jobmst_id,coalesce(cast(jobrun_deps as varchar(4000)),'<jobrundeps></jobrundeps>') jobrun_deps, strmst_desc jobrun_status, jobrun.jobrun_id,
case when jobrun.jobrun_id = <<jobrun_id>> then 'D' else 'S' end as depsuc
  FROM   jobrun, jobmst, nodmst, strmst
  where jobrun.jobmst_id = jobmst.jobmst_id
        and jobrun.nodmst_id = nodmst.nodmst_id
        and jobrun.jobrun_status = strmst_id and strmst_type = '7'
        and not convert(varchar(100), coalesce(jobrun.jobrun_deps,'<jobrundeps></jobrundeps>'))  in ('<jobrundeps></jobrundeps>','<jobrundeps>0</jobrundeps>')        
        and (jobrun.jobrun_id = <<jobrun_id>> or coalesce(jobrun.jobrun_deps,'<jobrundeps></jobrundeps>') like '%<jobrunid><<jobrun_id>></jobrunid>%')
        and jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>'
order by depsuc desc        

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[

]]>
        </querytext_oracle>
    </query>
    
    <query>
        <queryname>9702 All JobRuns dependency data per production day</queryname>
        <querytotals></querytotals>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobrun.jobmst_id, 
  jobmst.jobmst_name,
  len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) level,
  coalesce(jobmst.jobmst_prntid,0) jobmst_prntid,
  jobrun.jobrun_prntid,
  case  when jobrun.jobrun_status < 50 and coalesce(jobrun_time,jobrun_esttime) < getdate()  then getdate() else  coalesce(jobrun_time,jobrun_esttime) end  jobrun_time, 
CASE
    WHEN jobrun_status = 101     THEN 100
    WHEN jobrun_status = 51 then (datediff(second,
	case  when jobrun.jobrun_status < 50 and coalesce(jobrun_time,jobrun_esttime) < getdate()  then getdate() else  coalesce(jobrun_time,jobrun_esttime) end,
	getdate()
	 ) / jobrun_estduration) * 100
    ELSE 0
  END PctComplete, 
  jobrun.jobrun_cmd,
  substring(jobrun.jobrun_joboutput,1,1000) joboutput,
  --coalesce(jobrun_duration, jobrun_estduration) duration,
  dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_time,jobrun_esttime)) jobrun_endtime,
  coalesce(jobmst.jobmst_prntname,'') jobmst_prntname,
  jobrun.jobmst_type,
  'agent' nodmst_name,
  coalesce(CONVERT(VARCHAR(5),jobrun.jobrun_fromtm,108),'') jobrun_fromtm_hhmm,
  jobrun.jobrun_fromtm, 
  jobrun.jobrun_ignoretime,
  --jobrun.jobrun_prntid,
  case when jobrun.jobrun_deplogic = 1 then 'All'  when jobrun_deplogic = 2 then 'One' else '' end DepLogic,
  --jobmst.jobmst_prntid,
  --coalesce(jobrun.jobrun_prntid,0) jobrun_prntid,
  jobrun.jobrun_status status_code,
  convert(varchar(4000), coalesce(jobrun.jobrun_deps,'')) deps, rtrim(strmst_desc) jobrun_status ,
  coalesce(jobrun.jobrun_orgstatus,'') jobrun_orgstatus,
  jobrun_successors
 from jobrun, jobmst, strmst with(nolock)
  where 
   (jobrun_proddt = '<<prod_date>>' or '<<prod_date>>' = '')
  -- and (jobrun.jobrun_id in ('<<jobrun_id>>') or '<<jobrun_id>><<%>>' = '%')
 
  and jobrun.jobrun_status = strmst_id and strmst_type = '7'
  and jobrun.jobmst_id = jobmst.jobmst_id
  and datediff(hour,getdate(), coalesce(jobrun_time,jobrun_esttime)) < 96
--order by jobrun_time, jobmst_name
]]>
        </querytext_sqlserver>
             
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobrun.jobmst_id,
  jobmst.jobmst_name,
  LENGTH(COALESCE(jobmst_prntname,' ')) - LENGTH(REPLACE(COALESCE(jobmst_prntname,' '),'\',' ')) "level",
  COALESCE(jobmst.jobmst_prntid,0) jobmst_prntid,
  jobrun.jobrun_prntid,
  CASE
    WHEN jobrun.jobrun_status                < 50
    AND COALESCE(jobrun_time,jobrun_esttime) < sysdate
    THEN sysdate
    ELSE COALESCE(jobrun_time,jobrun_esttime)
  END jobrun_time,
  CASE
    WHEN jobrun_status = 101     THEN 100
    WHEN jobrun_status = 51 then (((sysdate - jobrun_time) * (24*60*60) ) / jobrun_estduration) * 100
    ELSE 0
  END "PctComplete",
  COALESCE(jobrun_time,jobrun_esttime) + numToDSInterval( COALESCE(jobrun_duration, jobrun_estduration,0), 'second' ) jobrun_endtime,
  --coalesce(jobrun_time,jobrun_esttime) + interval cast(coalesce(jobrun_duration, jobrun_estduration,'0') as varchar(20)) second jobrun_endtime,
  --dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_time,jobrun_esttime)) jobrun_endtime,
  COALESCE(jobmst.jobmst_prntname,' ') jobmst_prntname,
  jobrun.jobmst_type,
  'agent' nodmst_name,
  COALESCE(TO_CHAR(jobrun.jobrun_fromtm,'HH24.mi'),'') jobrun_fromtm_hhmm,
  jobrun.jobrun_fromtm,
  jobrun.jobrun_ignoretime,
  CASE
    WHEN jobrun.jobrun_deplogic = 1
    THEN 'All'
    WHEN jobrun_deplogic = 2
    THEN 'One'
    ELSE ' '
  END "DepLogic",
  jobrun.jobrun_status status_code,
  COALESCE(CAST(substr(jobrun.jobrun_deps,1,4000) AS VARCHAR(4000)),'') deps,
  COALESCE(CAST(substr(jobrun.jobrun_deps,4001,4000) AS VARCHAR(4000)),'') deps2,
  rtrim(strmst_desc) jobrun_status ,
  COALESCE(CAST(jobrun.jobrun_orgstatus AS VARCHAR(2000)),'') jobrun_orgstatus,
  cast(jobrun_successors as varchar(4000)) jobrun_successors
FROM tidal.jobrun,
  tidal.jobmst,
  tidal.strmst
WHERE (jobrun_proddt = to_date('<<prod_date>>','yyyy-mm-dd')
OR '<<prod_date>>'   = '')
  --(jobrun_proddt = to_date('2018-07-15','yyyy-mm-dd')  or '2018-12-01' = '')
AND jobrun.jobrun_status                                   = strmst_id
AND strmst_type                                            = '7'
AND jobrun.jobmst_id                                       = jobmst.jobmst_id
AND sysdate - COALESCE(jobrun_time,jobrun_esttime,sysdate) < 4
]]>
        </querytext_oracle>
    </query>
    <query>

  <queryname>JobDependencyData</queryname>
        <querytotals></querytotals>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <cachetimeout>30</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
SELECT 
jobdata.jobmst_type,
jobdata.jobmst_prntid,
jobdata.jobmst_active,
jobdep.jobdep_id as id,
jobdata.jobmst_id as jobid, 
jobdep.jobdep_jobmst as depjobid,
jobdep.jobdep_joblogic condition, 
jobdep.nodmst_id as connectionid, 
jobdep.nodmst_name as connectionname,
jobdep.jobdep_dateoffset as dateoffset, 
jobdata_1.jobname as depjobname, 
jobdata_1.jobgroup as depjobparent, 
jobdata_1.jobtype as depjobtype,
jobdep.jobdep_value as depjobvalue,
jobdep.jobdep_fileextent as fileextent, 
jobdep.jobdep_filename as filename, 
jobdep.jobdep_filetype as filetype, 
jobdep.jobdep_canignore as ignoredep, 
rtrim(jobdep.jobdep_ingroup) as ingroup, 
jobdep.jobdep_instoffset as instanceoffset,
jobdata.jobmst_id, 
jobdata.jobname as jobname, 
jobdata.jobmst_owner as ownerid, 
jobdep.jobdep_keepmetifready as keepmetifready, 
jobdep.jobdep_lstchgtm as lastchangetime,
jobdep.jobdep_usrmodtm as lastusermodifiedtime, 
jobdep.jobdep_joblogic as logic, 
jobdep.nodmst_id as nodeid, 
jobdep.jobdep_filetype occurrence, 
jobdep.jobdep_operator as operator, 
jobdep.jobdep_value as procstep,
jobdep.jobdep_status as status, 
jobdep.jobdep_type as type, 
jobdep.varmst_id as variableid, 
jobdep.varmst_name as variablename, 
jobdep.jobdep_value as varvalue,
jobdata.jobname jobmst_name, 
jobdata.jobgroup as jobmst_prntname, 
 jobdata_1.fromtime jobdtl_until_time,
 jobdata_1.untiltime jobdtl_until_time, 
 CASE WHEN jobdep_joblogic = 1 THEN 'All' WHEN jobdep_joblogic = 2 THEN 'One' ELSE '' END  DepLogic, 
 jobdep_id id, 
 jobdep_type type, 
 jobdep_filetype occurrence, 
coalesce(jobdata.fromtime,'00:00')  jobdtl_fromtm_hhmm,
case when not jobdata.servicemst_name is null then jobdata.servicemst_name when jobdata.jobmst_type = 1 then 'G' when jobdata.jobmst_type = 2 then 'J'  when jobdata.jobmst_type = 6 then 'F' when jobdata.jobmst_type = 8 then 'A' else '?' end jobmst_type
FROM jobdep 
RIGHT OUTER JOIN jobdata jobdata ON jobdata.jobmst_id = jobdep.jobmst_id 
LEFT OUTER JOIN jobdata jobdata_1 ON jobdata_1.jobmst_id = jobdep.jobdep_jobmst 
where jobdata.version = 0  and (jobdata_1.version = 0 or jobdata_1.version is null) and not jobdata.jobmst_dirty = 'X'
]]>
        </querytext_sqlserver>
             
        <querytext_oracle>
            <![CDATA[
SELECT 
jobdata.jobmst_type,
jobdata.jobmst_prntid,
jobdata.jobmst_active,
jobdep.jobdep_id as id,
jobdata.jobmst_id as jobid, 
jobdep.jobdep_jobmst as depjobid,
jobdep.jobdep_joblogic condition, 
jobdep.nodmst_id as connectionid, 
jobdep.nodmst_name as connectionname,
jobdep.jobdep_dateoffset as dateoffset, 
jobdata_1.jobname as depjobname, 
jobdata_1.jobgroup as depjobparent, 
jobdata_1.jobtype as depjobtype,
jobdep.jobdep_value as depjobvalue,
jobdep.jobdep_fileextent as fileextent, 
jobdep.jobdep_filename as filename, 
jobdep.jobdep_filetype as filetype, 
jobdep.jobdep_canignore as ignoredep, 
rtrim(jobdep.jobdep_ingroup) as ingroup, 
jobdep.jobdep_instoffset as instanceoffset,
jobdata.jobmst_id, 
jobdata.jobname as jobname, 
jobdata.jobmst_owner as ownerid, 
jobdep.jobdep_keepmetifready as keepmetifready, 
jobdep.jobdep_lstchgtm as lastchangetime,
jobdep.jobdep_usrmodtm as lastusermodifiedtime, 
jobdep.jobdep_joblogic as logic, 
jobdep.nodmst_id as nodeid, 
jobdep.jobdep_filetype occurrence, 
jobdep.jobdep_operator as operator, 
jobdep.jobdep_value as procstep,
jobdep.jobdep_status as status, 
jobdep.jobdep_type as type, 
jobdep.varmst_id as variableid, 
jobdep.varmst_name as variablename, 
jobdep.jobdep_value as varvalue,
jobdata.jobname jobmst_name, 
jobdata.jobgroup as jobmst_prntname, 
 jobdata_1.fromtime jobdtl_until_time,
 jobdata_1.untiltime jobdtl_until_time, 
 CASE WHEN jobdep_joblogic = 1 THEN 'All' WHEN jobdep_joblogic = 2 THEN 'One' ELSE '' END  DepLogic, 
 jobdep_id id, 
 jobdep_type type, 
 jobdep_filetype occurrence, 
coalesce(jobdata.fromtime,'00:00')  jobdtl_fromtm_hhmm,
case when not jobdata.servicemst_name is null then jobdata.servicemst_name when jobdata.jobmst_type = 1 then 'G' when jobdata.jobmst_type = 2 then 'J'  when jobdata.jobmst_type = 6 then 'F' when jobdata.jobmst_type = 8 then 'A' else '?' end jobmst_type
FROM jobdep 
RIGHT OUTER JOIN jobdata jobdata ON jobdata.jobmst_id = jobdep.jobmst_id 
LEFT OUTER JOIN jobdata jobdata_1 ON jobdata_1.jobmst_id = jobdep.jobdep_jobmst 
where jobdata.version = 0  and (jobdata_1.version = 0 or jobdata_1.version is null)
]]>
        </querytext_oracle>
    </query>




    <query>
        <queryname>9702H All JobRuns dependency data per production day</queryname>
        <querytotals></querytotals>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <cachetimeout>300</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobrun.jobmst_id, 
  jobrun.jobmst_name,
  len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) level,
  coalesce(jobrun.jobmst_prntid,0) jobmst_prntid,
  jobrun.jobrun_prntid,
  case  when jobrun.jobrun_status < 50  then (SELECT Max(v) FROM (VALUES (getdate()), (jobrun_esttime)) AS value(v)) else  coalesce(jobrun_time,jobrun_esttime) end  jobrun_time,
CASE
    WHEN jobrun_status = 101     THEN 100
    WHEN jobrun_status = 51 then (datediff(second,
	case  when jobrun.jobrun_status < 50 and coalesce(jobrun_time,jobrun_esttime) < getdate()  then getdate() else  coalesce(jobrun_time,jobrun_esttime) end,
	getdate()
	 ) / (jobrun_estduration + 1)) * 100
    ELSE 0
  END PctComplete,
  jobrun.jobrun_cmd,
  substring(jobrun.jobrun_joboutput,1,1000) joboutput,
  dateadd(ss, coalesce(jobrun_duration, jobrun_estduration), 
    case  when jobrun.jobrun_status < 50  then (SELECT Max(v) FROM (VALUES (getdate()), (jobrun_esttime)) AS value(v)) else  coalesce(jobrun_time,jobrun_esttime) end) jobrun_endtime,
  coalesce(jobrun.jobmst_prntname,'') jobmst_prntname,
  jobrun.jobmst_type,
  jobrun.nodmst_name,
  coalesce(CONVERT(VARCHAR(5),jobrun.jobrun_fromtm,108),'') jobrun_fromtm_hhmm,
  jobrun.jobrun_fromtm, 
  jobrun.jobrun_ignoretime,
  case when jobrun.jobrun_deplogic = 1 then 'All'  when jobrun_deplogic = 2 then 'One' else '' end DepLogic,
  jobrun.jobrun_status status_code,
  convert(varchar(4000), coalesce(jobrun.jobrun_deps,'')) deps, rtrim(JOBRUNSTATUS.statusname) jobrun_status ,
  coalesce(jobrun.jobrun_orgstatus,'') jobrun_orgstatus,
  jobrun_successors
 from jobrun, jobrunstatus with (nolock)
  where 
  (jobrun_proddt = '<<prod_date>>' or '<<prod_date>>' = '')
   and jobrun.jobrun_status = JOBRUNSTATUS.statusid
  and datediff(hour,getdate(), coalesce(jobrun_time,jobrun_esttime)) < 96
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobrun_id,
  jobrun.jobmst_id,
  jobrun.jobmst_name,
  LENGTH(COALESCE(jobmst_prntname,' ')) - LENGTH(REPLACE(COALESCE(jobmst_prntname,' '),'\',' ')) "level",
  COALESCE(jobrun.jobmst_prntid,0) jobmst_prntid,
  jobrun.jobrun_prntid,
  CASE
    WHEN jobrun.jobrun_status                < 50
    AND COALESCE(jobrun_time,jobrun_esttime) < sysdate
    THEN sysdate
    ELSE COALESCE(jobrun_time,jobrun_esttime)
  END jobrun_time,
  CASE
    WHEN jobrun_status = 101     THEN 100
    WHEN jobrun_status = 51 then (((sysdate - jobrun_time) * (24*60*60) ) / (jobrun_estduration + 1)) * 100
    ELSE 0
  END "PctComplete",
  jobrun.jobrun_cmd,
  substr(jobrun.jobrun_joboutput,1,1000) joboutput,
  COALESCE(jobrun_time,jobrun_esttime) + numToDSInterval( COALESCE(jobrun_duration, jobrun_estduration,0), 'second' ) jobrun_endtime,
  --coalesce(jobrun_time,jobrun_esttime) + interval cast(coalesce(jobrun_duration, jobrun_estduration,'0') as varchar(20)) second jobrun_endtime,
  --dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_time,jobrun_esttime)) jobrun_endtime,
  COALESCE(jobrun.jobmst_prntname,' ') jobmst_prntname,
  jobrun.jobmst_type,
  jobrun.nodmst_name,
  COALESCE(TO_CHAR(jobrun.jobrun_fromtm,'HH24.mi'),' ') jobrun_fromtm_hhmm,
  jobrun.jobrun_fromtm,
  jobrun.jobrun_ignoretime,
  CASE
    WHEN jobrun.jobrun_deplogic = 1
    THEN 'All'
    WHEN jobrun_deplogic = 2
    THEN 'One'
    ELSE ''
  END "DepLogic",
  jobrun.jobrun_status status_code,
  COALESCE(CAST(substr(jobrun.jobrun_deps,1,4000) AS VARCHAR(4000)),'') deps,
  COALESCE(CAST(substr(jobrun.jobrun_deps,4001,4000) AS VARCHAR(4000)),'') deps2,
  statusname jobrun_status ,
  COALESCE(CAST(jobrun.jobrun_orgstatus AS VARCHAR(2000)),'') jobrun_orgstatus,
  cast(jobrun_successors as varchar(4000)) jobrun_successors
FROM jobrun,
  jobdata,
  jobrunstatus
WHERE (jobrun_proddt = to_date('<<prod_date>>','yyyy-mm-dd')
OR '<<prod_date>>'   = '')
  --(jobrun_proddt = to_date('2018-07-15','yyyy-mm-dd')  or '2018-12-01' = '')
AND jobrun.jobrun_status                                   = statusid
AND jobrun.jobmst_id                                       = jobdata.jobmst_id
AND jobdata.version                                        = 0
AND sysdate - COALESCE(jobrun_time,jobrun_esttime,sysdate) < 365 
]]>
        </querytext_oracle>
    </query>

        <query>
        <queryname>9703H Jobrun Summary Average Waiting for Resource</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields>Agent,ProdDate,WaitingOnResource</chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
select proddt ProdDate, count(*) Jobs, avg(DATEDIFF(ss,WaitingonResource,Active)) WaitingOnResource, avg(DATEDIFF(ss,Launched,Active)) Launched, Queue,Agent from JOBRUN_STATUS_SUMMARY where  not WaitingonResource is null and not Launched is null
and Proddt between  '<<from_date>>' and '<<to_date>>'
group by ProdDt, queue, agent
order by ProdDt, Agent
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT proddt "ProdDate",
  COUNT(*) Jobs,
  AVG((Active - WaitingonResource) *24*60*60) WaitingOnResource,
  AVG((Active - Launched)*24*60*60) Launched,
  Queue,
  Agent
FROM JOBRUN_STATUS_SUMMARY
WHERE NOT WaitingonResource IS NULL
AND NOT Launched            IS NULL
--AND Proddt BETWEEN to_date('2018-12-01','yyyy-mm-dd') AND to_date('2018-12-05','yyyy-mm-dd')
and Proddt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND to_date('<<to_date>>','yyyy-mm-dd')
GROUP BY ProdDt,
  queue,
  agent
ORDER BY ProdDt,
  Agent
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>9704H Jobrun Summary Waiting for Launched</queryname>
        <querytotals></querytotals>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT *
FROM
  (SELECT jobdata.JobGroup,
    JobName,
    JOBRUN_STATUS_SUMMARY.jobrun_id,
    ReRun,
    COALESCE(DATEDIFF(ss,launched,active),0) Lauched_Status_time,
    COALESCE(DATEDIFF(ss,active,COALESCE(CompletedNormally,CompletedAbnormally)),0) Active_Status_time,
    FinalStatus ,
    jobrun.jobrun_orgstatus,
    jobrun.nodmst_name Agent,
    Queue,
    Owner,
    ProdDt,
    jobrun.quemst_id,
    jobrun_duration
  FROM JOBRUN_STATUS_SUMMARY
  JOIN jobrun
  ON jobrun.jobrun_id = JOBRUN_STATUS_SUMMARY.JOBRUN_ID
  JOIN jobdata
  ON jobrun.jobmst_id = jobdata.jobmst_id
  AND jobdata.version = 0
  WHERE type          > 1
  AND Proddt BETWEEN '<<from_date>>' AND '<<to_date>>'
  ) s1
WHERE Lauched_Status_time > <<lauchtime_seconds:10>>
ORDER BY jobrun_id,
  rerun,
  Lauched_Status_time DESC
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT *
FROM
  (SELECT jobdata.JobGroup,
    JobName,
    JOBRUN_STATUS_SUMMARY.JOBRUN_ID,
    ReRun,
   (Active - Launched)*24*60*60 Lauched_Status_time,
   (COALESCE(CompletedNormally,CompletedAbnormally) - Active)*24*60*60 Active_Status_time,
    FinalStatus ,
    jobrun.jobrun_orgstatus,
    jobrun.nodmst_name Agent,
    Queue,
    Owner,
    ProdDt,
    jobrun.quemst_id,
    jobrun_duration
  FROM JOBRUN_STATUS_SUMMARY
  JOIN jobrun
  ON jobrun.jobrun_id = JOBRUN_STATUS_SUMMARY.JOBRUN_ID
  JOIN jobdata
  ON jobrun.jobmst_id = jobdata.jobmst_id
  AND jobdata.version = 0
  WHERE type          > 1
  AND Proddt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND to_date('<<to_date>>','yyyy-mm-dd')
  ) s1
WHERE Lauched_Status_time > <<lauchtime_seconds:10>>
ORDER BY jobrun_id,
  rerun,
  Lauched_Status_time DESC
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>ConnectionAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     (msglog.msglog_category = 3) and msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     (msglog.msglog_category = 3) and 
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd')
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     (msglog.msglog_category = 3) and msglog.msglog_crtdt >= DateTime('<<from_date>>')  and msglog.msglog_crtdt <= DateTime('<<to_date>> 23:59:59')
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>JobAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, jobname, jobgroup, msglog.nodmst_name, msglog.usrmst_name , jobmst_desc
     --, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog , jobdata
      WHERE     msglog.msglog_category in (10,33) and msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
       msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name:%>>' and (jobdata.jobmst_id = <<jobmst_id:0>> or <<jobmst_id:0>> = 0)))
           )
      and ((msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0)) 
      order by   msglog.msglog_crtdt desc
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog 
      WHERE     msglog.msglog_category in (10,33) and msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and (to_date('<<to_date>>','yyyy-mm-dd') + 1)
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name>>'))
           )
      order by   msglog.msglog_crtdt
      ]]>
        
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     msglog.msglog_category in (10,33) and msglog.msglog_source=2 and msglog.msglog_crtdt >= Datetime('<<from_date>>')  and msglog.msglog_crtdt <= Datetime('<<to_date>> 23:59:59')
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>JobDisabled</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
          
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog 
      WHERE    msglog_text like 'Modified Job%Active:%Y%=>%N%' and  msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
       msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name>>'))
           )
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog 
      WHERE     msglog_text like 'Modified Job%Active:%Y%=>%N%' and msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and (to_date('<<to_date>>','yyyy-mm-dd') + 1)
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name>>'))
           )
      order by   msglog.msglog_crtdt
      ]]>
        
        </querytext_oracle>



</query>
    <query>
        <queryname>JobEnabled</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
          
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog 
      WHERE    msglog_text like 'Modified Job%Active:%N%=>%Y%' and  msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
       msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name>>'))
           )
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
     SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name, msglog.msglog_category, msglog.msglog_source , msglog_type
      FROM         msglog 
      WHERE     msglog_text like 'Modified Job%Active:%N%=>%Y%' and msglog.msglog_source=2 and msglog.msglog_subcategory in (2,3,4) and
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and (to_date('<<to_date>>','yyyy-mm-dd') + 1)
      and (
           (msglog.jobmst_id in (select jobmst_id from jobdata where jobdata.version=0 and jobname like '<<job_name>>'))
           )
      order by   msglog.msglog_crtdt
      ]]>
        
        </querytext_oracle>



</query>
    <query>
        <queryname>AlertAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
     select * from alrtmst where alrtmst_lstchgtm >= '<<from_date>>'  and alrtmst_lstchgtm <= '<<to_date>> 23:59:59'
      order by   alrtmst_id, alrtmst_lstchgtm
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
     select * from alrtmst where
     alrtmst_lstchgtm between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd')
     order by   alrtmst_id, alrtmst_lstchgtm
      ]]>
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     
      ]]>
        </querytext_sqlite>
    </query>
    
     <query>
        <queryname>JobRunAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields>jobrun_proddt,jobrun_duration</chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
     SELECT        JOBRUN.jobrun_id, JOBRUN.jobmst_prntname, JOBRUN.jobmst_name, JOBRUN.jobmst_id, JOBRUN.jobrun_joboutput, JOBRUN.jobrun_proddt, JOBRUNSTATUS.statusname, CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, jobrun_duration 
FROM            JOBRUN INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
 where  (((JOBRUN.jobmst_name like '<<job_name>><<%>>') and (coalesce(jobrun.jobmst_prntname,'') like '<<job_group:%>>') and ('<<jobmst_id:0>>' = '0' )) 
  or JOBRUN.jobmst_id = '<<jobmst_id:0>>') 
           and (jobrun_proddt >= '<<from_date>>'  and jobrun_proddt <= '<<to_date>>')
order by jobrun.jobrun_id
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT JOBRUN.jobrun_id,
  JOBRUN.jobmst_prntname,
  JOBRUN.jobmst_name,
  JOBRUN.jobmst_id,
  JOBRUN.jobrun_joboutput,
  JOBRUN.jobrun_proddt,
  JOBRUNSTATUS.statusname,
  TO_CHAR(to_date(COALESCE(jobrun_duration,0),'sssss'),'hh24:mi:ss') Duration,
  jobrun_duration
FROM JOBRUN
INNER JOIN JOBRUNSTATUS
ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE (((JOBRUN.jobmst_name LIKE '%')
AND (COALESCE(jobrun.jobmst_prntname,' ') LIKE '<<job_group:%>>')
AND ('0'            = '0' ))
OR JOBRUN.jobmst_id = '0')
and (jobrun_proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd'))
AND jobrun_duration < 86399
ORDER BY jobrun.jobrun_id
      ]]>
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>AlertHistory</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>alerts</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT distinct  ALRTMST.alrtmst_id, ALRTMST.jobrun_id, ALRTMST.alrtmst_time,
 cast(ALRTMST.alrtmst_desc as varchar(1000)) Description ,
 case ALRTMST.alrtmst_state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus,
 ALRTMST.usrmst_fullname, JOBDATA.jobmst_id, JOBDATA.JobName, JOBDATA.JobGroup, JOBRUN_STATUS_SUMMARY.CurrentStatus,
 cast(ALRTMST.alrtmst_resp as varchar(1000)) Response , ALRTMST.alrtmst_respuser, ALRTMST.usrmst_name
FROM 
 ALRTMST INNER JOIN
         JOBDATA ON ALRTMST.jobmst_id = JOBDATA.jobmst_id 
 INNER JOIN
         JOBRUN_STATUS_SUMMARY ON ALRTMST.jobrun_id = JOBRUN_STATUS_SUMMARY.jobrun_id
            where ALRTMST.alrtmst_time >= '<<from_date>>' and ALRTMST.alrtmst_time <= '<<to_date>> 23:59:59' and
                  (alrtmst.jobmst_id in(<<jobid:0>>) or '<<jobid:0>>' = '0') and jobdata.version = 0
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT distinct  ALRTMST.alrtmst_id, ALRTMST.jobrun_id, ALRTMST.alrtmst_time,
 cast(ALRTMST.alrtmst_desc as varchar(1000)) Description ,
 case ALRTMST.alrtmst_state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus,
 ALRTMST.usrmst_fullname, JOBDATA.jobmst_id, JOBDATA.JobName, JOBDATA.JobGroup, JOBRUN_STATUS_SUMMARY.CurrentStatus,
 cast(ALRTMST.alrtmst_resp as varchar(1000)) Response , ALRTMST.alrtmst_respuser, ALRTMST.usrmst_name
FROM 
 ALRTMST INNER JOIN
         JOBDATA ON ALRTMST.jobmst_id = JOBDATA.jobmst_id 
 INNER JOIN
         JOBRUN_STATUS_SUMMARY ON ALRTMST.jobrun_id = JOBRUN_STATUS_SUMMARY.jobrun_id
            where ALRTMST.alrtmst_time between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') and
                  (alrtmst.jobmst_id in(<<jobid:0>>) or '<<jobid:0>>' = '0') and jobdata.version = 0
      ]]>
        
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>OpenAlerts</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>alerts</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT distinct  ALRTMST.alrtmst_id, ALRTMST.jobrun_id, ALRTMST.alrtmst_time,
 cast(ALRTMST.alrtmst_desc as varchar(1000)) Description ,
 case ALRTMST.alrtmst_state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus,
 ALRTMST.usrmst_fullname, JOBDATA.jobmst_id, JOBDATA.JobName, JOBDATA.JobGroup, JOBRUN_STATUS_SUMMARY.CurrentStatus,
 cast(ALRTMST.alrtmst_resp as varchar(1000)) Response , ALRTMST.alrtmst_respuser, ALRTMST.usrmst_name
FROM 
 ALRTMST INNER JOIN
         JOBDATA ON ALRTMST.jobmst_id = JOBDATA.jobmst_id 
 INNER JOIN
         JOBRUN_STATUS_SUMMARY ON ALRTMST.jobrun_id = JOBRUN_STATUS_SUMMARY.jobrun_id
            where ALRTMST.alrtmst_state in(1,2) and ALRTMST.alrtmst_time >= '<<from_date>>' and ALRTMST.alrtmst_time <= '<<to_date>> 23:59:59' and
                  (alrtmst.jobmst_id in(<<jobid:0>>) or '<<jobid:0>>' = '0') and jobdata.version = 0
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT distinct  ALRTMST.alrtmst_id, ALRTMST.jobrun_id, ALRTMST.alrtmst_time,
 cast(ALRTMST.alrtmst_desc as varchar(1000)) Description ,
 case ALRTMST.alrtmst_state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus,
 ALRTMST.usrmst_fullname, JOBDATA.jobmst_id, JOBDATA.JobName, JOBDATA.JobGroup, JOBRUN_STATUS_SUMMARY.CurrentStatus,
 cast(ALRTMST.alrtmst_resp as varchar(1000)) Response , ALRTMST.alrtmst_respuser, ALRTMST.usrmst_name
FROM 
 ALRTMST INNER JOIN
         JOBDATA ON ALRTMST.jobmst_id = JOBDATA.jobmst_id 
 INNER JOIN
         JOBRUN_STATUS_SUMMARY ON ALRTMST.jobrun_id = JOBRUN_STATUS_SUMMARY.jobrun_id
            where ALRTMST.alrtmst_state in(1,2) and ALRTMST.alrtmst_time between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd') and
                  (alrtmst.jobmst_id in(<<jobid:0>>) or '<<jobid:0>>' = '0') and jobdata.version = 0
      ]]>
        
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>Alerts</queryname>
        <db>admiral</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields></chartfields>
        <category>alerts</category>
        <linkquery></linkquery><querydescription>Alerts, open and recently closed</querydescription>
        <cachetimeout>10</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
SELECT top 1000 case state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus
	,[id] alrtmst_id
      ,[description]
      ,[jobname]
      ,[jobid] jobmst_id
      ,[jobrunid] jobrun_id
      ,[response]
	  ,strmst_desc jobrun_status
      ,[lastchangetime]
      ,[responsetime]
	  ,usrmst_name
      ,[time]
  FROM alert_view
  left join usrmst  on responseuser = usrmst.usrmst_id
  join strmst on  jobrunstatus = strmst_id and strmst_type = '7' and strmst_id = jobrunstatus
  where state in (1,2) or (state = 3 and lastchangetime > DATEADD(Minute,-5,SYSDATETIME()))
  order by state, id 
        ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT case state when 1 then 'Open' when 2 then 'Acknowledged' when 3 then 'Closed' end AlertStatus
	,[id]
	,id  '$$treelevel'
      ,[description]
      ,[jobname]
      ,[jobid] jobmst_id
      ,[jobrunid] jobrun_id
      ,[jobrunstatus] 
	  ,strmst_desc
      ,[lastchangetime]
      ,[response]
      ,[responsetime]
      ,[responseuser]
	  ,usrmst_name
      ,[time]
      ,[type]
  FROM alert_view
  left join usrmst  on responseuser = usrmst.usrmst_id
  join strmst on  jobrunstatus = strmst_id and strmst_type = '7' and strmst_id = jobrunstatus
  where state in(1,2) 
  order by state, id
      ]]>
        
        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
     
      ]]>
        </querytext_sqlite>
    </query>
    <query>
      <queryname>Alerts with JobrunInfo</queryname>
      <db>admiral</db>
      <queryfields></queryfields>
      <chartfields></chartfields>
      <category>alerts</category>
      <linkquery></linkquery><querydescription>Alerts,selected by date range</querydescription>
      <cachetimeout>10</cachetimeout>
      <querytext_sqlserver>
          <![CDATA[
          SELECT ALRTMST.alrtmst_id, ALRTMST.alrtmst_type, ALRTMST.alrtmst_time, ALRTMST.alrtmst_desc, CASE ALRTMST.alrtmst_state WHEN 1 THEN 'Open' WHEN 2 THEN 'Acknowledged' WHEN 3 THEN 'Closed' END AS AlertStatus, 
          ALRTMST.alrtmst_resp, ALRTMST.jobmst_id,  job_view.name, job_view.parentname, strmst_desc jobrun_status, alrtmst.jobrun_id, jobrun.jobrun_status
FROM            ALRTMST INNER JOIN
          job_view ON ALRTMST.jobmst_id = job_view.id 
left outer JOIN JOBRUN ON ALRTMST.jobrun_id = JOBRUN.jobrun_id
left outer JOIN strmst on jobrun_status = strmst.strmst_id and strmst_type = 7
WHERE ALRTMST.alrtmst_time >= '<<from_date>>' and ALRTMST.alrtmst_time <= '<<to_date>> 23:59:59' and jobrun.jobrun_status in (103,66)
      ]]>
      </querytext_sqlserver>
      <querytext_oracle>
          <![CDATA[
          SELECT ALRTMST.alrtmst_id, ALRTMST.alrtmst_type, ALRTMST.alrtmst_time, ALRTMST.alrtmst_desc, CASE ALRTMST.alrtmst_state WHEN 1 THEN 'Open' WHEN 2 THEN 'Acknowledged' WHEN 3 THEN 'Closed' END AS AlertStatus, 
          ALRTMST.alrtmst_resp, ALRTMST.jobmst_id,  JOBDATA.jobname, JOBDATA.jobgroup, statusname JOBRUN_STATUS
FROM            ALRTMST INNER JOIN
          JOBDATA ON ALRTMST.jobmst_id = JOBDATA.jobmst_id 
left outer JOIN JOBRUN ON ALRTMST.jobrun_id = JOBRUN.jobrun_id
left outer JOIN jobrunstatus on jobrun_status = JOBRUNSTATUS.ID
         WHERE        (JOBDATA.version = 0) and ALRTMST.alrtmst_time >= '<<from_date>>' and ALRTMST.alrtmst_time <= '<<to_date>> 23:59:59'

    ]]>
      
      </querytext_oracle>
      <querytext_sqlite>
          <![CDATA[
   
    ]]>
      </querytext_sqlite>
  </query>
  
    <query>
        <queryname>UserAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
 SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     (msglog.msglog_category in(16,45)) and msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
     
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
         SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
              FROM         msglog
              WHERE     (msglog.msglog_category in(16,45)) and 
              msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd')
              order by   msglog.msglog_crtdt
              ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>ActionAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     (msglog.msglog_category in(6,27)) and 
      msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     (msglog.msglog_category in(6,27)) and 
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and (to_date('<<to_date>>','yyyy-mm-dd') + 1)
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>EventAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     (msglog.msglog_category in(9,28)) and msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     (msglog.msglog_category in(9,28)) and 
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and (to_date('<<to_date>>','yyyy-mm-dd') + 1)
      order by   msglog.msglog_crtdt
      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>ResourceAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT msglog.msglog_crtdt,
  msglog.msglog_text,
  msglog.nodmst_name,
  msglog.usrmst_name
FROM msglog
WHERE (msglog.msglog_category IN(13))
AND msglog.msglog_crtdt       >= '<<from_date>>'
AND msglog.msglog_crtdt       <= '<<to_date>> 23:59:59'
ORDER BY msglog.msglog_crtdt

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT msglog.msglog_crtdt,
  msglog.msglog_text,
  msglog.nodmst_name,
  msglog.usrmst_name
FROM msglog
WHERE (msglog.msglog_category IN(13))
AND msglog.msglog_crtdt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND (to_date('<<to_date>>','yyyy-mm-dd') + 1)
ORDER BY msglog.msglog_crtdt

      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>VariableAudit</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT msglog.msglog_crtdt,
  msglog.msglog_text,
  msglog.nodmst_name,
  msglog.usrmst_name
FROM msglog
WHERE (msglog.msglog_category IN(17))
AND msglog.msglog_crtdt       >= '<<from_date>>'
AND msglog.msglog_crtdt       <= '<<to_date>> 23:59:59'
ORDER BY msglog.msglog_crtdt

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT msglog.msglog_crtdt,
  msglog.msglog_text,
  msglog.nodmst_name,
  msglog.usrmst_name
FROM msglog
WHERE (msglog.msglog_category IN(17))
AND msglog.msglog_crtdt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND (to_date('<<to_date>>','yyyy-mm-dd') + 1)
ORDER BY msglog.msglog_crtdt
      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>JobCompletionStatus</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields>FinalStatus,ProdDt,cnt</chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT        CONVERT(varchar(10), JOBRUN_STATUS_SUMMARY.ProdDt, 120) AS ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus, COUNT(*) AS cnt
FROM            JOBRUN_STATUS_SUMMARY INNER JOIN
                         JOBDATA ON JOBRUN_STATUS_SUMMARY.jobmst_id = JOBDATA.jobmst_id
WHERE        (JOBRUN_STATUS_SUMMARY.Type > 1) AND (NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL) and proddt >= '<<from_date>>'  and proddt < '<<to_date>> 23:59:59')
      and JOBDATA.JobName like '<<job>>' and JOBDATA.JobGroup like '\<<jobgroup>>'
      and JOBDATA.version = 0
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT     to_char(JOBRUN_STATUS_SUMMARY.proddt, 'yyyy-mm-dd') "ProdDate",
JOBRUN_STATUS_SUMMARY.FinalStatus, COUNT(*) AS cnt
FROM            JOBRUN_STATUS_SUMMARY INNER JOIN
                         JOBDATA ON JOBRUN_STATUS_SUMMARY.jobmst_id = JOBDATA.jobmst_id
WHERE        (JOBRUN_STATUS_SUMMARY.Type > 1) AND
(NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL) 
        and proddt between to_date('<<from_date>>','yyyy-mm-dd')  and to_date('<<to_date>>','yyyy-mm-dd')
        --and proddt between to_date('2018-12-07','yyyy-mm-dd')  and to_date('2018-12-09','yyyy-mm-dd')
        )
      and JOBDATA.JobName like '<<job>>' and JOBDATA.JobGroup like '\<<jobgroup>>'
      and JOBDATA.version = 0
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY "ProdDate", JOBRUN_STATUS_SUMMARY.FinalStatus
      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>JobCompletionStatusbyAgent</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup</queryfields>
        <chartfields>proddt,cnt,finalstatus</chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT    JOBRUN_STATUS_SUMMARY.Agent,  CONVERT(varchar(10), JOBRUN_STATUS_SUMMARY.ProdDt, 120) AS ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus, COUNT(*) AS cnt
FROM            JOBRUN_STATUS_SUMMARY INNER JOIN
                         JOBData ON JOBRUN_STATUS_SUMMARY.jobmst_id = JOBDATA.jobmst_id
WHERE        (JOBRUN_STATUS_SUMMARY.Type > 1) AND (NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL) and proddt >= '<<from_date>>'  and proddt < '<<to_date>> 23:59:59')
and JOBDATA.JobName like '<<job>>' and 
JOBDATA.JobGroup like '\<<jobgroup>>' and jobdata.version = 0
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt, JOBRUN_STATUS_SUMMARY.AGENT,JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY ProdDt, JOBRUN_STATUS_SUMMARY.AGENT, JOBRUN_STATUS_SUMMARY.FinalStatus
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT JOBRUN_STATUS_SUMMARY.Agent,
  TO_CHAR( JOBRUN_STATUS_SUMMARY.proddt, 'yyyy-mm-dd') "ProdDate",
  JOBRUN_STATUS_SUMMARY.FinalStatus,
  COUNT(*) AS cnt
FROM JOBRUN_STATUS_SUMMARY
INNER JOIN JOBData
ON JOBRUN_STATUS_SUMMARY.jobmst_id           = JOBDATA.jobmst_id
WHERE (JOBRUN_STATUS_SUMMARY.Type            > 1)
AND (NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL)
AND proddt BETWEEN to_date('<<from_date>>','yyyy-mm-dd') AND to_date('<<to_date>>','yyyy-mm-dd'))
AND JOBDATA.JobName LIKE '<<job>>'
AND JOBDATA.JobGroup LIKE '\<<jobgroup>>'
AND JOBDATA.version = 0
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt,
  JOBRUN_STATUS_SUMMARY.AGENT,
  JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY "ProdDate",
  JOBRUN_STATUS_SUMMARY.AGENT,
  JOBRUN_STATUS_SUMMARY.FinalStatus

      ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>JobCompletionStatusbyOwner</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate,job,jobgroup,owner</queryfields>
        <chartfields>proddt,cnt,finalstatus</chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
SELECT    JOBRUN_STATUS_SUMMARY.Owner,  CONVERT(varchar(10), JOBRUN_STATUS_SUMMARY.ProdDt, 120) AS ProdDt, JOBRUN_STATUS_SUMMARY.FinalStatus, COUNT(*) AS cnt
FROM            JOBRUN_STATUS_SUMMARY
  INNER JOIN JOBDATA ON JOBRUN_STATUS_SUMMARY.jobmst_id = JOBDATA.jobmst_id
  WHERE (JOBRUN_STATUS_SUMMARY.Type > 1) AND (NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL) and proddt >= '<<from_date>>'  and proddt < '<<to_date>> 23:59:59')
    and JOBDATA.JobName like '<<job>>' and JOBDATA.JobGroup like '\<<jobgroup>>'
    and JOBDATA.version = 0
    and JOBRUN_STATUS_SUMMARY.owner like '<<ownerlist>>'
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt, JOBRUN_STATUS_SUMMARY.Owner,JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY ProdDt, JOBRUN_STATUS_SUMMARY.Owner, JOBRUN_STATUS_SUMMARY.FinalStatus
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT JOBRUN_STATUS_SUMMARY.Owner,
  TO_CHAR( JOBRUN_STATUS_SUMMARY.ProdDt, 'yyyy-mm-dd') "ProdDate",
  JOBRUN_STATUS_SUMMARY.FinalStatus,
  COUNT(*) AS cnt
FROM JOBRUN_STATUS_SUMMARY
INNER JOIN JOBDATA
ON JOBRUN_STATUS_SUMMARY.jobmst_id           = JOBDATA.jobmst_id
WHERE (JOBRUN_STATUS_SUMMARY.Type            > 1)
AND (NOT (JOBRUN_STATUS_SUMMARY.FinalStatus IS NULL)
AND
  proddt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>>','yyyy-mm-dd'))
  --proddt BETWEEN to_date('2018-12-07','yyyy-mm-dd') AND to_date('2018-12-07','yyyy-mm-dd'))
AND JOBDATA.JobName LIKE '<<job>>'
AND JOBDATA.JobGroup LIKE '\<<jobgroup>>'
AND JOBDATA.version = 0
AND JOBRUN_STATUS_SUMMARY.owner LIKE '<<ownerlist>>'
GROUP BY JOBRUN_STATUS_SUMMARY.ProdDt,
  JOBRUN_STATUS_SUMMARY.Owner,
  JOBRUN_STATUS_SUMMARY.FinalStatus
ORDER BY "ProdDate",
  JOBRUN_STATUS_SUMMARY.Owner,
  JOBRUN_STATUS_SUMMARY.FinalStatus
      ]]>
    </querytext_oracle>
    </query>
    <query>
        <queryname>RunVolume - Selected Job Status in timeframe</queryname>
        <db>reporting</db>
        <chartfields>StartDate,JobsActive</chartfields>
        <category>analysis</category> 
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
declare @StartDate datetime = convert(datetime,'<<from_datetime>>:00',126) ,
      @EndTime datetime = convert(datetime,'<<to_datetime>>:00',126),
      @Interval int = <<interval_minutes:15>>
      ;WITH cSequence AS
      (
      SELECT
      @StartDate AS StartDate,
      DATEADD(minute, @Interval, @StartDate) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)

SELECT StartDate, count(jobrun_id) JobsSelected FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.<<SummaryStatus:Active>> > cSequence.StartDate and JOBRUN_STATUS_SUMMARY.<<SummaryStatus:Active>> < cSequence.EndRange
         left outer JOIN jobdata ON JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id
         where (JOBDATA.JobType = 'Job' or JOBDATA.JobType is null) and (jobdata.version = 0 or jobdata.version is null)
		 group by StartDate
     --having count(jobrun_id) > 0
     order by StartDate
     
 OPTION (MAXRECURSION 0);   
    ]]>
        </querytext_sqlserver>
        <querytext_oracle>

            <![CDATA[        
WITH cSequence ("StartDate", "EndRange")  AS
      (
      SELECT
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') "StartDate",
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') + 15/(24*60) "EndRange" from dual
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') "StartDate",
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') + 15/(24*60) "EndRange" from dual
      UNION ALL
      SELECT
      "EndRange",
      15/(24*60) + "EndRange"
      FROM cSequence
      WHERE 15/(24*60) + "EndRange" <
      to_date('<<to_datetime>>', 'yyyy-mm-dd"T"HH24:MI')
      --to_date('2018-12-04 09:30', 'yyyy-mm-dd HH24:MI')
     ) 
SELECT "StartDate", count(jobrun_id) "JobsActive" FROM cSequence
         left outer join JOBRUN_STATUS_SUMMARY  on JOBRUN_STATUS_SUMMARY.Completed > cSequence."StartDate" and JOBRUN_STATUS_SUMMARY.Active < cSequence."EndRange"
         left outer JOIN jobdata ON JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id or JOBRUN_STATUS_SUMMARY.jobmst_id is null
         where (JOBDATA.JobType != 'JobGroup' or JOBDATA.JobType is null) and  (JOBDATA.version = 0  or jobdata.version is null)
		 group by "StartDate"
     order by "StartDate"

    ]]>
            </querytext_oracle>
    </query>

    <query>
        <queryname>RunVolume - Active Jobs in timeframe</queryname>
        <db>reporting</db>
        <chartfields>StartDate,JobsActive</chartfields>
        <category>analysis</category> 
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
declare @StartDate datetime = convert(datetime,'<<from_datetime>>:00',126) ,
      @EndTime datetime = convert(datetime,'<<to_datetime>>:00',126),
      @Interval int = <<interval_minutes:60>>
      ;WITH cSequence AS
      (
      SELECT
      @StartDate AS StartDate,
      DATEADD(minute, @Interval, @StartDate) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)

SELECT StartDate, count(jobrun_id) JobsActive FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.Completed > cSequence.StartDate and JOBRUN_STATUS_SUMMARY.Active < cSequence.EndRange
         left outer JOIN jobdata ON JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id
         where (JOBDATA.JobType = 'Job' or JOBDATA.JobType is null) and (jobdata.version = 0 or jobdata.version is null)
		 group by StartDate
     --having count(jobrun_id) > 0
     order by StartDate
     
 OPTION (MAXRECURSION 0);   
    ]]>
        </querytext_sqlserver>
        <querytext_oracle>

            <![CDATA[        
WITH cSequence ("StartDate", "EndRange")  AS
      (
      SELECT
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') "StartDate",
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') + 15/(24*60) "EndRange" from dual
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') "StartDate",
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') + 15/(24*60) "EndRange" from dual
      UNION ALL
      SELECT
      "EndRange",
      15/(24*60) + "EndRange"
      FROM cSequence
      WHERE 15/(24*60) + "EndRange" <
      to_date('<<to_datetime>>', 'yyyy-mm-dd"T"HH24:MI')
      --to_date('2018-12-04 09:30', 'yyyy-mm-dd HH24:MI')
     ) 
SELECT "StartDate", count(jobrun_id) "JobsActive" FROM cSequence
         left outer join JOBRUN_STATUS_SUMMARY  on JOBRUN_STATUS_SUMMARY.Completed > cSequence."StartDate" and JOBRUN_STATUS_SUMMARY.Active < cSequence."EndRange"
         left outer JOIN jobdata ON JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id or JOBRUN_STATUS_SUMMARY.jobmst_id is null
         where (JOBDATA.JobType != 'JobGroup' or JOBDATA.JobType is null) and  (JOBDATA.version = 0  or jobdata.version is null)
		 group by "StartDate"
     order by "StartDate"

    ]]>
            </querytext_oracle>
    </query>
    <query>
        <queryname>RunVolume - Details - Active Jobs in timeframe</queryname>
        <db>reporting</db> 
        <chartfields></chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>>
        <querytext_sqlserver>
            <![CDATA[
declare @StartDate datetime = convert(datetime,'<<from_datetime>>:00',126) ,
      @EndTime datetime = convert(datetime,'<<to_datetime>>:00',126),
      @Interval int = <<interval_minutes:60>>
      ;WITH cSequence AS
      (
      SELECT
      @StartDate AS StartDate,
      DATEADD(minute, @Interval, @StartDate) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)

SELECT StartDate, jobrun_id,JOBDATA.JobGroup, JOBDATA.JobName, Active, Completed, CurrentStatus, JOBRUN_STATUS_SUMMARY.Agent, ReRun, JOBDATA.JobType,
         DATEDIFF(SS,Active,Completed) Duration,Proddt ProdDate  FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.Completed >= cSequence.StartDate and JOBRUN_STATUS_SUMMARY.Active <= cSequence.EndRange
		left outer JOIN jobdata ON jobdata.version = 0 and JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id
     where (JobType = 'Job' or JobType is null)
     order by StartDate, Active
         ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[        
WITH cSequence ("StartDate", "EndRange")  AS
      (
      SELECT
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') "StartDate",
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') + 15/(24*60) "EndRange" from dual
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') "StartDate",
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') + 15/(24*60) "EndRange" from dual
      UNION ALL
      SELECT
      "EndRange",
      15/(24*60) + "EndRange"
      FROM cSequence
      WHERE 15/(24*60) + "EndRange" <
      to_date('<<to_datetime>>', 'yyyy-mm-dd"T"HH24:MI')
      --to_date('2018-12-04 09:30', 'yyyy-mm-dd HH24:MI')
     ) 
SELECT "StartDate",
  jobrun_id,
  JOBDATA.JOBGROUP "JobGroup",
  JOBDATA.JOBNAME "JobName",
  JOBRUN_STATUS_SUMMARY.ACTIVE "Active",
  JOBRUN_STATUS_SUMMARY.COMPLETED "Completed",
  JOBRUN_STATUS_SUMMARY.CURRENTSTATUS "CurrentStatus",
  JOBRUN_STATUS_SUMMARY.AGENT "Agent",
  RERUN "ReRun",
  JOBDATA.JOBTYPE "JobType",
  (JOBRUN_STATUS_SUMMARY.Completed - JOBRUN_STATUS_SUMMARY.Active)* 24*60*60 "Duration",
  Proddt "ProdDate"
FROM cSequence
LEFT OUTER JOIN JOBRUN_STATUS_SUMMARY
ON JOBRUN_STATUS_SUMMARY.Completed >= cSequence."StartDate"
AND JOBRUN_STATUS_SUMMARY.Active   <= cSequence."EndRange"
LEFT OUTER JOIN jobdata
ON jobdata.version                  = 0
AND JOBRUN_STATUS_SUMMARY.jobmst_id = jobdata.jobmst_id
WHERE (JobType                      = 'Job'
OR JobType                         IS NULL)
ORDER BY "StartDate",
  Active

         ]]>
        </querytext_oracle>

    </query>


    <query>
        <queryname>RunVolumebyAgent - Active Jobs in timeframe</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields>Agent,StartDate,JobsActive</chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <import_oracle>y</import_oracle>
        <querytext_sqlserver>
            <![CDATA[
declare @StartDate datetime = '<<from_date>> 00:00:00',
      @EndTime datetime = '<<to_date>> 23:59:59',
      @Interval int = <<interval_minutes:60>> 

      ;WITH cSequence AS
      (
      SELECT
      @StartDate AS StartDate,
      DATEADD(minute, @Interval, @StartDate) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
SELECT StartDate, coalesce(Agent,'') Agent, count(jobrun_id) JobsActive FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.Completed > cSequence.StartDate and JOBRUN_STATUS_SUMMARY.Active < cSequence.EndRange
         where type > 1
		 group by StartDate, Agent
--having (count(jobrun_id) > 0 or (count(jobrun_id) is null)) 
      order by Agent, StartDate
 OPTION (MAXRECURSION 0);      
 ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[        
WITH cSequence ("StartDate", "EndRange") AS
  (SELECT
    --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') "StartDate",
    --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') + 15/(24*60) "EndRange" from dual
    to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') "StartDate",
    to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') + 15/(24*60) "EndRange"
  FROM dual
  UNION ALL
  SELECT "EndRange",
    15/(24*60) + "EndRange"
  FROM cSequence
  WHERE 15/(24*60) + "EndRange" < to_date('<<to_datetime>>', 'yyyy-mm-dd"T"HH24:MI')
    --to_date('2018-12-04 09:30', 'yyyy-mm-dd HH24:MI')
  )
SELECT "StartDate",
  COALESCE(Agent,'') "Agent",
  COUNT(jobrun_id) "JobsActive"
FROM cSequence
LEFT OUTER JOIN JOBRUN_STATUS_SUMMARY
ON JOBRUN_STATUS_SUMMARY.Completed > cSequence."StartDate"
AND JOBRUN_STATUS_SUMMARY.Active   < cSequence."EndRange"
WHERE (TYPE > 1 or TYPE IS NULL)
GROUP BY "StartDate",
  COALESCE(Agent,'')
  --having (count(jobrun_id) > 0 or (count(jobrun_id) is null))
ORDER BY "Agent",
  "StartDate"

 ]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>RunVolumebyOwner - Active Jobs in timeframe</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields>Owner,StartDate,JobsActive</chartfields>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
declare @StartDate datetime = '<<from_date>> 00:00:00',
      @EndTime datetime = '<<to_date>> 23:59:59',
      @Interval int = <<interval:60>>

      ;WITH cSequence AS
      (
      SELECT
      @StartDate AS StartDate,
      DATEADD(minute, @Interval, @StartDate) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(minute, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(minute, @Interval, EndRange) < @EndTime
)
SELECT StartDate, Owner, count(jobrun_id) JobsActive FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.Completed > cSequence.StartDate and JOBRUN_STATUS_SUMMARY.Active < cSequence.EndRange
         where type > 1
		 group by StartDate, Owner
     --having count(jobrun_id) > 0
      order by Owner, StartDate
 OPTION (MAXRECURSION 0);      
 ]]>
        </querytext_sqlserver>
                <querytext_oracle>
            <![CDATA[        
WITH cSequence ("StartDate", "EndRange")  AS
      (
      SELECT
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') "StartDate",
      --to_date('2018-12-01 08:30', 'yyyy-mm-dd HH24:MI') + 15/(24*60) "EndRange" from dual
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') "StartDate",
      to_date('<<from_datetime>>', 'yyyy-mm-dd"T"HH24:MI') + 15/(24*60) "EndRange" from dual
      UNION ALL
      SELECT
      "EndRange",
      15/(24*60) + "EndRange"
      FROM cSequence
      WHERE 15/(24*60) + "EndRange" <
      to_date('<<to_datetime>>', 'yyyy-mm-dd"T"HH24:MI')
      --to_date('2018-12-04 09:30', 'yyyy-mm-dd HH24:MI')
     )                 
SELECT "StartDate", Owner, count(jobrun_id) "JobsActive" FROM cSequence left outer join JOBRUN_STATUS_SUMMARY  on
         JOBRUN_STATUS_SUMMARY.Completed > cSequence."StartDate" and JOBRUN_STATUS_SUMMARY.Active < cSequence."EndRange"
         where (type > 1 or type is null)
		 group by "StartDate", Owner
     --having count(jobrun_id) > 0
      order by Owner, "StartDate"
 ]]>
        </querytext_oracle>
    </query>
<query>
        <queryname>SystemMessages</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>system</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE     msglog.msglog_crtdt between  '<<from_date>>' and '<<to_date>> 23:59:59' 
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      order by   msglog.msglog_crtdt    desc

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
            SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE    
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      order by   msglog.msglog_crtdt    desc
      ]]>
        </querytext_oracle>

        <querytext_sqlite>
            <![CDATA[
            SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     msglog.msglog_crtdt >= Datetime('<<from_date>>')  and msglog.msglog_crtdt <= Datetime('<<to_date>> 23:59:59')
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      order by   msglog.msglog_crtdt    desc
      ]]>
        </querytext_sqlite>
    </query>
    <query>
        <queryname>MessageLog</queryname>
        <db>admiral</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>system</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
select *,  substring(msglog_text,1,<<chars:24>>) leftpart, reverse(substring(reverse(msglog_text),1,<<chars:24>>)) rightpart , 1 as one from (
	select   [msglog_id]
		  ,[msglog_crtdt]
          ,concat(CONVERT(VARCHAR(20), msglog_crtdt, 111), '_' , FORMAT (msglog_crtdt, 'HH')) crtdt_hour
		  ,[msglog_type]
		  ,[msglog_source]
          ,[msglog_text] msglog_text_orig
		  ,case when q1 > 0 and q2 > 0 then concat(SUBSTRING( msglog_text,1,q1 - 1 ), SUBSTRING(msglog_text,q2 + 1 ,99999) ) else msglog_text end msglog_text
	  from (
		SELECT  [msglog_id]
			  ,[msglog_crtdt]
			  ,[msglog_type]
			  ,[msglog_source]
			  ,CHARINDEX(char(34), msglog_text, 1) q1
			  ,substring(msglog_text,1                                  ,CHARINDEX(char(34), msglog_text, 1) -1) s1
			  ,substring(msglog_text,CHARINDEX(char(34), msglog_text, 1),99999) s2
			  ,[msglog_text] 
			  ,concat(
			  substring(msglog_text,1,CHARINDEX(char(34), msglog_text, 1) -1),
			  substring(msglog_text,CHARINDEX(char(34), msglog_text, CHARINDEX(char(34), msglog_text, 1)) + 1 ,99999)
			  ) msglogtext
			  ,CHARINDEX(char(34), msglog_text, CHARINDEX(char(34), msglog_text, 1) + 1) q2
       
		  FROM [msglog]
		   )  as v1
	  ) as v2
    WHERE     msglog_crtdt between  '<<from_date>>' and '<<to_date>> 23:59:59' 
      order by   msglog_crtdt    desc      
      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
         <![CDATA[
            SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog 
      WHERE    
      msglog.msglog_crtdt between to_date('<<from_date>>','yyyy-mm-dd') and to_date('<<to_date>> 23:59:59','yyyy-mm-dd HH24:MI:SS')
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      order by   msglog.msglog_crtdt    desc
      ]]>
        </querytext_oracle>

        <querytext_sqlite>
            <![CDATA[
            SELECT     msglog.msglog_crtdt, msglog.msglog_text, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog
      WHERE     msglog.msglog_crtdt >= Datetime('<<from_date>>')  and msglog.msglog_crtdt <= Datetime('<<to_date>> 23:59:59')
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      order by   msglog.msglog_crtdt    desc
      ]]>
        </querytext_sqlite>
    </query>


<query>
        <queryname>SystemActivity - last 15 minutes</queryname>
        <db>admiral</db>
        <queryfields></queryfields>
        <chartfields></chartfields>
        <category>system</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
select 1 seq, 'msglog_changes' [Activity Desc] , count(*) cnt from msglog where msglog_crtdt > dateadd(MINUTE,-15, getdate())
union
select 2 seq, 'jobrun_changes' [Activity Desc] , count(*) cnt from jobrun where jobrun.jobrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 3 seq, 'events_changes' [Activity Desc] , count(*) cnt from trgtskrun where trgtskrun.trgtskrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 4 seq, 'jobs gone active' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' [Activity Desc] , count(*) cnt from msglog, jobmst where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Launched%'


      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select 1 seq, 'msglog_changes' ActivityDesc , count(*) cnt from tidal.msglog  where msglog_crtdt > current_timestamp - INTERVAL '15' MINUTE 
union
select 2 seq, 'jobrun_changes' ActivityDesc , count(*) cnt from tidal.jobrun  where jobrun.jobrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 3 seq, 'events_changes' ActivityDesc , count(*) cnt from tidal.trgtskrun  where trgtskrun.trgtskrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 4 seq, 'jobs gone active' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' ActivityDesc , count(*) cnt from tidal.msglog  where msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Launched%'
      ]]>
        </querytext_oracle>

        <querytext_sqlite>
            <![CDATA[
select 1 seq, 'msglog_changes' [Activity Desc] , count(*) cnt from msglog where msglog_crtdt > dateadd(MINUTE,-15, getdate())
union
select 2 seq, 'jobrun_changes' [Activity Desc] , count(*) cnt from jobrun where jobrun.jobrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 3 seq, 'events_changes' [Activity Desc] , count(*) cnt from trgtskrun where trgtskrun.trgtskrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 4 seq, 'jobs gone active' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' [Activity Desc] , count(*) cnt from msglog where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Launched%'
      ]]>
        </querytext_sqlite>
    </query>

    <query>
        <queryname>Check schedule and Counts</queryname>
        <db>admiral</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>system</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
declare @future_days int = <<future_days:3>>;
declare @pct int = 1;
with cte as (SELECT        schmst_comp, schmst_comptime, schmst_schgroups,schmst_schjobs2, schmst_lstcmptm, schmst_proddt,
 DATEDIFF(day,  schmst.schmst_proddt,'20000101') daynum, DATEDIFF(day,  getdate()  ,'20000101') currdaynum
FROM            schmst)
select 'Error! No New Schedule created for:' as 'period' ,getdate() + @future_days schmst_proddt,0 schmst_schjobs2,getdate()+ @future_days schmst_proddt, 0 schmst_schjobs2 ,0 pct  where not DATEDIFF(day,  getdate() + @future_days  ,'20000101') in(select  DATEDIFF(day,  schmst.schmst_proddt  ,'20000101') from schmst  where datediff(day,getdate() + @future_days,'20000101')  =  DATEDIFF(day,  schmst.schmst_proddt  ,'20000101') )
union
select '1 week' as 'period',today.schmst_proddt schmst_proddt,today.schmst_schjobs2 schmst_schjobs2, lastweek.schmst_proddt schmst_proddt,lastweek.schmst_schjobs2 schmst_schjobs2,
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,3)) pct
from cte as today , cte as lastweek 
where today.currdaynum  + 7 = lastweek.daynum and 
DATEDIFF(day,  getdate() ,'20000101') = today.daynum  and
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,3)) > @pct
and not (abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) = 0
union
select '4 week' as 'period',today.schmst_proddt,today.schmst_schjobs2, lastweek.schmst_proddt,lastweek.schmst_schjobs2,
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,2)) pct
from cte as today , cte as lastweek 
where today.daynum  + 28 = lastweek.daynum and 
DATEDIFF(day,  getdate()  ,'20000101') = today.daynum  and
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,2)) > @pct
union
select '12 week' as 'period',today.schmst_proddt,today.schmst_schjobs2, lastweek.schmst_proddt,lastweek.schmst_schjobs2,
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,2)) pct
from cte as today , cte as lastweek 
where today.daynum  + 84 = lastweek.daynum and
DATEDIFF(day,  getdate()  ,'20000101') = today.daynum  and
(abs(lastweek.schmst_schjobs2 - today.schmst_schjobs2)) /CAST(today.schmst_schjobs2 AS DECIMAL (9,2)) > @pct

      ]]>
        </querytext_sqlserver>
                <querytext_oracle>
        </querytext_oracle>

        <querytext_sqlite>
            <![CDATA[

      ]]>
        </querytext_sqlite>
    </query>

    <query>
        <queryname>OperatorActions</queryname>
        <db>reporting</db>
        <queryfields>fromdate,todate</queryfields>
        <chartfields></chartfields>
        <category>audit</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
       SELECT     msglog.msglog_crtdt, msglog.msglog_text, jobdata.jobname Jobname, jobdata.jobgroup Parentname,msglog.OWNER_NAME Ownername, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog , jobdata
      WHERE     
      jobdata.version = 0
      and msglog.msglog_crtdt >= '<<from_date>>'  and msglog.msglog_crtdt <= '<<to_date>> 23:59:59'
       --and ((msglog_type in(2) and msglog_source in(1,6) and msglog_category in(0,11,10) ) or (msglog_type in(2) and msglog_source in(1) and msglog_category in(11,10)))
      and (msglog_subcategory = 5)
      and (msglog.jobmst_id is null  or msglog.jobmst_id = jobdata.jobmst_id)
      order by   msglog.msglog_crtdt    desc

      ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
       SELECT     msglog.msglog_crtdt, msglog.msglog_text, jobdata.jobname Jobname, jobdata.jobgroup Parentname,msglog.OWNER_NAME Ownername, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog , jobdata
      WHERE     
      jobdata.version = 0
      and msglog.msglog_crtdt >= to_date('<<from_date>>','yyyy-mm-dd')  and msglog.msglog_crtdt <= to_date('<<to_date>> 23:59:59', 'yyyy-mm-dd HH24:MI:SS')
       --and ((msglog_type in(2) and msglog_source in(1,6) and msglog_category in(0,11,10) ) or (msglog_type in(2) and msglog_source in(1) and msglog_category in(11,10)))
      and (msglog_subcategory = 5)
      and (msglog.jobmst_id is null  or msglog.jobmst_id = jobdata.jobmst_id)
      order by   msglog.msglog_crtdt    desc

      ]]>

        </querytext_oracle>
        <querytext_sqlite>
            <![CDATA[
       SELECT     msglog.msglog_crtdt, msglog.msglog_text, job.name Jobname, job.parentname Parentname,msglog.OWNER_NAME Ownername, msglog.nodmst_name, msglog.usrmst_name
      FROM         msglog , job
      WHERE     msglog.msglog_crtdt >= Datetime('<<from_date>>')  and msglog.msglog_crtdt <= Datetime('<<to_date>> 23:59:59')
       and ((msglog_type in(2) and msglog_source in(1) and msglog_category in(11,10) ) or (msglog_type in(2) and msglog_source in(1) and msglog_category in(11,10)))
      and (msglog.jobmst_id is null  or msglog.jobmst_id = job.jobmst_id)
      order by   msglog.msglog_crtdt    desc

      ]]>
        </querytext_sqlite>
    </query>

       <query>
        <queryname>ShowSchedule</queryname>
       <db>admiral</db>
        <queryfields></queryfields>
        <chartfields></chartfields>
        <category>system</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT        schmst_proddt, schmst_comp, schmst_comptime, schmst_schgroups, schmst_adhocgroups, schmst_schjobs2, schmst_adhocjobs2, schmst_carryover2, schmst_reruns2, schmst_lstcmptm, 
                         schmst_schgroups + schmst_adhocgroups + schmst_schjobs2 +  schmst_adhocjobs2  +  schmst_reruns2  AS Total
FROM            schmst
ORDER BY schmst_proddt DESC
]]>
        </querytext_sqlserver>
                <querytext_oracle>
            <![CDATA[
SELECT schmst_proddt,
  schmst_comp,
  schmst_comptime,
  schmst_schgroups,
  schmst_adhocgroups,
  schmst_schjobs2,
  schmst_adhocjobs2,
  schmst_carryover2,
  schmst_reruns2,
  schmst_lstcmptm,
  schmst_schgroups + schmst_adhocgroups + schmst_schjobs2 + schmst_adhocjobs2 + schmst_reruns2 AS Total
FROM tidal.schmst
ORDER BY schmst_proddt DESC
]]>
        </querytext_oracle>

    </query>
    <query>
        <queryname>GetJobDependencies</queryname>
       <db>admiral</db>
        <queryfields></queryfields>
        <chartfields></chartfields>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT        jobdep.jobdep_id, jobdep.jobmst_id, jobdep.jobdep_type, jobdep.jobdep_jobmst, jobdep.jobdep_operator, jobdep.jobdep_status, jobdep.jobdep_joblogic, jobdep.jobdep_filename, 
                         jobdep.jobdep_filetype, jobdep.varmst_id, jobdep.jobdep_value, varmst.varmst_name, jobmst.jobmst_type, jobmst.jobmst_prntid, jobmst.jobmst_active, jobmst.jobmst_name, jobmst.jobmst_prntname, 
                         jobdtl.jobdtl_cmd, jobdtl.jobdtl_fromtm, jobdtl.jobdtl_untiltm
FROM            jobdtl INNER JOIN
                         jobmst ON jobdtl.jobdtl_id = jobmst.jobdtl_id LEFT OUTER JOIN
                         jobdep AS jobdep ON jobmst.jobmst_id = jobdep.jobmst_id LEFT OUTER JOIN
                         varmst ON jobdep.varmst_id = varmst.varmst_id
ORDER BY jobdep.jobmst_id
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT jobdep.jobdep_id,
  jobdep.jobmst_id,
  jobdep.jobdep_type,
  jobdep.jobdep_jobmst,
  jobdep.jobdep_operator,
  jobdep.jobdep_status,
  jobdep.jobdep_joblogic,
  jobdep.jobdep_filename,
  jobdep.jobdep_filetype,
  jobdep.varmst_id,
  jobdep.jobdep_value,
  varmst.varmst_name,
  jobmst.jobmst_type,
  jobmst.jobmst_prntid,
  jobmst.jobmst_active,
  jobmst.jobmst_name,
  jobmst.jobmst_prntname,
  jobdtl.jobdtl_cmd,
  jobdtl.jobdtl_fromtm,
  jobdtl.jobdtl_untiltm
FROM tidal.jobdtl
INNER JOIN tidal.jobmst
ON jobdtl.jobdtl_id = jobmst.jobdtl_id
LEFT OUTER JOIN tidal.jobdep  jobdep
ON jobmst.jobmst_id = jobdep.jobmst_id
LEFT OUTER JOIN tidal.varmst
ON jobdep.varmst_id = varmst.varmst_id
ORDER BY jobdep.jobmst_id
]]>
        </querytext_oracle>

    </query>
       <query>
        <queryname>9996 ScopeCounts</queryname>
       <db>admiral</db>
        <queryfields></queryfields>
        <chartfields></chartfields>
        <category>admin</category>
        <linkquery></linkquery>
        <querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
select '1 - master: ' + (select nodmst_alias from nodmst where nodmst_type = 1) source, cast(CONVERT(BIGINT, 0) as varchar)  cnt
union
select '2 - agents enabled: ' source, cast( (select CONVERT(BIGINT, count(*)) from nodmst where nodmst_active = 'y') as varchar) cnt 
union
select '3 - agents disabled: ' source,cast( (select CONVERT(BIGINT, count(*)) from nodmst where nodmst_active = 'n') as varchar) cnt 
union
select '4 - count of jobrun' source ,cast( CONVERT(BIGINT, count(*)) as varchar) cnt from jobrun
union	
select '5 - count of msglog' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt from msglog
union
select '6 - count of joboutput' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt from joboutput
union
select '7 - size of jobrun_outputlen' source, cast(sum(CONVERT(BIGINT, jobrun_outputlen)) as varchar) cnt from joboutput
union
SELECT '8 - count of active jobs ' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt  FROM jobmst WHERE (jobmst_dirty <> 'X' and jobmst_active = 'y')
union
SELECT '9 - count of inactive jobs ' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt FROM jobmst WHERE (jobmst_dirty <> 'X' and not jobmst_active = 'y' )
union
select 'Schedule: ' + format(schmst_proddt,'yyyy-MM-dd') source , 'groups:' + cast(schmst_schgroups as varchar) + ', jobs:' + cast(schmst_schjobs2 as varchar) + ', reruns:' + cast(schmst_reruns2 as varchar) + ', carryover:' +   cast(schmst_carryover2 as varchar) cnt  from schmst where schmst_proddt > CURRENT_TIMESTAMP - 90 ]]>
        </querytext_sqlserver>
                <querytext_oracle>
            <![CDATA[
select '1 - master: ' + (select nodmst_alias from nodmst where nodmst_type = 1) source, cast(CONVERT(BIGINT, 0) as varchar)  cnt
union
select '2 - agents enabled: ' source, cast( (select CONVERT(BIGINT, count(*)) from nodmst where nodmst_active = 'y') as varchar) cnt 
union
select '3 - agents disabled: ' source,cast( (select CONVERT(BIGINT, count(*)) from nodmst where nodmst_active = 'n') as varchar) cnt 
union
select '4 - count of jobrun' source ,cast( CONVERT(BIGINT, count(*)) as varchar) cnt from jobrun
union	
select '5 - count of msglog' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt from msglog
union
select '6 - count of joboutput' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt from joboutput
union
select '7 - size of jobrun_outputlen' source, cast(sum(CONVERT(BIGINT, jobrun_outputlen)) as varchar) cnt from joboutput
union
SELECT '8 - count of active jobs ' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt  FROM jobmst WHERE (jobmst_dirty <> 'X' and jobmst_active = 'y')
union
SELECT '9 - count of inactive jobs ' source, cast(CONVERT(BIGINT, count(*)) as varchar) cnt FROM jobmst WHERE (jobmst_dirty <> 'X' and not jobmst_active = 'y' )
union
select 'Schedule: ' + format(schmst_proddt,'yyyy-MM-dd') source , 'groups:' + cast(schmst_schgroups as varchar) + ', jobs:' + cast(schmst_schjobs2 as varchar) + ', reruns:' + cast(schmst_reruns2 as varchar) + ', carryover:' +   cast(schmst_carryover2 as varchar) cnt  from schmst where schmst_proddt > CURRENT_TIMESTAMP - 90 
]]>
        </querytext_oracle>

    </query>

  <query>
        <queryname>9998 Show rows per table and size of data in table</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
SELECT 
t.Name AS table_name,
p.rows AS row_count,
CAST(ROUND((SUM(a.used_pages) / 128), 0) as varchar(10)) AS used_mb,
CAST(ROUND((SUM(a.total_pages) - SUM(a.used_pages)) / 128, 0) AS varchar(10)) AS unused_mb,
CAST(ROUND((SUM(a.total_pages) / 128), 0) AS varchar(10)) AS total_mb
FROM sys.tables t
INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id
INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
WHERE (
	p.rows > 100
)
GROUP BY t.Name, s.Name, p.Rows
ORDER BY row_count desc, s.Name, t.Name

    </querytext_sqlserver>
        <querytext_oracle>
      SELECT lower(table_name)  AS table_name ,tablespace_name ,num_rows ,blocks*8/1024      AS size_mb ,pct_free ,compression ,logging FROM    all_tables WHERE   owner = 'TIDAL' ORDER BY 3 desc
    </querytext_oracle>
    </query>

  <query>
        <queryname>9999 Delete from TES Reporting DB</queryname>
        <category>admin</category>
        <db>reporting</db>
        <chartfields></chartfields>
         <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
            select 'Done' as Result;
            delete from alrtmst where alrtmst_lstchgtm < DATEADD(Day,-<<days:365>>,GETDATE());
            delete from jobrun where jobrun_lstchgtm < DATEADD(Day,-<<days:365>>,GETDATE());
            delete from jobrun_status_summary where proddt < DATEADD(Day,-<<days:365>>,GETDATE());
            delete from msglog where msglog_crtdt < DATEADD(Day,-<<days:365>>,GETDATE());
            delete from table_size_history where status_date < DATEADD(Day,-<<days:365>>,GETDATE());
            commit;
      
            

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            select 'Done' as Result from dual;
            delete from alrtmst where alrtmst_lstchgtm < (sysdate - <<days:365>>);
            delete from jobrun where jobrun_lstchgtm < (sysdate - <<days:365>>);
            delete from jobrun_status_summary where proddt < (sysdate - <<days:365>>);
            delete from msglog where msglog_crtdt < (sysdate - <<days:365>>);
            delete from table_size_history where status_date < (sysdate - <<days:365>>);
            commit;
]]>

        </querytext_oracle>

    </query>   

  <query>
        <queryname>9997 SYSVAL Values</queryname>
        <category>admin</category>
        <db>admiral</db>
        <chartfields></chartfields>
         <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
            select * from (
select case sysval_id  
when 1 then 'Parameter defines as polling interval in each second for all service jobs to check the connection status'
when 2 then 'Mail type, no mail = 0, SMTP = 5 '
when 3 then 'Sender mail address of the mail id would be defined here'
when 4 then 'It defines in which language logs should be populated'
when 5 then 'This will be used to enable/disable the audit logs. The value can be set as Y or N'
when 6 then 'This id will be used to enable/disable the audit logs for the below functions
* Action Manager
* Agent Manager
* Agent Messenger
* Client
* Dependency Manager
* Fault Tolerance
* Job Manager
* Master
* Queue manager'
when 7 then 'To check the values for System Value diagnostic flags to set ON or OFF.
The possible parameter for System Value diagnostic flags are below,
* Scheduler Log
* ClientManager Log
* AgentManager Log
* Compiler Log
* JobManagerLog
* EventManagerLog
* QueueManagerLog
* DatabaseLog
* CommunicationLog'
when 8 then 'This will be used to save System Value diagnostic flags (Logging level) values in number
Possible System Value diagnostic flags are below,
* Scheduler Log
* ClientManager Log
* AgentManager Log
* Compiler Log
* JobManagerLog
* EventManagerLog
* QueueManagerLog
* DatabaseLog
* CommunicationLog
'
when 9 then 'This parameter would be defined to set the number of days audit logs to be retained'
when 10 then 'This parameter would be defined to set the number of days errors are retain'
when 11 then 'This parameter would be defined to set the number of days the systemValue diagnostic flags (Logging level) are retain'
when 12 then 'Define this parameter to set enable the purge of system history/data'
when 13 then 'To get the last purge status and date'
when 14 then 'This parameter would be defined to set the number of days to define for future compiles'
when 15 then 'No longer used. It is not mandatory, so the value would be 0 as default'
when 16 then 'This is used to mention the company name. The default value is Company Name'
when 17 then 'This parameter would be defined to set the number of days alert message are retain'
when 18 then 'This will be used to mention the password of the mail. But we are not saving this in database'
when 19 then 'This id is used to save the SMTP mail address'
when 20 then 'This is used to save the date of last time calendar had been compiled'
when 21 then 'This will be used to enable/disable the fault tolarance.The value can be set as Y or N'
when 23 then 'Default priority of job'
when 24 then 'It has the below functionality to run the job based on previous instance of jobrun of current job. * Run Anyway ­ Run the job when all previous instance completes with any status * Skip ­ Skip the jobrun until job completes normally.
* Defer until normal ­ Defer the jobrun until the previous instance completes normally.
* Defer until complete ­ Defer the jobrun until the job completes with any status.
'
when 25 then 'It defines the gap that the number of days purge should happen.'
when 26 then 'This will be used to enable/disable the "default unscheduled allowed". The value can be set to Y or N. The default value is Y, so it will allow the adhoc job only. If the value is N it will not allow the adhoc job, it will insert only calendar jobs'
when 27 then 'Sets the public flag default in the Variables, Calendars, Job Events, System Events and Actions dialogs. Public items are available to all the users of Scheduler with an appropriate security policy. The default value is Y. If it is N, it will not allow for all users of Scheduler' 
when 28 then 'Sets the default agent for Connection can be defined in system configuration/connection definition' 
when 34 then 'It is used to save the jobrun output in the following options, * Discard (N value in Database) * Append (Y value in Database) * Replace (R value in Database)'
when 36 then 'Beginning of day ­offset in hours from midnight (production offset)'
when 37 then 'Compile offset from midnight in hours (compile time)'
when 38 then 'Starting day of the week,1=sunday'
when 39 then 'This is used to check the runtime user password to run the jobs. The default value is N. When we enable the password (The value is Y), all runtime user profiles require valid passwords.'
when 40 then 'This will be used to save the last forecasted date.'
when 41 then 'This will be used to enable/disable the carry over option for next day. The value can be set as Y or N. The default value is N, so it will allow carrying over the job to next day'
when 42 then 'Use either master or agent time zone for jobs. Y -­ Relative to Agent N -­ Relative to Master (Default)'
when 43 then 'ITO Adapter  installed, Y or N'
when 63 then 'Database Version'
when 70 then 'This can be defined to mention number of days the job supposed to carryover'
when 79 then 'Save the value to enable\disable the job carry over.0 is Yes(carry over to next day), 1 is No(not carry over)'
when 84 then 'Current product date. Used in carryover options'
when 89 then 'This parameter would be defined to set the number of days needed to expire the triggerActionRun'
when 90 then 'The number of seconds to wait for a connection recovery before sending a lost connection system event'
when 93 then 'Set to Y to rerun on completed normally only'
when 94 then 'Default method of estimating the start time for a job'
when 95 then 'Default course of action for a job to take if it is likely to run into an agent outage window'
when 100 then 'A flag that indicates if the queues are paused, Y or N'
when 102 then 'Option to set the trim options for variable values'
when 112 then 'Recompile calendars when the number of days since the last calendar compile reaches this number. Set to ­-1 to disable automatic calendar recompile'
when 113 then 'Override rerun when time dependency is met for disabled job. Default is (N) and override (Y).'
when 132 then 'Set sysval_string to Y (the default value) to allow the workgroup to assign additional runtime user. When set to N no additonal workgroup runtime user included.'
when 136 then 'Set sysval_string to Y to disable the rerun context menu command from the UI for any job in Aborted status. When set to N (the default value) will keep Rerun context menu command'
end 
config_option,
case sysval_id  
when 1 then '10'
when 2 then '5'
when 3 then ''
when 4 then '1'
when 5 then 'Y'
when 6 then ''
when 7 then ''
when 8 then ''
when 9 then '7'
when 10 then '30'
when 11 then '30'
when 12 then 'Y'
when 13 then ''
when 14 then '3'
when 15 then '0'
when 16 then 'Company Name'
when 17 then '7'
when 18 then ''
when 19 then 'valid SMTP mail address'
when 20 then 'na'
when 21 then 'na'
when 23 then '50'
when 24 then 'Defer until normal'
when 25 then '1'
when 26 then 'Y'
when 27 then 'Y' 
when 28 then '' 
when 34 then 'Append (Y value in Database)'
when 36 then '0'
when 37 then '0'
when 38 then '1'
when 39 then 'N'
when 40 then ''
when 41 then 'Y'
when 42 then 'N'
when 43 then 'N'
when 63 then 'na'
when 70 then '3'
when 79 then '0'
when 84 then 'na'
when 89 then '7'
when 90 then '60'
when 93 then 'Y'
when 94 then ''
when 95 then ''
when 100 then 'na'
when 102 then 'N'
when 112 then '90'
when 113 then 'N'
when 132 then 'Y'
when 136 then 'N'
end 
recommended_value,
coalesce(sysval_string,cast(sysval_integer as varchar) ) actual_value,
sysval_id
 from sysval
 ) res
 where not config_option is null
         

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            select * from (
select case sysval_id  
when 1 then 'Parameter defines as polling interval in each second for all service jobs to check the connection status'
when 2 then 'Mail type, no mail = 0, SMTP = 5 '
when 3 then 'Sender mail address of the mail id would be defined here'
when 4 then 'It defines in which language logs should be populated'
when 5 then 'This will be used to enable/disable the audit logs. The value can be set as Y or N'
when 6 then 'This id will be used to enable/disable the audit logs for the below functions
* Action Manager
* Agent Manager
* Agent Messenger
* Client
* Dependency Manager
* Fault Tolerance
* Job Manager
* Master
* Queue manager'
when 7 then 'To check the values for System Value diagnostic flags to set ON or OFF.
The possible parameter for System Value diagnostic flags are below,
* Scheduler Log
* ClientManager Log
* AgentManager Log
* Compiler Log
* JobManagerLog
* EventManagerLog
* QueueManagerLog
* DatabaseLog
* CommunicationLog'
when 8 then 'This will be used to save System Value diagnostic flags (Logging level) values in number
Possible System Value diagnostic flags are below,
* Scheduler Log
* ClientManager Log
* AgentManager Log
* Compiler Log
* JobManagerLog
* EventManagerLog
* QueueManagerLog
* DatabaseLog
* CommunicationLog
'
when 9 then 'This parameter would be defined to set the number of days audit logs to be retained'
when 10 then 'This parameter would be defined to set the number of days errors are retain'
when 11 then 'This parameter would be defined to set the number of days the systemValue diagnostic flags (Logging level) are retain'
when 12 then 'Define this parameter to set enable the purge of system history/data'
when 13 then 'To get the last purge status and date'
when 14 then 'This parameter would be defined to set the number of days to define for future compiles'
when 15 then 'No longer used. It is not mandatory, so the value would be 0 as default'
when 16 then 'This is used to mention the company name. The default value is Company Name'
when 17 then 'This parameter would be defined to set the number of days alert message are retain'
when 18 then 'This will be used to mention the password of the mail. But we are not saving this in database'
when 19 then 'This id is used to save the SMTP mail address'
when 20 then 'This is used to save the date of last time calendar had been compiled'
when 21 then 'This will be used to enable/disable the fault tolarance.The value can be set as Y or N'
when 23 then 'Default priority of job'
when 24 then 'It has the below functionality to run the job based on previous instance of jobrun of current job. * Run Anyway - Run the job when all previous instance completes with any status * Skip - Skip the jobrun until job completes normally.
* Defer until normal - Defer the jobrun until the previous instance completes normally.
* Defer until complete - Defer the jobrun until the job completes with any status.
'
when 25 then 'It defines the gap that the number of days purge should happen.'
when 26 then 'This will be used to enable/disable the "default unscheduled allowed". The value can be set to Y or N. The default value is Y, so it will allow the adhoc job only. If the value is N it will not allow the adhoc job, it will insert only calendar jobs'
when 27 then 'Sets the public flag default in the Variables, Calendars, Job Events, System Events and Actions dialogs. Public items are available to all the users of Scheduler with an appropriate security policy. The default value is Y. If it is N, it will not allow for all users of Scheduler' 
when 28 then 'Sets the default agent for Connection can be defined in system configuration/connection definition' 
when 34 then 'It is used to save the jobrun output in the following options, * Discard (N value in Database) * Append (Y value in Database) * Replace (R value in Database)'
when 36 then 'Beginning of day -offset in hours from midnight (production offset)'
when 37 then 'Compile offset from midnight in hours (compile time)'
when 38 then 'Starting day of the week,1=sunday'
when 39 then 'This is used to check the runtime user password to run the jobs. The default value is N. When we enable the password (The value is Y), all runtime user profiles require valid passwords.'
when 40 then 'This will be used to save the last forecasted date.'
when 41 then 'This will be used to enable/disable the carry over option for next day. The value can be set as Y or N. The default value is N, so it will allow carrying over the job to next day'
when 42 then 'Use either master or agent time zone for jobs. Y -- Relative to Agent N -- Relative to Master (Default)'
when 43 then 'ITO Adapter  installed, Y or N'
when 63 then 'Database Version'
when 70 then 'This can be defined to mention number of days the job supposed to carryover'
when 79 then 'Save the value to enable\disable the job carry over.0 is Yes(carry over to next day), 1 is No(not carry over)'
when 84 then 'Current product date. Used in carryover options'
when 89 then 'This parameter would be defined to set the number of days needed to expire the triggerActionRun'
when 90 then 'The number of seconds to wait for a connection recovery before sending a lost connection system event'
when 93 then 'Set to Y to rerun on completed normally only'
when 94 then 'Default method of estimating the start time for a job'
when 95 then 'Default course of action for a job to take if it is likely to run into an agent outage window'
when 100 then 'A flag that indicates if the queues are paused, Y or N'
when 102 then 'Option to set the trim options for variable values'
when 112 then 'Recompile calendars when the number of days since the last calendar compile reaches this number. Set to --1 to disable automatic calendar recompile'
when 113 then 'Override rerun when time dependency is met for disabled job. Default is (N) and override (Y).'
when 132 then 'Set sysval_string to Y (the default value) to allow the workgroup to assign additional runtime user. When set to N no additonal workgroup runtime user included.'
when 136 then 'Set sysval_string to Y to disable the rerun context menu command from the UI for any job in Aborted status. When set to N (the default value) will keep Rerun context menu command'
end 
config_option,
case sysval_id  
when 1 then '10'
when 2 then '5'
when 3 then ''
when 4 then '1'
when 5 then 'Y'
when 6 then ''
when 7 then ''
when 8 then ''
when 9 then '7'
when 10 then '30'
when 11 then '30'
when 12 then 'Y'
when 13 then ''
when 14 then '3'
when 15 then '0'
when 16 then 'Company Name'
when 17 then '7'
when 18 then ''
when 19 then 'valid SMTP mail address'
when 20 then 'na'
when 21 then 'na'
when 23 then '50'
when 24 then 'Defer until normal'
when 25 then '1'
when 26 then 'Y'
when 27 then 'Y' 
when 28 then '' 
when 34 then 'Append (Y value in Database)'
when 36 then '0'
when 37 then '0'
when 38 then '1'
when 39 then 'N'
when 40 then ''
when 41 then 'Y'
when 42 then 'N'
when 43 then 'N'
when 63 then 'na'
when 70 then '3'
when 79 then '0'
when 84 then 'na'
when 89 then '7'
when 90 then '60'
when 93 then 'Y'
when 94 then ''
when 95 then ''
when 100 then 'na'
when 102 then 'N'
when 112 then '90'
when 113 then 'N'
when 132 then 'Y'
when 136 then 'N'
end 
recommended_value,
coalesce(sysval_string,cast(sysval_integer as varchar(10)) ) actual_value,
sysval_id
 from tidal.sysval
 ) res
 where not config_option is null
]]>
        </querytext_oracle>

    </query>   

  <query>
        <queryname>orig-9997 SYSVAL Values</queryname>
        <category>hidden</category>
        <db>admiral</db>
        <chartfields></chartfields>
         <linkquery></linkquery><querydescription></querydescription>
        <querytext_sqlserver>
            <![CDATA[
            select * from (
select case sysval_id  
when 1 then 'sysval_poll_interval'
when 2 then 'mail_type, 5 = smtp '
when 3 then 'mail_user'
when 4 then 'log_language'
when 5 then 'audit_on'
when 6 then 'audit_flags(action,agent mgr,agent mess,client,dep mgr,FT,Job Mgr,Master,Queue'
when 7 then 'diag_on'
when 8 then 'diag_flags'
when 9 then 'audit_retain'
when 10 then 'error_retain'
when 11 then 'diag_retain'
when 12 then 'purge_frequency'
when 13 then 'purg_date'
when 14 then 'compile_outlook (future compile)'
when 15 then 'client_port'
when 16 then 'company_name'
when 17 then 'alert_retain'
when 18 then 'mail_password'
when 19 then 'mail_address'
when 20 then 'calendar date(last date calendars compiled)'
when 21 then 'fault tolerance'
when 23 then 'default jobpriority'
when 24 then 'default jobcincur'
when 25 then 'defaulkt jobhistory'
when 26 then 'allow default  unscheduled'
when 27 then 'default public' 
when 28 then 'default agent' 
when 36 then 'begin of day offset'
when 37 then 'comple offset'
when 38 then 'week begins,1=sunday'
when 39 then 'use NT passwords Y/N'
when 41 then 'schedule carryover Y/N'
when 42 then 'agent timezone'
when 43 then 'ito installed'
when 63 then 'database version'
when 70 then 'carryover days'
when 79 then 'default carryover'
when 84 then 'current production day'
when 89 then 'trigger action expire days'
when 90 then 'lost connection wait event(seconds)'
when 93 then 'rerun on completed normally only'
when 94 then 'default method for estimating job start time'
when 100 then 'queues paused'
when 102 then 'trim variables'
when 112 then 'recompile calendars after days , -1=disabled'
when 113 then 'override rerun time dep. for disabled job'
when 132 then 'always carryover active jobs to production date'
when 136 then 'disable rerun for aborted status'
end 
config_option
,sysval_id
,sysval_integer
,sysval_string
,sysval_time
 from sysval
 ) res
            
            

]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>

    </query>   

    <query>
        <queryname>del-dashboardQuery1</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>Errored/Abnormal Jobs</querydescription>
        
        <querytext_sqlserver>
            <![CDATA[
select jobrun.jobrun_id,jobrun.jobmst_id, jobmst.jobmst_name + coalesce( '(' + jobmst.jobmst_prntname +  ')','' )  Job, 
 case jobrun_status when 66 then 'Error Occurred' when 103 then 'Completed Abnormally' end jobrun_status, 
 convert(varchar(250), jobrun.jobrun_lstchgtm, 108)  Time,
 CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate, nodmst_name Agent,
 len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
 jobmst.jobmst_id from jobrun with (nolock)
    join  jobmst on jobrun.jobmst_id = jobmst.jobmst_id
    left join nodmst on jobrun.nodmst_id = nodmst.nodmst_id
  where 
         jobrun.jobrun_lstchgtm >  dateadd(MINUTE,-1440, getdate()) and 
         jobmst.jobmst_type > 1 and jobrun_status in( 66,103) and 
         jobrun.jobrun_rundt = (select sysval_time from sysval where sysval_id = 84)
         order by jobrun.jobrun_lstchgtm desc
         ]]>
        </querytext_sqlserver>
 <querytext_oracle>
            <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id, jobmst.jobmst_name || coalesce('('||jobmst.jobmst_prntname ||')','')   "JobName", 
 case jobrun_status when 66 then 'Error Occurred' when 103 then 'Completed Abnormally' end jobrun_status, 
 to_char( jobrun.jobrun_lstchgtm, 'hh24:mi:ss' )  "Time",
 to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd' ) "ProdDate",
 nodmst_name Agent,
 length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
 jobmst.jobmst_id from tidal.jobrun
    join  tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
    left join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
    where 
         jobrun.jobmst_id = jobmst.jobmst_id and jobrun.jobrun_lstchgtm >  sysdate - 1 and
         jobmst.jobmst_type > 1 and 
         jobrun_status in( 66,103) and 
         jobrun.jobrun_rundt = (select sysval_time from tidal.sysval where sysval_id = 84)
         order by jobrun.jobrun_lstchgtm desc
         ]]>
        </querytext_oracle>        
    </query>

    <query>
        <queryname>dashboardQuery1</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>admin</category><linkquery></linkquery><querydescription>Errored,Abnormal Jobs</querydescription>
        
        <querytext_sqlserver>
            <![CDATA[
select jobrun.jobrun_id,jobrun.jobmst_id, jobrun.jobmst_name + coalesce( '(' + jobrun.jobmst_prntname +  ')','' )  Job, 
 case jobrun_status when 66 then 'Error Occurred' when 103 then 'Completed Abnormally' end jobrun_status, 
 convert(varchar(250), jobrun.jobrun_lstchgtm, 108)  Time,
 CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate, nodmst_name Agent,
 len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
 jobrun.jobmst_id from jobrun with (nolock)
  where 
         jobrun.jobrun_lstchgtm >  dateadd(MINUTE,-1440, getdate()) and 
         jobrun.jobmst_type > 1 and jobrun_status in( 66,103) 
         order by jobrun.jobrun_lstchgtm desc
         ]]>
        </querytext_sqlserver>
 <querytext_oracle>
            <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id, jobmst.jobmst_name || coalesce('('||jobmst.jobmst_prntname ||')','')   "JobName", 
 case jobrun_status when 66 then 'Error Occurred' when 103 then 'Completed Abnormally' end jobrun_status, 
 to_char( jobrun.jobrun_lstchgtm, 'hh24:mi:ss' )  "Time",
 to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd' ) "ProdDate",
 nodmst_name Agent,
 length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
 jobmst.jobmst_id from tidal.jobrun
    join  tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
    left join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id
    where 
         jobrun.jobmst_id = jobmst.jobmst_id and jobrun.jobrun_lstchgtm >  sysdate - 1 and
         jobmst.jobmst_type > 1 and 
         jobrun_status in( 66,103) and 
         jobrun.jobrun_rundt = (select sysval_time from tidal.sysval where sysval_id = 84)
         order by jobrun.jobrun_lstchgtm desc
         ]]>
        </querytext_oracle>        
    </query>

    <query>
        <queryname>del-dashboardQuery2</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>Jobs stuck in Launched/Skipped/Orphaned/Waiting on Resources</querydescription>
        <querytext_sqlserver>
            <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id, jobmst.jobmst_name + coalesce( '(' + jobmst.jobmst_prntname +  ')','' )  Job, 
 case jobrun_status  when 49 then 'Waiting on Resources' when 50 then 'Launched' when 104 then 'Skipped' when 105 then 'Orphaned' else CONVERT(varchar(6),jobrun_status) end Status, 
 case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end JobType,
 convert(varchar(250), jobrun.jobrun_lstchgtm, 108)  Time, jobmst.jobmst_id,
 len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
 CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate, nodmst_name as Agent
  from jobrun with (nolock)
  join  jobmst on jobrun.jobmst_id = jobmst.jobmst_id 
  left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
 WHERE 
 jobrun.jobmst_type > 1 and
 jobrun.jobrun_rundt = (select sysval_time from sysval where sysval_id = 84) and
 jobrun.jobrun_lstchgtm >  dateadd(MINUTE,-1440, getdate()) and
 (
 ( 
    jobrun_status in (50)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
    AND jobrun_lstchgtm < (Select DATEADD(mi,-8,getdate()))
 ) or 
 ( 
    jobrun_status in (49)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
    AND jobrun_lstchgtm < (Select DATEADD(mi,-8,getdate()))
 ) or 
 
 (
    jobrun_status in (104,105)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
 )
 )
]]>
        </querytext_sqlserver>
        <querytext_oracle> 
          <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id "jobmst_id", jobmst.jobmst_name || coalesce( '(' || jobmst.jobmst_prntname ||  ')','' )  "JobName", 
 case jobrun_status when 50 then 'Launched' when 104 then 'Skipped' when 105 then 'Orphaned' else to_char(jobrun_status) end Status, 
 case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end "JobType",
 to_char( jobrun.jobrun_lstchgtm, 'hh24:mi:ss' ) Time, jobmst.jobmst_id,
 to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd' ) ProdDate
  from tidal.jobrun, tidal.jobmst 
 WHERE 
 jobrun.jobmst_id = jobmst.jobmst_id and 
 jobrun.jobmst_type > 1 and
 jobrun.jobrun_lstchgtm >  sysdate - 1 and
 jobrun.jobrun_rundt = (select sysval_time from tidal.sysval where sysval_id = 84) and
 (( 
    jobrun_status in (49,50)
    AND jobrun_lstchgtm < sysdate - (8/1440)
 ) or 
 (
    jobrun_status in (104,105)
 ))

]]>
        </querytext_oracle>

    </query>

    <query>
        <queryname>dashboardQuery2</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>admin</category><linkquery></linkquery><querydescription>Jobs stuck in Launched/Skipped/Orphaned/Waiting on Resources</querydescription>
        <querytext_sqlserver>
            <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id, jobrun.jobmst_name + coalesce( '(' + jobrun.jobmst_prntname +  ')','' )  Job, 
 case jobrun_status  when 49 then 'Waiting On Resource' when 50 then 'Launched' when 104 then 'Skipped' when 105 then 'Orphaned' else CONVERT(varchar(6),jobrun_status) end jobrun_status, 
 case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end JobType,
 convert(varchar(250), jobrun.jobrun_lstchgtm, 108)  Time, jobrun.jobmst_id,
 len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
 CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate, nodmst_name as Agent
  from jobrun with (nolock)
--  join  jobmst on jobrun.jobmst_id = jobmst.jobmst_id 
--  left join nodmst on  jobrun.nodmst_id = nodmst.nodmst_id
 WHERE 
 jobrun.jobmst_type > 1 and
 jobrun.jobrun_rundt > dateadd(MINUTE,-1440, getdate()) and
 jobrun.jobrun_lstchgtm >  dateadd(MINUTE,-1440, getdate()) and
 (
 ( 
    jobrun_status in (50)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
    AND jobrun_lstchgtm < (Select DATEADD(mi,-8,getdate()))
 ) or 
 ( 
    jobrun_status in (49)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
    AND jobrun_lstchgtm < (Select DATEADD(mi,-8,getdate()))
 ) or 
 
 (
    jobrun_status in (104,105)
    AND CONVERT(VARCHAR(11),jobrun_proddt) = CONVERT(VARCHAR(11),GETDATE())
 )
 )

]]>
        </querytext_sqlserver>
        <querytext_oracle> 
          <![CDATA[
select jobrun.jobrun_id, jobrun.jobmst_id "jobmst_id", jobmst.jobmst_name || coalesce( '(' || jobmst.jobmst_prntname ||  ')','' )  "JobName", 
 case jobrun_status when 50 then 'launched' when 104 then 'Skipped' when 105 then 'Orphaned' else to_char(jobrun_status) end Jobrun_Status, 
 case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end "JobType",
 to_char( jobrun.jobrun_lstchgtm, 'hh24:mi:ss' ) Time, jobmst.jobmst_id,
 to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd' ) ProdDate
  from tidal.jobrun, tidal.jobmst 
 WHERE 
 jobrun.jobmst_id = jobmst.jobmst_id and 
 jobrun.jobmst_type > 1 and
 jobrun.jobrun_lstchgtm >  sysdate - 1 and
 jobrun.jobrun_rundt = (select sysval_time from tidal.sysval where sysval_id = 84) and
 (( 
    jobrun_status in (49,50)
    AND jobrun_lstchgtm < sysdate - (8/1440)
 ) or 
 (
    jobrun_status in (104,105)
 ))

]]>
        </querytext_oracle>

    </query>

    <query>
        <queryname>dashboardQuery3</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>admin</category><linkquery></linkquery><querydescription>Jobs running longer than expected</querydescription>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobmst_id,Job,JobType,Duration - EstimatedDuration TimeExceeded, jobrun_status, Duration, EstimatedDuration, ProdDate, Agent  from (
select jobrun.jobrun_id, jobrun.jobmst_id, jobrun.jobmst_name + coalesce( '(' + jobrun.jobmst_prntname +  ')','' )  Job, 
case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end JobType,
case jobrun_status when 51 then DATEDIFF(SS, jobrun.jobrun_stachgtm, getdate()) 
else jobrun.jobrun_duration end Duration,
len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
jobrun.jobrun_estduration EstimatedDuration,
CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate,
 case jobrun_status when 51 then 'Active' when 101 then 'Completed Normally' end jobrun_status,
  convert(varchar(250), jobrun.jobrun_lstchgtm, 108)  ChangeTime, nodmst_name Agent from
   jobrun with (nolock)
   --join jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   --left join nodmst on jobrun.nodmst_id = nodmst.nodmst_id 
   where 
        jobrun.jobrun_rundt >  dateadd(MINUTE,-1440, getdate()) and
		(case jobrun_status when 51 then DATEDIFF(SS, jobrun.jobrun_stachgtm, getdate()) 
else jobrun.jobrun_duration end - jobrun.jobrun_estduration) > 3 and 
          jobrun.jobrun_lstchgtm >  dateadd(MINUTE,-1440, getdate()) and
		 jobrun_status in(51)
		 and jobrun.jobmst_type > 1
         --order by jobmst_type desc, jobrun.jobrun_lstchgtm desc
		 ) res
		 order by JobType desc,  (Duration - EstimatedDuration) desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[        
select jobrun_id, jobmst_id,"Job","JobType","Duration" - "EstimatedDuration" TimeExceeded, "Jobrun_Status", "Duration", "EstimatedDuration", "ProdDate", Agent  from (
select jobrun.jobrun_id, jobrun.jobmst_id, jobmst.jobmst_name || coalesce( '(' || jobmst.jobmst_prntname ||  ')','' )  "Job", 
case jobrun.jobmst_type when 1 then 'JobGroup' else 'Job' end "JobType",
case jobrun_status when 51 then extract(second from jobrun.jobrun_stachgtm - current_timestamp) 
else jobrun.jobrun_duration end "Duration",
length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  "Successors",
jobrun.jobrun_estduration "EstimatedDuration",
to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd' ) "ProdDate",
 case jobrun_status when 51 then 'Active' when 101 then 'Completed Normally' end "Jobrun_Status",
  to_char( jobrun.jobrun_lstchgtm, 'hh24:mi:ss' )  "ChangeTime", nodmst_name Agent 
  from
   tidal.jobrun 
   join tidal.jobmst on jobrun.jobmst_id = jobmst.jobmst_id
   left join tidal.nodmst on jobrun.nodmst_id = nodmst.nodmst_id 
   where 
        jobrun.jobrun_rundt = (select sysval_time from tidal.sysval where sysval_id = 84) and
		(case 
    jobrun_status 
    when 51 then   extract(second from jobrun.jobrun_stachgtm - current_timestamp)
    else coalesce(jobrun.jobrun_duration,0) 
    end
    - coalesce(jobrun.jobrun_estduration,0)) > 3 and 
          
		 coalesce(jobrun_status,0) in(51)		 ) 
     res
		 order by "JobType" desc,  ("Duration" - "EstimatedDuration") desc
]]>
        </querytext_oracle>
    </query>
<query>   
        <queryname>dashboardQuery4</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>admin</category><linkquery></linkquery><querydescription>System Activity- last 15 minutes</querydescription>
        <cachetimeout>300</cachetimeout>
        <querytext_sqlserver>
            <![CDATA[
select 1 seq, 'msglog_changes' [Activity Desc] , count(*) cnt, getdate() Updated from msglog with (nolock) where msglog_crtdt > dateadd(MINUTE,-15, getdate())
union
select 2 seq, 'jobrun_changes' [Activity Desc] , count(*) cnt, getdate() Updated from jobrun with (nolock) where jobrun.jobrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
--select 3 seq, 'events_changes' [Activity Desc] , count(*) cnt from trgtskrun with (nolock) where trgtskrun.trgtskrun_crtdt > dateadd(MINUTE,-15, getdate()), getdate() Updated
--union
select 4 seq, 'jobs gone active' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and  msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and  msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and  msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' [Activity Desc] , count(*) cnt, getdate() Updated from msglog, jobdata with (nolock) where msglog.jobmst_id = jobdata.jobmst_id and jobdata.version = 0 and jobdata.jobmst_type > 1 and  msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' [Activity Desc] , count(*) cnt, getdate() Updated from msglog with (nolock) where msglog.msglog_crtdt > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Launched%'
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select 1 seq, 'msglog_changes' ActivityDesc , count(*) cnt from tidal.msglog  where msglog_crtdt > current_timestamp - INTERVAL '15' MINUTE 
union
select 2 seq, 'jobrun_changes' ActivityDesc , count(*) cnt from tidal.jobrun  where jobrun.jobrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 3 seq, 'events_changes' ActivityDesc , count(*) cnt from tidal.trgtskrun  where trgtskrun.trgtskrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 4 seq, 'jobs gone active' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' ActivityDesc , count(*) cnt from tidal.msglog  where msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Launched%'
]]>
        </querytext_oracle>
    </query>
<query>   
        <queryname>del-dashboardQuery4</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>System Activity- last 15 minutes</querydescription>
        <querytext_sqlserver>
            <![CDATA[
select 1 seq, 'msglog_changes' [Activity Desc] , count(*) cnt from msglog with (nolock) where msglog_crtdt > dateadd(MINUTE,-15, getdate())
union
select 2 seq, 'jobrun_changes' [Activity Desc] , count(*) cnt from jobrun with (nolock) where jobrun.jobrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 3 seq, 'events_changes' [Activity Desc] , count(*) cnt from trgtskrun with (nolock) where trgtskrun.trgtskrun_lstchgtm > dateadd(MINUTE,-15, getdate())
union
select 4 seq, 'jobs gone active' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' [Activity Desc] , count(*) cnt from msglog, jobmst with (nolock) where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' [Activity Desc] , count(*) cnt from msglog with (nolock) where msglog.msglog_lstchgtm > dateadd(MINUTE,-15, getdate()) and msglog_text like '%Status change to Launched%'

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select 1 seq, 'msglog_changes' ActivityDesc , count(*) cnt from tidal.msglog  where msglog_crtdt > current_timestamp - INTERVAL '15' MINUTE 
union
select 2 seq, 'jobrun_changes' ActivityDesc , count(*) cnt from tidal.jobrun  where jobrun.jobrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 3 seq, 'events_changes' ActivityDesc , count(*) cnt from tidal.trgtskrun  where trgtskrun.trgtskrun_lstchgtm > current_timestamp - INTERVAL '15' MINUTE 
union
select 4 seq, 'jobs gone active' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE and msglog_text like '%Status change to Active%'
union
select 5 seq, 'jobs completed normally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed normally%'
union
select 6 seq, 'jobs completed abnormally' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Completed abnormally%'
union
select 7 seq, 'jobs errored' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to %Error%'
union
select 8 seq, 'jobs timed out' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Timed%'
union
select 9 seq, 'jobs changed to waiting on dependencies' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on dependencies%'
union
select 10 seq, 'jobs changed to waiting on resources' ActivityDesc , count(*) cnt from tidal.msglog, tidal.jobmst  where msglog.jobmst_id = jobmst.jobmst_id and jobmst.jobmst_type > 1 and  msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Waiting on resource%'
union
select 11 seq, 'jobs changed to launched' ActivityDesc , count(*) cnt from tidal.msglog  where msglog.msglog_lstchgtm > current_timestamp - INTERVAL '15' MINUTE  and msglog_text like '%Status change to Launched%'
]]>
        </querytext_oracle>
    </query>

     <query>
        <queryname>old-dashboardQuery5</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>OperatorActions</querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT      msglog.msglog_text, jobdata.jobname +'(' + jobdata.jobgroup + ')' Jobname, msglog.usrmst_name
      FROM         msglog , jobdata
      WHERE     
      jobdata.version = 0
      and msglog.msglog_crtdt >= dateadd(MINUTE,-1440, getdate())
       --and ((msglog_type in(2) and msglog_source in(1,6) and msglog_category in(0,11,10) ) or (msglog_type in(2) and msglog_source in(1) and msglog_category in(11,10)))
      and (msglog_subcategory = 5)
      and (msglog.jobmst_id is null  or msglog.jobmst_id = jobdata.jobmst_id)
      order by   msglog.msglog_crtdt    desc
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>
    
     <query>
        <queryname>old-dashboardQuery6</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>System Messages</querydescription>
        <querytext_sqlserver>
            <![CDATA[

SELECT     COUNT(*) Times , MAX(msglog.msglog_crtdt) LastOccurence, msglog.msglog_text
      FROM         msglog 
      WHERE     msglog.msglog_crtdt > dateadd(MINUTE,-1440, getdate()) 
       and msglog_type in(2,1,4) and jobrun_id = 0 and msglog_subcategory=0 and msglog_source not in(13) and msglog.jobmst_id = 0
      GROUP by    msglog.msglog_text
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>
     <query>
        <queryname>dashboardQuery0</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>admin</category><linkquery></linkquery><querydescription>Job Activity</querydescription>
        <querytext_sqlserver>
            <![CDATA[
             
 SELECT  jobrun.jobrun_id jobrun_id,
 jobrun.jobrun_instance instance, 
 jobrun.jobmst_id jobmst_id, 
 coalesce(jobrun.jobmst_prntname,'') as [Group], 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' + jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') + '\' + jobrun.jobmst_name end as [Group],
 jobrun.jobmst_name as JobName, 
 --'' LastAction,
 rtrim(statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'Group' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
  JOBRUN.owner_name as Owner,

--dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime, 
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
--CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
--jobrun_duration,
--case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
--CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
--Convert(varchar(10), jobrun_rundt,120)  as RunDate, 
--jobrun_instance,
--coalesce(jobrun.jobclass,'') JobClass,
--datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
  
--len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    --jobrun.jobrun_prntid,
    nodmst_name,
    --quemst_name,  
    --cast(jobrun_cmd as varchar(1000))  command,
    --jobrun.jobrun_status sc,
    --'' job_dependencies,
    --len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) lvl ,
    --DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
    '<<master>>' master
  FROM   jobrun  with(nolock)
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
         (
          (jobrun_proddt >= '<<prod_date>>'  and jobrun_proddt <= '<<prod_date>>') or 
          (jobrun_rundt >= '<<prod_date>>'  and jobrun_rundt <= '<<prod_date>>')
          )
		  --and JOBDATA.version = 0 
  order by ProdDate, 
  jobrun_fullpath, 
  --jobrun.jobrun_launchtm,  
  --EstStartTime, 
  jobrun_status

        
]]>
        </querytext_sqlserver>
        <querytext_oracle>
                    <![CDATA[

SELECT  jobrun.jobrun_id "jobrun_id",jobrun.jobrun_instance "instance", jobrun.jobmst_id "jobmst_id",
 coalesce(jobrun.jobmst_prntname,'') as JobGroup, 
 --case when jobrun.jobmst_type = 1 and jobrun.jobmst_prntid  is null then '\' || jobrun.jobmst_name else coalesce(jobrun.jobmst_prntname,'') || '\' || jobrun.jobmst_name end as "JobGroup",
 jobrun.jobmst_name as "JobName",  jobrun_instance,
 rtrim(statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end ) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,  
 jobrun.owner_name "Owner", jobrun_esttime "EstStartTime",  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') Duration, 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  "EstDuration", 
 jobrun.jobrun_launchtm StartTime,
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    jobrun_rundt - jobrun_proddt carryover_days,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    jobrun.jobrun_prntid,
    jobrun.nodmst_name,
    jobrun.quemst_name,  
    jobrun.jobrun_cmd command, 
    coalesce(jobrun.jobclass,'') as "JobClass",
    jobrun.jobrun_status sc,  
    '' job_dependencies,
    '<<master>>' master
  FROM   jobrun
   --left join quemst on jobrun.quemst_id = quemst.quemst_id
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id  and jobdata.version = 0
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where 
          (
            jobrun_proddt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') or 
            jobrun_rundt between to_date('<<prod_date>>','yyyy-mm-dd') and to_date('<<prod_date>>','yyyy-mm-dd') 
          )
  order by "ProdDate", cast(jobrun_fullpath as varchar(4000)), jobrun.jobrun_launchtm,  "EstStartTime", jobrunstatus.statusname
]]>
        </querytext_oracle>
    </query>    
     <query>
        <queryname>DEL-dashboardQuery5-2</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>SLA Report</querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT       
            JOBSLA.sla_group,
            JOBRUN.jobrun_id,  
            JOBRUN.jobmst_id,
						JOBRUN.jobmst_prntname, 
						JOBRUN.jobmst_name, 
						JOBRUNSTATUS.statusname 'status', 
						 case when 
							case when  jobrun_time is null then GETDATE() else jobrun_time end   > cast('<<prod_date>> ' + JOBSLA.expected_start_time as datetime) then 'X' else ' ' 
							  end MissedStartSla,
						 case when 
							case when  jobrun_time is null then GETDATE() else dateadd(s,jobrun_duration, jobrun_time) end   > cast('<<prod_date>> ' + JOBSLA.sla_end_time as datetime) then 'X' else ' ' 
							  end MissedSla,
						convert(varchar,cast(JOBRUN.jobrun_time as time(0)), 8) ActualStartTime,  
						convert(varchar,cast(case when  jobrun_time is null then null else dateadd(s,jobrun_duration, jobrun_time) end as time(0)), 8)  actual_end_time,
						convert(varchar,cast(cast('<<prod_date>> ' + JOBSLA.expected_start_time as datetime) as time(0)), 8) sla_start_time,
						convert(varchar,cast(cast('<<prod_date>> ' + JOBSLA.sla_end_time        as datetime) as time(0)), 8) sla_end_time,
						JOBRUN.jobrun_proddt 
FROM            JOBRUN INNER JOIN
                         JOBSLA ON JOBRUN.jobmst_id = JOBSLA.jobmst_id AND JOBRUN.jobrun_instance = JOBSLA.instance INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE        (JOBRUN.jobrun_proddt = '<<prod_date>>')
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>   
 <query>
        <queryname>dashboardQuery6</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>Jobs on Unavailable Agents</querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT        Coalesce(nodmst.nodmst_name, nodlstms.nodlstmst_name)  Agent_AgentList,
        jobrun.jobrun_id, 
        jobmst.jobmst_prntname,
        jobmst.jobmst_name,
CONVERT(varchar(10), jobrun_proddt, 120) AS ProdDate
FROM            jobrun INNER JOIN
                         jobmst ON jobrun.jobmst_id = jobmst.jobmst_id LEFT OUTER JOIN
                         nodmst ON jobrun.nodmst_id = nodmst.nodmst_id LEFT OUTER JOIN
                         nodlstms ON jobrun.nodlstmst_id = nodlstms.nodlstmst_id
WHERE        (jobrun.jobrun_status = 7)
order by  Coalesce(nodmst.nodmst_name, nodlstms.nodlstmst_name) ,jobmst.jobmst_prntname,  jobmst.jobmst_name
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>
 <query>
        <queryname>GetLastImportTime</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>Last import time</querydescription>
        <querytext_sqlserver>
            <![CDATA[
select (msglog_crtdt) last_import_time from msglog where msglog_id in (select max(msglog_id) from msglog)
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>        
     <query>
        <queryname>SLA All</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>sla</category><linkquery></linkquery><querydescription>SLA Report all jobs</querydescription>
        <querytext_sqlserver> 
            <![CDATA[
select      case when jobsla.sla_group is null then '' else jobsla.sla_group end sla_group, JOBRUN.jobrun_id,  JOBRUN.jobmst_id, JOBSLA.id,
						JOBRUN.jobmst_name, 
						JOBRUN.jobmst_prntname,
						JOBRUNSTATUS.statusname 'jobrun_status', 
						 case when 
							case when  jobrun_time is null then GETDATE() else dateadd(s,jobrun_duration, jobrun_time) end   < cast('<<prod_date>> ' + JOBSLA.sla_end_time as datetime) or jobsla.ID IS NULL then ' ' else 'X' 
							  end Sla,
						case when 
							case when  jobrun_time is null then GETDATE() else jobrun_time end   < cast('<<prod_date>> ' + JOBSLA.expected_start_time as datetime) or jobsla.ID IS NULL  then ' ' else 'X' 
							  end StSla,
						convert(varchar,cast(JOBRUN.jobrun_time as time(0)), 8) StartTime,  
						convert(varchar,cast(case when  jobrun_time is null then null else dateadd(s,jobrun_duration, jobrun_time) end as time(0)), 8) EndTime,
						convert(varchar,cast(cast('<<prod_date>> ' + JOBSLA.expected_start_time as datetime) as time(0)), 8) sla_start_time,
						convert(varchar,cast(cast('<<prod_date>> ' + JOBSLA.sla_end_time        as datetime) as time(0)), 8) sla_end_time,
						JOBRUN.jobrun_proddt,
            '' jobrun_sla_ind,
            jobrun_successors,
            '0' [$$treeLevel]
FROM            JOBRUN full outer JOIN
                         JOBSLA ON JOBRUN.jobmst_id = JOBSLA.jobmst_id AND JOBRUN.jobrun_instance = JOBSLA.instance INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE        (JOBRUN.jobrun_proddt = '<<prod_date>>')
order by JOBSLA.id

]]>
        </querytext_sqlserver>
        <querytext_oracle>
               <![CDATA[
select      case when jobsla.sla_group is null then ' ' else jobsla.sla_group end sla_group,
            JOBRUN.jobrun_id,  
            JOBRUN.jobmst_id, JOBSLA.id,
            JOBRUN.jobmst_name, 
            JOBRUN.jobmst_prntname,
--            JOBRUN.jobrun_duration,
--            jobrun.jobrun_time,
--            jobrun_time + numToDSInterval(jobrun_duration,'second'),
--            to_char(case when  jobrun_time is null then sysdate else coalesce(jobrun_time + numToDSInterval(jobrun_duration,'second'),sysdate) end, 'HH24:mi'),
--            to_char(to_date('<<prod_date>> ' || JOBSLA.sla_end_time, 'YYYY-MM-DD HH24:mi'),'HH24:mi'),
            JOBRUNSTATUS.statusname "jobrun_status", 
             case when 
              case when  jobrun_time is null then sysdate else coalesce(jobrun_time + numToDSInterval(jobrun_duration,'second'),sysdate) end   < to_date('<<prod_date>> ' || JOBSLA.sla_end_time, 'YYYY-MM-DD HH24:mi') or jobsla.ID IS NULL then ' ' else 'X' 
                end Sla,
            case when 
              case when  jobrun_time is null then sysdate else jobrun_time end   < to_date('<<prod_date>> ' || JOBSLA.expected_start_time, 'YYYY-MM-DD HH24:mi') or jobsla.ID IS NULL  then ' ' else 'X' 
                end StSla,
            to_char(JOBRUN.jobrun_time , 'HH:mi') "StartTime",  
            case when  jobrun_time is null then null else jobrun_time + numToDSInterval(jobrun_duration,'second') end  EndTime,
            to_char(to_date('<<prod_date>> ' || JOBSLA.expected_start_time, 'YYYY-MM-DD HH24:mi'), 'HH24:mi') sla_start_time,
            to_char(to_date('<<prod_date>> ' || JOBSLA.sla_end_time, 'YYYY-MM-DD HH24:mi'), 'HH24:mi') sla_end_time,
            JOBRUN.jobrun_proddt,
            ' ' jobrun_sla_ind,
            jobrun_successors,
            '0' "$$treeLevel"
FROM            JOBRUN full outer JOIN
                         JOBSLA ON JOBRUN.jobmst_id = JOBSLA.jobmst_id AND JOBRUN.jobrun_instance = JOBSLA.instance INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE        (JOBRUN.jobrun_proddt = date '<<prod_date>>')
order by JOBSLA.id

]]>
        </querytext_oracle>
    </query>   

     <query>
        <queryname>SLA Jobruns</queryname>
       <db>reporting</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><linkquery></linkquery><querydescription>SLA Jobruns</querydescription>
        <querytext_sqlserver>
            <![CDATA[
SELECT        JOBRUN.jobrun_id,  JOBRUN.jobmst_id, JOBSLA.id,
						JOBRUN.jobmst_name, 
						JOBRUN.jobmst_prntname, 
						JOBRUNSTATUS.statusname 'status', 
            '' jobrun_successors,
						JOBRUN.jobrun_proddt 
FROM            JOBRUN INNER JOIN
                         JOBSLA ON JOBRUN.jobmst_id = JOBSLA.jobmst_id AND JOBRUN.jobrun_instance = JOBSLA.instance INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE        JOBRUN.jobrun_proddt in( select  max(jobrun_proddt) sysval_time from jobrun where jobrun_lstchgtm = (select max(jobrun_lstchgtm) from jobrun))
order by JOBSLA.id
]]>

        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[        
SELECT        JOBRUN.jobrun_id,  JOBRUN.jobmst_id, JOBSLA.id,
						JOBRUN.jobmst_name, 
						JOBRUN.jobmst_prntname, 
						JOBRUNSTATUS.statusname "status", 
            '' jobrun_successors,
						JOBRUN.jobrun_proddt 
FROM            JOBRUN INNER JOIN
                         JOBSLA ON JOBRUN.jobmst_id = JOBSLA.jobmst_id AND JOBRUN.jobrun_instance = JOBSLA.instance INNER JOIN
                         JOBRUNSTATUS ON JOBRUN.jobrun_status = JOBRUNSTATUS.statusid
WHERE        JOBRUN.jobrun_proddt in( select  max(jobrun_proddt) sysval_time from jobrun where jobrun_lstchgtm = (select max(jobrun_lstchgtm) from jobrun))
order by JOBSLA.id
]]>
        </querytext_oracle>
    </query>   

     <query>
        <queryname>Event and Actions by Jobrun Schedule</queryname>
       <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>jobactivity</category><linkquery></linkquery><querydescription>Events and actions detailed information</querydescription>
        <querytext_sqlserver> 
            <![CDATA[
SELECT         trgtskrun.jobmst_id, trgmst.trgmst_name AS Event, tskmst.tskmst_name AS Action, jobrun.jobrun_id , 
                         jobmst.jobmst_name AS Jobname, jobmst.jobmst_prntname AS JobGroup, trgtskrun.trgtskrun_parent, trgtskrun.jobrun_id, trgtskrun.trgtskrun_payload, case when trgtskrun_parent is null then 0 else 1 end  as [$$treeLevel]
FROM            trgtskrun INNER JOIN
                         trgmst ON trgtskrun.trgmst_id = trgmst.trgmst_id INNER JOIN
                         jobrun ON trgtskrun.jobrun_id = jobrun.jobrun_id INNER JOIN
                         jobmst ON trgtskrun.jobmst_id = jobmst.jobmst_id LEFT OUTER JOIN
                         tskmst ON trgtskrun.tskmst_id = tskmst.tskmst_id
                         WHERE        (JOBRUN.jobrun_proddt = '<<prod_date>>')

]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT         trgtskrun.jobmst_id, trgmst.trgmst_name AS Event, tskmst.tskmst_name AS Action, jobrun.jobrun_id , 
                         jobmst.jobmst_name AS Jobname, jobmst.jobmst_prntname AS JobGroup, trgtskrun.trgtskrun_parent, trgtskrun.jobrun_id, trgtskrun.trgtskrun_payload, case when trgtskrun_parent is null then 0 else 1 end  "$$treeLevel"
FROM            tidal.trgtskrun INNER JOIN
                         tidal.trgmst ON trgtskrun.trgmst_id = trgmst.trgmst_id INNER JOIN
                         tidal.jobrun ON trgtskrun.jobrun_id = jobrun.jobrun_id INNER JOIN
                         tidal.jobmst ON trgtskrun.jobmst_id = jobmst.jobmst_id LEFT OUTER JOIN
                         tidal.tskmst ON trgtskrun.tskmst_id = tskmst.tskmst_id
                         WHERE        (JOBRUN.jobrun_proddt =  date '<<prod_date>>')
]]>

        </querytext_oracle>
    </query>   


  <query>
        <queryname>999 adhoc testt</queryname>
        <db>admiral</db><queryfields></queryfields><chartfields></chartfields>
        <category>hidden</category><querydescription></querydescription>><linkquery></linkquery>
        <querytext_sqlserver>
            <![CDATA[
      declare @StartTime datetime = '<<from_date>>',
      @EndTime datetime = ' '<<to_date>>'',
      @Interval int = 900 -- this can be changed.

      ;WITH cSequence AS
      (
      SELECT
      @StartTime AS StartDate,
      DATEADD(SECOND, @Interval, @StartTime) AS EndRange
      UNION ALL
      SELECT
      EndRange,
      DATEADD(SECOND, @Interval, EndRange)
      FROM cSequence
      WHERE DATEADD(SECOND, @Interval, EndRange) < @EndTime
)
 /* insert into tmp_IRange */
SELECT * FROM cSequence OPTION (MAXRECURSION 0);
]]>
        </querytext_sqlserver>
        <querytext_oracle>
        </querytext_oracle>
    </query>
        <query>
        <queryname>TESTQB</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobrun_id, jobmst_prntname, jobmst_id, jobmst_name, jobrun_instance,statusname jobrun_status, jobrun_stachgtm, jobrun_lstchgtm, jobrun_joboutput joboutput, jobrun_met, jobmst_type, jobrun_proddt, jobrun_estduration, jobrun_duration, jobrun_esttime, jobrun_time, nodmst_name, quemst_name, jobrun_adhoc, jobrun_waitop, jobrun_fromtm, jobrun_untiltm, owner_name, jobrun_concur,
 jobrun_priority, jobrun_cmd, jobrun_envfile, jobrun_exitcode, jobrun_timewin, jobrun_saveoutput, jobrun_reruns, jobrun_output, jobrun_allowadhoc, jobrun_hasdependents, jobrun_rundt, jobrun_minrun, jobrun_maxrun, jobrun_deplogic, jobcls_id, jobrun_interval, jobrun_intervalcnt, jobrun_rerun, jobrun_timediff, jobrun_outputlen, jobrun_normalexit, jobrun_normalrange, jobrun_normalop, jobrun_deprerun, jobrun_carryover,
 jobrun_resetsucc, jobrun_ignoretime, jobrun_fromstep, jobrun_savelogonly, jobrun_expire, jobrun_deps, jobrun_deps jobrun_deps_details, jobrun_deps UnmetFileDependencies, jobrun_cputime, jobrun_extinfo, jobrun_reslock, jobrun_estmethod, jobrun_nearoutage, jobrun_queuetm, jobrun_launchtm, jobrun_fullpath, jobrun_usrmodtm, jobrun_successors, jobrun_startrundt,
  ' ' jobrun_dep_type, ' ' jobrun_dep_met, ' ' jobrun_dep_jobrunid, ' ' jobrun_dep_filename, ' ' jobrun_dep_varid from jobrun with(nolock), jobrunstatus where jobrun_status = jobrunstatus.statusid  and 
 ((jobrun_proddt='<<prod_date>>' or jobrun_rundt='<<prod_date>>') and (jobrun_id in (<<jobrun_id:0>>) or <<jobrun_id:0>> = 0 ))

	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
      select count(*) from jobrun where jobrun_proddt = to_date('2017-10-25', 'yyyy-mm-dd')
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>TESTInheritance</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select jobmst_id, jobrun_id, jobrun_status from 
{{715JobActivityNG}} 
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select jobmst_id, jobrun_id, job from 
{{711HAllJobRunsOneDay}} where jobrun_status in ('Completed Abnormally','Error Occurred','Deferred','Timed Out')
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>JobactivityInError</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
select [Group], JobName, jobmst_id, jobrun_id, jobrun_status , job_type, Owner, nodmst_name, quemst_name, ProdDate,'<<master>>' master from 
{{715JobActivityNG}} 
where jobrun_status in ('Completed Abnormally','Error Occurred','Deferred','Timed Out','Cancelled','Aborted')
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select "JobGroup", "JobName", "jobmst_id", "jobrun_id", "jobrun_status" , "job_type", "Owner", "nodmst_name", "quemst_name", "ProdDate" from 
{{715JobActivityNG}} 
where "jobrun_status" in ('Completed Abnormally','Error Occurred','Deferred','Timed Out','Cancelled','Aborted')
]]>
        </querytext_oracle>
    </query> 
       
        <query>
        <queryname>JobsSelected</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
          
 WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  case when D.jobdtl_inhagent = 'Y' then mt.jobdtl_proxy else D.jobdtl_proxy end as jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  coalesce(JobGroup,'') JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  n.NODMST_NAME Agent,
  coalesce(jc.jobcls_name,'') Jobclass,
  coalesce(nl.nodlstmst_name,'') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active,
  owner_name,
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobdtl_extinfo ExtendedInfo,
  jobdtl_retnsn,
  jobmst_desc,
  jobmst_runbook,
  len(coalesce(JobGroup,'')) -  len(replace(coalesce(JobGroup,''),'\','')) lvl,
  '<<master>>' master,
  fullpath
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
  where Jobname like '%' and  coalesce(JobGroup,'') like '%'
  and  jobmst_id in (<<selectedids>>)
	   ]]>
        </querytext_sqlserver> 
        <querytext_oracle>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo1,
  jobdtl_extinfo2,
  jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  0 as lvls,
  case m.jobmst_type when 1 then  cast('\' as varchar(1)) || cast(m.jobmst_name as varchar(1000)) else ' ' end  JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,  
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  substr(jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  mt.lvls +1 as lvls,
  case m.jobmst_type when 1 then  cast((mt.JobGroup || cast('\' as varchar(1)) || m.jobmst_name) as varchar(1000)) else mt.JobGroup end JobGroup  ,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  substr(d.jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(d.jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(d.jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  d.jobdtl_saveoutput,
  d.jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' 
    when jobmst_type=2 then 'Job'
    when jobmst_type=6 then 'FTP'          
    when jobmst_type=7 then 'AS400' 
    when jobmst_type=8 then 'Adapter' 
    else to_char(jobmst_type) end JobType,
  JobName,
  JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  n.NODMST_NAME Agent,
  coalesce(jc.jobcls_name,'') Jobclass,  
  cast(jde.jobdtl_cmd as varchar(4000)) jobdtl_cmd,
  cast(jobdtl_params as varchar(4000)) jobdtl_params,
  jde.jobmst_active,
  owner_name,
  U.USRMST_NAME RuntimeUser,
  JOBDTL_INHAGENT,
  jobdtl_INHEVENT,
  jobdtl_INHTIME,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_desc,
  jobmst_runbook,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobdtl_extinfo1 "ExtendedInfo1",
  jobdtl_extinfo2 "ExtendedInfo2",
  jobdtl_extinfo3 "ExtendedInfo3",
  '' "ExtendedInfo",
  '<<master>>' master
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
where jobmst_id in (<<selectedids>>)
]]>
        </querytext_oracle>
    </query>    
    <query>
        <queryname>JobRunsSelected</queryname>
        <category>hidden</category>
        <querytotals>All Jobs:count(jobname);Average Duration:avg(Duration);JobRuns:sum(JobRuns)</querytotals>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <chartfields></chartfields>
        <querytext_sqlserver>
            <![CDATA[
 SELECT  jobrun.jobrun_id jobrun_id, jobrun_instance, jobrun.jobmst_id jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, 
 jobrun.jobmst_name as JobName, 
 rtrim(statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
 Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type,
  JOBRUN.owner_name,
dateadd(minute, datediff(minute,0,jobrun_esttime) / 15 * 15, 0)  EstStartTime, 
convert(varchar,jobrun.jobrun_launchtm, 120) StartTime, 
CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108)  Duration, 
CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
jobrun_instance,
coalesce(jobrun.jobclass,'') JobClass,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
  
    len(cast(coalesce(jobrun_successors,'|') as varchar(8000))) - len(replace(cast(coalesce(jobrun_successors,'|') as varchar(8000)), '|', '')) - 1  Successors,
    --len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    nodmst_name,
    quemst_name,  
    cast(jobrun_cmd as varchar(1000))  command,
    jobrun.jobrun_status sc,
    '' job_dependencies,
    len(coalesce(jobmst_prntname,'')) -  len(replace(coalesce(jobmst_prntname,''),'\','')) lvl ,
    DATEDIFF ( minute , jobrun_lstchgtm , current_timestamp ) StatusTime,
    '<<master>>' master
  FROM   jobrun  with(nolock)
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where  jobrun_id in(<<selectedids>>)       
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>

        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
 SELECT  jobrun.jobrun_id "jobrun_id",  jobrun.jobrun_instance "jobrun_instance", jobrun.jobmst_id "jobmst_id", coalesce(jobmst_prntname,'') as "JobGroup", 
 jobmst_name as "JobName",  jobrun_instance,
 trim(statusname || case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end ) jobrun_status,
  Case when jobrun.jobmst_type = 1 then 'JobGroup' when jobrun.jobmst_type=2 then 'Job' when jobrun.jobmst_type=6 then 'FTP' when jobrun.jobmst_type=8 then 'Adapter' end job_type, 
 jobrun.owner_name, jobrun_esttime EstStartTime,  
 to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') Duration, 
 to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  EstDuration, 
 jobrun.jobrun_launchtm StartTime,
   to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
   case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    jobrun_rundt - jobrun_proddt carryover_days,
    length(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000))) - length(replace(cast(coalesce(cast(jobrun_successors as varchar(4000)),'|') as varchar(4000)), '|', '')) - 1  Successors,
    --coalesce(length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')),0) "$$treeLevel",
    jobrun.jobrun_prntid,
    jobrun.nodmst_name,
    jobrun.quemst_name,  
    jobrun.jobrun_cmd command,
    coalesce(jobrun.jobclass,'') "JobClass",
    jobrun.jobrun_status sc,  
    '' job_dependencies, '<<master>>' master
  FROM   jobrun
   --left join quemst on jobrun.quemst_id = quemst.quemst_id
   --join jobdata on jobrun.jobmst_id = jobdata.jobmst_id  and jobdata.version = 0
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where  jobrun_id in(<<selectedids>>)       
  order by "ProdDate", cast(jobrun_fullpath as varchar(4000)), jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_oracle>
        <querytext_sqlite3>
<![CDATA[
        SELECT  jobrun.jobrun_id jobrun_id, jobrun.jobmst_id jobmst_id, coalesce(jobdata.JobGroup,'') as JobGroup, 
 jobdata.JobName as JobName,  jobrun_instance,
 statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end jobrun_status,jobrun.jobmst_type, JOBRUN.owner_name, jobrun_esttime EstStartTime,  
 jobrun_duration Duration, jobrun_estduration EstDuration, jobrun.jobrun_launchtm StartTime,
 jobrun_proddt ProdDate, case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
    JulianDay(jobrun_proddt) - JulianDay(jobrun_rundt) carryover_days,
    length(coalesce(jobrun_successors,'|')) - length(replace(coalesce(jobrun_successors,'|'), '|', '')) - 1  Successors,
    --length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')) [$$treeLevel],
    jobrun.jobrun_prntid,
    nodmst_name,
    quemst_name,  
    jobdtl_cmd command,
    coalesce(jobrun.jobclass,'') jobclass,
    jobrun.jobrun_status sc,
    '' job_dependencies,
    length(coalesce(jobmst_prntname,'')) -  length(replace(coalesce(jobmst_prntname,''),'\','')) lvl
  FROM   jobrun
   join jobdata on jobrun.jobmst_id = jobdata.jobmst_id
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
  where  jobrun_id in(<<selectedids>>)       
		  and JOBDATA.version = 0
          
  order by ProdDate, jobrun_fullpath, jobrun.jobrun_launchtm,  EstStartTime, jobrun_status
]]>
        </querytext_sqlite3>

    </query>
        <query>
        <queryname>TestJinja2</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
select nodmst_id id ,  nodmst_name name from nodmst where nodmst_id > 1 order by nodmst_alias
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select jobmst_id, jobrun_id, job from 
{{711HAllJobRunsOneDay}} where jobrun_status in ('Completed Abnormally','Error Occurred','Deferred','Timed Out')
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>queryAgent</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
SELECT        nodmst.nodmst_id id , nodmst.nodmst_name + coalesce(' (' + servicemst.servicemst_name  + ')','') name, nodmst.nodmst_name
FROM            nodmst LEFT OUTER JOIN
                         servicemst ON nodmst.servicemst_id = servicemst.servicemst_id            
                         where nodmst_id > 1 order by nodmst_name
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT        nodmst.nodmst_id id , nodmst.nodmst_name || coalesce(' (' || servicemst.servicemst_name  || ')','') name
FROM            nodmst LEFT OUTER JOIN
                         servicemst ON nodmst.servicemst_id = servicemst.servicemst_id            
                         where nodmst_id > 1 order by nodmst_name
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>queryRuntimeUser</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
SELECT        usrmst.usrmst_id id , usrmst.usrmst_name + coalesce(' (' + usrmst.usrmst_domain  + ')','') usrmst_name 
FROM            usrmst 
                         where usrmst_suser = 'R' order by usrmst_name
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT        nodmst.nodmst_id id , nodmst.nodmst_name || coalesce(' (' || servicemst.servicemst_name  || ')','') name
FROM            nodmst LEFT OUTER JOIN
                         servicemst ON nodmst.servicemst_id = servicemst.servicemst_id            
                         where nodmst_id > 1 order by nodmst_name
]]>
        </querytext_oracle>
    </query>



        <query>
        <queryname>queryJobrunAgent</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type></template_type>
        <querytext_sqlserver> 
            <![CDATA[
        select * from 
        {{queryAgent}}
        ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
        select * from 
        {{queryAgent}}
        ]]>

        </querytext_oracle>
    </query>
        <query>
        <queryname>queryCalendar</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
select evntmst_id id ,  evntmst_name name from evntmst  order by evntmst_name
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select evntmst_id id ,  evntmst_name name from evntmst order by evntmst_name
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>queryJobrunStatus</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
select statusid id, statusname name from JOBRUNSTATUS order by name
	   ]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select statusid id, statusname name from JOBRUNSTATUS order by name
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>queryJobgroup</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
{% extends "JobDefinition.sql" %}
{% block columns %}
jobmst_id id,
coalesce(JobGroup,'') + '\' + JobName name,
{% endblock %}
{% block content %}
where jobmst_type = 1
order by jobgroup, jobname
{% endblock %}
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
{% extends "JobDefinition.sql" %}
{% block columns %}
jobmst_id id,
coalesce(JobGroup,'') || '\' || JobName name,
{% endblock %}
{% block content %}
where jobmst_type = 1
order by jobgroup, jobname
{% endblock %}
]]>
        </querytext_oracle>
    </query>
        <query>
        <queryname>queryJobrun</queryname>
        <category>reporting</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
SELECT  top 50  jobrun.jobrun_id jobrun_id,
Convert(varchar(10), jobrun_proddt,120)  as ProdDate, 
 jobrun.jobrun_instance instance, jobrun.jobmst_id jobmst_id, coalesce(jobrun.jobmst_prntname,'') as JobGroup, 
 rtrim(statusname +  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) jobrun_status,
coalesce(convert(varchar,jobrun.jobrun_launchtm, 120),'') StartTime, 
coalesce(CONVERT(varchar, DATEADD(ss, jobrun_duration, 0), 108), '')  Duration, 
CONVERT(varchar, DATEADD(ss, jobrun_estduration, 0), 108)  EstDuration, 
jobrun_duration,
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as jobruns,
CONVERT(varchar,dateadd(ss, coalesce(jobrun_duration, jobrun_estduration),coalesce(jobrun_launchtm,jobrun_time,jobrun_esttime)), 120) EndTime,
datediff(DAY,jobrun_proddt,jobrun_rundt) carryover_days,
    jobrun.jobrun_prntid
  FROM   jobrun  with(nolock)
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where         
         (
          jobmst_id = <<jobmst_id:0>>
          )
  order by ProdDate desc, jobrun_fullpath, jobrun.jobrun_launchtm,   jobrun_status
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
SELECT  jobrun.jobrun_id "jobrun_id",
to_char( jobrun.jobrun_proddt, 'yyyy-mm-dd') "ProdDate", 
jobrun.jobrun_instance instance,
jobrun.jobmst_id "jobmst_id", 
coalesce(jobrun.jobmst_prntname,'') as JobGroup, 
rtrim(statusname ||  case when coalesce(jobrun_orgstatus,0) = 0 then '' else '*' end) "jobrun_status",
jobrun.jobrun_launchtm "StartTime",
to_char(to_date(mod(jobrun_duration, 86400),'sssss'),'hh24:mi:ss') "Duration", 
to_char(to_date(mod(jobrun_estduration, 86400),'sssss'),'hh24:mi:ss')  "EstDuration", 
jobrun_duration "jobrun_duration",
case when jobrun_reruns=0 then 1 else jobrun_reruns + 1 end as "jobruns",
jobrun_rundt - jobrun_proddt "carryover_days",
jobrun.jobrun_prntid "jobrun_prntid"
  FROM   jobrun  
   join JOBRUNSTATUS on  jobrun.jobrun_status = JOBRUNSTATUS.statusid
   where  
         (
           rownum <= <<maxrows:50>> and
          jobmst_id = <<jobmst_id:0>>
          )
  order by jobrun.jobrun_proddt desc, cast(jobrun_fullpath as varchar(4000)), jobrun.jobrun_launchtm, jobrun_status
]]>
        </querytext_oracle>
    </query>  
    <query>
        <queryname>Agents</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription>Active Agents not connected</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            Node:Active='Y' and connectionactive = 'N':id,name,active,connectionactive,activejobs
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Node::
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>300 All Agents</queryname>
        <category>agents</category>
        <linkquery></linkquery><querydescription>All Agents</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            Node:id > 1:id,name,active,connectionactive,activejobs,joblimit,joblimit,servicename,enabledjobs,machine
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Node::
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>All Queues</queryname>
        <category>queue</category>
        <linkquery></linkquery><querydescription>All Queues</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            Queue:id > 0:id,name,active,available,bump,description,limit,numwaitingjobs, numrunningjobs,priority
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Queue:id > 0:id,name,active,available,bump,description,limit,numwaitingjobs, numrunningjobs,priority
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>Users</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            UserSession:endtime is null:
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Node::
]]>
        </querytext_oracle>
    </query>

    <query>
        <queryname>Queue</queryname>
        <category>Queue</category>
        <linkquery></linkquery><querydescription>Queue</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            Queue:Active='Y':id,name,parent_name,limit,active,status,master
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            Queue::
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>Statistics</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            StatisticsTotal::
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            StatisticsTotal::
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>JobRun</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription>Job Runs</querydescription>
        <db>restapi</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
            JobRun::id,jobrun_id,name,parentname,instance,statusname,agentname,master
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
            JobRun::id,jobrun_id,name,parentname,instance,statusname,agentname,master
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>SelectedJOBS</queryname><category>admin</category><db>reporting</db><template_type></template_type><querydescription>Selected JOBS</querydescription><cachetimeout>0</cachetimeout>
             <querytext_sqlserver>
            <![CDATA[
select selected_id, entityName from SELECTED_ENTITY where entityType = 'JOBS' and username = '<<username>>' order by entityName
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select selected_id, entityName from SELECTED_ENTITY where entityType = 'JOBS' and username = '<<username>>' order by entityName
]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>SelectedJOB_GROUPS</queryname><category>admin</category><db>reporting</db><template_type></template_type><querydescription>Selected JOB GROUPS</querydescription><cachetimeout>0</cachetimeout>
             <querytext_sqlserver>
            <![CDATA[
select selected_id, entityName from SELECTED_ENTITY where entityType = 'JOB_GROUPS' and username = '<<username>>' order by entityName
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select selected_id, entityName,username from SELECTED_ENTITY where entityType = 'JOB_GROUPS' and username = '<<username>>' order by entityName
]]>
        </querytext_oracle>
    </query>    
<query>
        <queryname>SelectedCALENDARS</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription>Selected CALENDARS</querydescription><cachetimeout>0</cachetimeout>
        <db>reporting</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
select selected_id, entityName,username from SELECTED_ENTITY where entityType = 'CALENDARS' and username = '<<username>>' order by entityName
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select selected_id, entityName,username from SELECTED_ENTITY where entityType = 'CALENDARS' and username = '<<username>>' order by entityName
]]>
        </querytext_oracle>
    </query>
<query>
        <queryname>SelectedVARIABLES</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription>Selected VARIABLES</querydescription><cachetimeout>0</cachetimeout>
        <db>reporting</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
select selected_id, entityName,username from SELECTED_ENTITY where entityType = 'VARIABLES' and username = '<<username>>' order by entityName
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select selected_id, entityName,username from SELECTED_ENTITY where entityType = 'VARIABLES' order by entityName
]]>
        </querytext_oracle>
    </query>


        <query>
        <queryname>MasterLog</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
select top {{max_rows|default('500')}} * from master_log  where entry_datetime between convert(datetime,'{{from_datetime|default('00')}}:00',126) and convert(datetime,'{{to_datetime|default('00')}}:00',126)
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
select * from master_log  
]]>
        </querytext_oracle>
    </query>
    <query>
      <queryname>JobsWithDependenciesAndEvents</queryname>
      <category>admin</category>
      <linkquery></linkquery><querydescription></querydescription>
      <db>admiral</db>
      <template_type></template_type>
      <querytext_sqlserver>
          <![CDATA[
          select 'job: ' + isnull(jobmst_prntname,'') + '\'+ jobname fullPath, 'cmd: ' + isnull(jobdtl_cmd,'') command  ,'params: ' + isnull(jobdtl_param ,'') params  ,' dep: ' + isnull(isnull(depjobparent,'') + '\' + depjobname,'') dep_fullPath, ' file-dep: ' + isnull(filename,'') Filename, 'event: ' + isnull(EventName,'') EventName from 
          (
          SELECT 
          --jobmst.jobmst_type,
          jobmst.jobmst_prntid,
          --jobmst.jobmst_active,jobdep.jobdep_id as id,
          jobmst.jobmst_id as jobid, 
          --jobdep.jobdep_jobmst as depjobid,jobdep.jobdep_joblogic condition, jobdep.nodmst_id as connectionid, --jobdep.nodmst_name as connectionname,jobdep.jobdep_dateoffset as dateoffset, 
          jobmst_1.jobmst_name as depjobname, 
          jobmst_1.jobmst_prntname as depjobparent, 
          jobmst_1.jobmst_type as depjobtype,
          jobdep.jobdep_value as depjobvalue,
          jobdep.jobdep_fileextent as fileextent, 
          jobdep.jobdep_filename as filename, 
          jobdep.jobdep_filetype as filetype, 
          jobdep.jobdep_canignore as ignoredep, 
          rtrim(jobdep.jobdep_ingroup) as ingroup, 
          jobdep.jobdep_instoffset as instanceoffset,
          jobmst.jobmst_id, 
          jobmst.jobmst_name as jobname, 
          jobmst.jobmst_owner as ownerid, 
          jobdep.jobdep_keepmetifready as keepmetifready, 
          jobdep.jobdep_lstchgtm as lastchangetime,
          jobdep.jobdep_usrmodtm as lastusermodifiedtime, 
          jobdep.jobdep_joblogic as logic, 
          jobdep.nodmst_id as nodeid, 
          jobdep.jobdep_filetype occurrence, 
          jobdep.jobdep_operator as operator, 
          jobdep.jobdep_value as procstep,
          jobdep.jobdep_status as status, 
          jobdep.jobdep_type as type, 
          jobdep.varmst_id as variableid, 
          --jobdep.varmst_name as variablename, 
          jobdep.jobdep_value as varvalue,
          jobmst.jobmst_name jobmst_name, 
          jobmst.jobmst_prntname as jobmst_prntname, 
		  jobdtl.jobdtl_cmd,
		  REPLACE(REPLACE(CAST(jobdtl_params AS VARCHAR), CHAR(13), ' '), CHAR(10), ' ') jobdtl_param,
           CASE WHEN jobdep_joblogic = 1 THEN 'All' WHEN jobdep_joblogic = 2 THEN 'One' ELSE '' END  DepLogic, 
           jobdep_id jobdep_id, 
           jobdep_type jobdep_type, 
           jobdep_filetype filetype2, 
           trgmst.trgmst_name EventName,
          --coalesce(jobmst.fromtime,'00:00')  jobdtl_fromtm_hhmm,
          case  when jobmst.jobmst_type = 1 then 'G' when jobmst.jobmst_type = 2 then 'J'  when jobmst.jobmst_type = 6 then 'F' when jobmst.jobmst_type = 8 then 'A' else '?' end jobmst_type
          FROM jobdep 
          RIGHT OUTER JOIN jobmst ON jobmst.jobmst_id = jobdep.jobmst_id 
		  inner join jobdtl on  jobdtl.jobdtl_id = jobmst.jobdtl_id
          LEFT OUTER JOIN jobmst jobmst_1 ON jobmst_1.jobmst_id = jobdep.jobdep_jobmst 
          left outer join trgjob on trgjob.jobmst_id = jobmst.jobmst_id 
          left outer join trgmst on trgmst.trgmst_id = trgjob.trgmst_id
           --trgjob ON trgmst.trgmst_id = trgjob.trgmst_id INNER JOIN
           --                        jobmst ON trgjob.jobmst_id = jobmst.jobmst_id
          where  not jobmst.jobmst_dirty = 'X'
          ) a
          where jobmst_prntname like '%<<jobgroup>>%'
          order by jobmst_prntname, jobmst_name, depjobparent, depjobname, filename , EventName

]]>
      </querytext_sqlserver>
      <querytext_oracle>
          <![CDATA[

]]>
      </querytext_oracle>
  </query>
  <query>
        <queryname>Job launchtime comparison</queryname>
        <category>analysis</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
 with cte as (
  select jobrun.jobmst_id, jobrun.jobrun_instance, jobrun.jobrun_proddt,
         DATEPART(HOUR, JOBRUN.jobrun_launchtm) hh from jobrun) 
  select today.jobmst_id, 
      jobmst.jobmst_name Job_Name, coalesce(jobmst.jobmst_prntname,'') Job_Group,
    yesterday.hh yesterday_starttime, today.hh today_starttime
   from cte as today , 
      cte as  yesterday,
      jobmst
    where 
    today.jobrun_proddt = '<<from_date>>'  and 
	yesterday.jobrun_proddt = '<<to_date>>'  and 
	yesterday.jobmst_id = today.jobmst_id and
	jobmst.jobmst_id =     today.jobmst_id and
	yesterday.jobmst_id = jobmst.jobmst_id and
	yesterday.jobrun_instance = today.jobrun_instance and
	abs(yesterday.hh - today.hh) >= <<hours_difference:5>>
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[

]]>
        </querytext_oracle>
    </query>
    <query>
        <queryname>JobDefinition</queryname>
        <category>admin</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>reporting</db>
        <template_type>jinja</template_type>
        <querytext_sqlserver>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  fullpath,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(jobmst_id as varchar(1000)) as fullpath,
  0 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo,
  jobdtl_saveoutput,
  case jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM jobmst M, jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  cast(cast(mt.fullpath as varchar(1000)) + '\' + cast(m.jobmst_id as varchar(100)) as varchar(1000)),
  mt.lvls +1 as lvls,
  cast(coalesce(m.jobmst_prntname,'') as varchar(1000)) JobGroup,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  case when D.jobdtl_inhagent = 'Y' then mt.jobdtl_proxy else D.jobdtl_proxy end as jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  d.jobdtl_extinfo,
  d.jobdtl_saveoutput,
  case d.jobdtl_trackmethod when 1 then 'ExitCode' when 2 then 'External' when 3 then 'CmdPipe' when 4 then 'ScanOutputNormal' when 5 then 'ScanOutputAbnormal' else '' end jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM jobmst M, JobDtlExtract MT, jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' when jobmst_type=2 then 'Job' when jobmst_type=6 then 'FTP' when jobmst_type=8 then 'Adapter' end JobType,
  JobName,
  coalesce(JobGroup,'') JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  n.NODMST_NAME Agent,
  coalesce(jc.jobcls_name,'') Jobclass,
  coalesce(nl.nodlstmst_name,'') AgentList,
  jde.jobdtl_cmd,
  jobdtl_params,
  jde.jobmst_active,
  owner_name,
  jobmst_alias,
  jobdtl_proxy,
  jobdtl_interval,
  jobdtl_intervalcnt,
  jobdtl_normalexit,
  jobdtl_priority,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_saveoutput,
  U.USRMST_NAME RuntimeUser,
  Jobdtl_InhAgent,
  jobdtl_InhEvent,
  jobdtl_InhTime,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobdtl_extinfo ExtendedInfo,
  jobdtl_retnsn,
  jobmst_desc,
  jobmst_runbook,
  len(coalesce(JobGroup,'')) -  len(replace(coalesce(JobGroup,''),'\','')) lvl,
  {% block columns %}{% endblock %}
  fullpath
From JobDtlExtract jde
    left outer join EVNTMST e on jde.calid= e.evntmst_id
    left outer join NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join OWNER o on jde.jobmst_owner = o.owner_id
  left outer join USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
  {% block content %}{% endblock %}
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[
WITH JobDtlExtract (
  jobmst_id,
  jobmst_prntid,
  JobName,
  lvls,
  JobGroup,
  calid,
  nodmst_id,
  jobcls_id,
  nodlstmst_id,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobmst_type,
  jobdtl_cmd,
  jobdtl_params,
  jobmst_desc,
  jobmst_runbook,
  jobmst_active,
  jobmst_owner,
  jobmst_alias,
  jobdtl_proxy,
  JOBDTL_INTERVAL,
  JOBDTL_INTERVALCNT,
  JOBDTL_NORMALEXIT,
  JOBDTL_PRIORITY,
  SERVICEMST_ID,
  jobdtl_inhevent,
  jobdtl_inhagent,
  jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  jobdtl_extinfo1,
  jobdtl_extinfo2,
  jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_lstchgtm)  as
(
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  0 as lvls,
  case m.jobmst_type when 1 then  cast('\' as varchar(1)) || cast(m.jobmst_name as varchar(1000)) else ' ' end  JobGroup,
  M.evntmst_id calid,
  D.nodmst_id,
  m.jobcls_id,  
  nodlstmst_id,
  d.jobdtl_fromtm,
  d.jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.jobdtl_proxy,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  jobdtl_minrun,
  jobdtl_maxrun,
  jobdtl_concur,
  jobdtl_duration,
  jobdtl_retnsn,
  jobdtl_rerun,
  jobdtl_carryover,
  substr(jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  jobdtl_saveoutput,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  m.jobmst_lstchgtm
  FROM tidal.jobmst M, tidal.jobdtl D
  WHERE M.jobmst_prntid is null  and M.jobdtl_id = D.jobdtl_id and m.jobmst_dirty !='X'
  UNION ALL
  SELECT m.jobmst_id,
  m.jobmst_prntid,
  m.jobmst_name as JobName,
  mt.lvls +1 as lvls,
  case m.jobmst_type when 1 then  cast((mt.JobGroup || cast('\' as varchar(1)) || m.jobmst_name) as varchar(1000)) else mt.JobGroup end JobGroup  ,
  case when D.jobdtl_inhevent = 'Y' then mt.calid else m.evntmst_id end as calid,
  case when D.jobdtl_inhagent  = 'Y' then mt.nodmst_id else D.nodmst_id end as nodmst_id ,
  m.jobcls_id,
  case when D.jobdtl_inhagent = 'Y' then mt.nodlstmst_id else D.nodlstmst_id end as nodlstmst_id,
  case when D.jobdtl_inhtime  = 'Y' then mt.jobdtl_fromtm  else  D.jobdtl_fromtm end as jobdtl_fromtm,
  case when D.jobdtl_inhtime = 'Y' then mt.jobdtl_untiltm else  D.jobdtl_untiltm end as jobdtl_untiltm,
  m.jobmst_type,
  d.jobdtl_cmd,
  d.jobdtl_params,
  m.jobmst_desc,
  m.jobmst_runbook,
  m.jobmst_active,
  m.jobmst_owner,
  m.jobmst_alias,
  d.JOBDTL_PROXY,
  D.JOBDTL_INTERVAL,
  D.JOBDTL_INTERVALCNT,
  D.JOBDTL_NORMALEXIT,
  D.JOBDTL_PRIORITY,
  D.SERVICEMST_ID,
  D.jobdtl_inhevent,
  D.jobdtl_inhagent,
  D.jobdtl_inhtime,
  d.jobdtl_minrun,
  d.jobdtl_maxrun,
  d.jobdtl_concur,
  d.jobdtl_duration,
  d.jobdtl_retnsn,
  d.jobdtl_rerun,
  d.jobdtl_carryover,
  substr(d.jobdtl_extinfo,1,4000) jobdtl_extinfo1,
  substr(d.jobdtl_extinfo,4001,4000) jobdtl_extinfo2,
  substr(d.jobdtl_extinfo,8001,4000) jobdtl_extinfo3,
  d.jobdtl_saveoutput,
  d.jobdtl_trackmethod,
  d.jobdtl_trackcmd,
  m.jobmst_lstchgtm
FROM tidal.jobmst M, JobDtlExtract MT, tidal.jobdtl D
  where MT.jobmst_id = M.jobmst_prntid  and M.jobdtl_id = D.jobdtl_id and not m.jobmst_dirty='X'
 )
SELECT jobmst_id,
  Case when jobmst_type = 1 then 'JobGroup' 
    when jobmst_type=2 then 'Job'
    when jobmst_type=6 then 'FTP'          
    when jobmst_type=7 then 'AS400' 
    when jobmst_type=8 then 'Adapter' 
    else to_char(jobmst_type) end JobType,
  JobName,
  JobGroup,
  coalesce(evntmst_name,'') Calendar,
  jde.nodmst_id,
  n.NODMST_NAME Agent,
  coalesce(jc.jobcls_name,'') Jobclass,  
  cast(jde.jobdtl_cmd as varchar(4000)) jobdtl_cmd,
  cast(jobdtl_params as varchar(4000)) jobdtl_params,
  jde.jobmst_active,
  owner_name "Owner",
  U.USRMST_NAME RuntimeUser,
  JOBDTL_INHAGENT,
  jobdtl_INHEVENT,
  jobdtl_INHTIME,
  jobdtl_duration,
  jobdtl_trackmethod,
  jobdtl_trackcmd,
  jobmst_desc,
  jobmst_runbook,
  jobdtl_fromtm,
  jobdtl_untiltm,
  jobdtl_extinfo1 "ExtendedInfo1",
  jobdtl_extinfo2 "ExtendedInfo2",
  jobdtl_extinfo3 "ExtendedInfo3",
  {% block columns %}{% endblock %}
  '' "ExtendedInfo"
From JobDtlExtract jde
    left outer join tidal.EVNTMST e on jde.calid= e.evntmst_id
    left outer join tidal.NODMST n on jde.nodmst_id= n.nodmst_id
  left outer join tidal.NODLSTMS nl on jde.nodlstmst_id = nl.nodlstmst_id
  left outer join tidal.OWNER o on jde.jobmst_owner = o.owner_id
  left outer join tidal.USRMST U on jde.jobdtl_proxy = U.USRMST_ID
  left outer join tidal.SERVICEMST S on jde.SERVICEMST_ID = S.SERVICEMST_ID 
  left outer join JOBCLS JC on jde.JOBCLS_ID = JC.JOBCLS_ID 
   {% block content %}{% endblock %}
]]>
        </querytext_oracle>
    </query>
  <query>
        <queryname>job_dep_details</queryname>
        <category>hidden</category>
        <linkquery></linkquery><querydescription></querydescription>
        <db>admiral</db>
        <template_type></template_type>
        <querytext_sqlserver>
            <![CDATA[
 SELECT        
--jobdep.jobmst_id, 
case when jobdep.jobdep_type = '1' then 'Job' when jobdep.jobdep_type = '2' then 'File' when jobdep.jobdep_type = '3' then 'Variable' end 'DepType', 
--jobdep.jobdep_jobmst, 
isnull(jobmst_dep.jobmst_name,'') 'Dependent_Jobname',
isnull(jobmst_dep.jobmst_prntname,'') 'Dependent_JobGroup',

--jobdep.jobdep_operator, 
--jobdep.jobdep_status, 
--jobdep.jobdep_joblogic, 
--jobdep.jobdep_ingroup, 
isnull(jobdep.jobdep_filename,'') FileName, 
isnull(varmst.varmst_name,'') Variable
--jobdep.jobdep_value, varmst.varmst_value
FROM            jobdep 
LEFT OUTER JOIN
                         varmst ON jobdep.varmst_id = varmst.varmst_id
LEFT OUTER JOIN
                         jobmst as jobmst_dep ON jobdep.jobdep_jobmst = jobmst_dep.jobmst_id
where jobdep.jobmst_id = '<<jobmst_id:0>>' or '<<jobmst_id:0>>' = '0' 
]]>
        </querytext_sqlserver>
        <querytext_oracle>
            <![CDATA[

]]>
        </querytext_oracle>
    </query>

</queries>
